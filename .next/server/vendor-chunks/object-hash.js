"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/object-hash";
exports.ids = ["vendor-chunks/object-hash"];
exports.modules = {

/***/ "(rsc)/./node_modules/object-hash/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-hash/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\r\n\r\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\n/**\r\n * Exported function\r\n *\r\n * Options:\r\n *\r\n *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'\r\n *  - `excludeValues` {true|*false} hash object keys, values ignored\r\n *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'\r\n *  - `ignoreUnknown` {true|*false} ignore unknown object types\r\n *  - `replacer` optional function that replaces values before hashing\r\n *  - `respectFunctionProperties` {*true|false} consider function properties when hashing\r\n *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing\r\n *  - `respectType` {*true|false} Respect special properties (prototype, constructor)\r\n *    when hashing to distinguish between types\r\n *  - `unorderedArrays` {true|*false} Sort all arrays before hashing\r\n *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing\r\n *  * = default\r\n *\r\n * @param {object} object value to hash\r\n * @param {object} options hashing options\r\n * @return {string} hash value\r\n * @api public\r\n */\r\nexports = module.exports = objectHash;\r\n\r\nfunction objectHash(object, options){\r\n  options = applyDefaults(object, options);\r\n\r\n  return hash(object, options);\r\n}\r\n\r\n/**\r\n * Exported sugar methods\r\n *\r\n * @param {object} object value to hash\r\n * @return {string} hash value\r\n * @api public\r\n */\r\nexports.sha1 = function(object){\r\n  return objectHash(object);\r\n};\r\nexports.keys = function(object){\r\n  return objectHash(object, {excludeValues: true, algorithm: 'sha1', encoding: 'hex'});\r\n};\r\nexports.MD5 = function(object){\r\n  return objectHash(object, {algorithm: 'md5', encoding: 'hex'});\r\n};\r\nexports.keysMD5 = function(object){\r\n  return objectHash(object, {algorithm: 'md5', encoding: 'hex', excludeValues: true});\r\n};\r\n\r\n// Internals\r\nvar hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];\r\nhashes.push('passthrough');\r\nvar encodings = ['buffer', 'hex', 'binary', 'base64'];\r\n\r\nfunction applyDefaults(object, sourceOptions){\r\n  sourceOptions = sourceOptions || {};\r\n\r\n  // create a copy rather than mutating\r\n  var options = {};\r\n  options.algorithm = sourceOptions.algorithm || 'sha1';\r\n  options.encoding = sourceOptions.encoding || 'hex';\r\n  options.excludeValues = sourceOptions.excludeValues ? true : false;\r\n  options.algorithm = options.algorithm.toLowerCase();\r\n  options.encoding = options.encoding.toLowerCase();\r\n  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false\r\n  options.respectType = sourceOptions.respectType === false ? false : true; // default to true\r\n  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;\r\n  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;\r\n  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false\r\n  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false\r\n  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true\r\n  options.replacer = sourceOptions.replacer || undefined;\r\n  options.excludeKeys = sourceOptions.excludeKeys || undefined;\r\n\r\n  if(typeof object === 'undefined') {\r\n    throw new Error('Object argument required.');\r\n  }\r\n\r\n  // if there is a case-insensitive match in the hashes list, accept it\r\n  // (i.e. SHA256 for sha256)\r\n  for (var i = 0; i < hashes.length; ++i) {\r\n    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {\r\n      options.algorithm = hashes[i];\r\n    }\r\n  }\r\n\r\n  if(hashes.indexOf(options.algorithm) === -1){\r\n    throw new Error('Algorithm \"' + options.algorithm + '\"  not supported. ' +\r\n      'supported values: ' + hashes.join(', '));\r\n  }\r\n\r\n  if(encodings.indexOf(options.encoding) === -1 &&\r\n     options.algorithm !== 'passthrough'){\r\n    throw new Error('Encoding \"' + options.encoding + '\"  not supported. ' +\r\n      'supported values: ' + encodings.join(', '));\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\n/** Check if the given function is a native function */\r\nfunction isNativeFunction(f) {\r\n  if ((typeof f) !== 'function') {\r\n    return false;\r\n  }\r\n  var exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i;\r\n  return exp.exec(Function.prototype.toString.call(f)) != null;\r\n}\r\n\r\nfunction hash(object, options) {\r\n  var hashingStream;\r\n\r\n  if (options.algorithm !== 'passthrough') {\r\n    hashingStream = crypto.createHash(options.algorithm);\r\n  } else {\r\n    hashingStream = new PassThrough();\r\n  }\r\n\r\n  if (typeof hashingStream.write === 'undefined') {\r\n    hashingStream.write = hashingStream.update;\r\n    hashingStream.end   = hashingStream.update;\r\n  }\r\n\r\n  var hasher = typeHasher(options, hashingStream);\r\n  hasher.dispatch(object);\r\n  if (!hashingStream.update) {\r\n    hashingStream.end('');\r\n  }\r\n\r\n  if (hashingStream.digest) {\r\n    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);\r\n  }\r\n\r\n  var buf = hashingStream.read();\r\n  if (options.encoding === 'buffer') {\r\n    return buf;\r\n  }\r\n\r\n  return buf.toString(options.encoding);\r\n}\r\n\r\n/**\r\n * Expose streaming API\r\n *\r\n * @param {object} object  Value to serialize\r\n * @param {object} options  Options, as for hash()\r\n * @param {object} stream  A stream to write the serializiation to\r\n * @api public\r\n */\r\nexports.writeToStream = function(object, options, stream) {\r\n  if (typeof stream === 'undefined') {\r\n    stream = options;\r\n    options = {};\r\n  }\r\n\r\n  options = applyDefaults(object, options);\r\n\r\n  return typeHasher(options, stream).dispatch(object);\r\n};\r\n\r\nfunction typeHasher(options, writeTo, context){\r\n  context = context || [];\r\n  var write = function(str) {\r\n    if (writeTo.update) {\r\n      return writeTo.update(str, 'utf8');\r\n    } else {\r\n      return writeTo.write(str, 'utf8');\r\n    }\r\n  };\r\n\r\n  return {\r\n    dispatch: function(value){\r\n      if (options.replacer) {\r\n        value = options.replacer(value);\r\n      }\r\n\r\n      var type = typeof value;\r\n      if (value === null) {\r\n        type = 'null';\r\n      }\r\n\r\n      //console.log(\"[DEBUG] Dispatch: \", value, \"->\", type, \" -> \", \"_\" + type);\r\n\r\n      return this['_' + type](value);\r\n    },\r\n    _object: function(object) {\r\n      var pattern = (/\\[object (.*)\\]/i);\r\n      var objString = Object.prototype.toString.call(object);\r\n      var objType = pattern.exec(objString);\r\n      if (!objType) { // object type did not match [object ...]\r\n        objType = 'unknown:[' + objString + ']';\r\n      } else {\r\n        objType = objType[1]; // take only the class name\r\n      }\r\n\r\n      objType = objType.toLowerCase();\r\n\r\n      var objectNumber = null;\r\n\r\n      if ((objectNumber = context.indexOf(object)) >= 0) {\r\n        return this.dispatch('[CIRCULAR:' + objectNumber + ']');\r\n      } else {\r\n        context.push(object);\r\n      }\r\n\r\n      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) {\r\n        write('buffer:');\r\n        return write(object);\r\n      }\r\n\r\n      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') {\r\n        if(this['_' + objType]) {\r\n          this['_' + objType](object);\r\n        } else if (options.ignoreUnknown) {\r\n          return write('[' + objType + ']');\r\n        } else {\r\n          throw new Error('Unknown object type \"' + objType + '\"');\r\n        }\r\n      }else{\r\n        var keys = Object.keys(object);\r\n        if (options.unorderedObjects) {\r\n          keys = keys.sort();\r\n        }\r\n        // Make sure to incorporate special properties, so\r\n        // Types with different prototypes will produce\r\n        // a different hash and objects derived from\r\n        // different functions (`new Foo`, `new Bar`) will\r\n        // produce different hashes.\r\n        // We never do this for native functions since some\r\n        // seem to break because of that.\r\n        if (options.respectType !== false && !isNativeFunction(object)) {\r\n          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');\r\n        }\r\n\r\n        if (options.excludeKeys) {\r\n          keys = keys.filter(function(key) { return !options.excludeKeys(key); });\r\n        }\r\n\r\n        write('object:' + keys.length + ':');\r\n        var self = this;\r\n        return keys.forEach(function(key){\r\n          self.dispatch(key);\r\n          write(':');\r\n          if(!options.excludeValues) {\r\n            self.dispatch(object[key]);\r\n          }\r\n          write(',');\r\n        });\r\n      }\r\n    },\r\n    _array: function(arr, unordered){\r\n      unordered = typeof unordered !== 'undefined' ? unordered :\r\n        options.unorderedArrays !== false; // default to options.unorderedArrays\r\n\r\n      var self = this;\r\n      write('array:' + arr.length + ':');\r\n      if (!unordered || arr.length <= 1) {\r\n        return arr.forEach(function(entry) {\r\n          return self.dispatch(entry);\r\n        });\r\n      }\r\n\r\n      // the unordered case is a little more complicated:\r\n      // since there is no canonical ordering on objects,\r\n      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,\r\n      // we first serialize each entry using a PassThrough stream\r\n      // before sorting.\r\n      // also: we can’t use the same context array for all entries\r\n      // since the order of hashing should *not* matter. instead,\r\n      // we keep track of the additions to a copy of the context array\r\n      // and add all of them to the global context array when we’re done\r\n      var contextAdditions = [];\r\n      var entries = arr.map(function(entry) {\r\n        var strm = new PassThrough();\r\n        var localContext = context.slice(); // make copy\r\n        var hasher = typeHasher(options, strm, localContext);\r\n        hasher.dispatch(entry);\r\n        // take only what was added to localContext and append it to contextAdditions\r\n        contextAdditions = contextAdditions.concat(localContext.slice(context.length));\r\n        return strm.read().toString();\r\n      });\r\n      context = context.concat(contextAdditions);\r\n      entries.sort();\r\n      return this._array(entries, false);\r\n    },\r\n    _date: function(date){\r\n      return write('date:' + date.toJSON());\r\n    },\r\n    _symbol: function(sym){\r\n      return write('symbol:' + sym.toString());\r\n    },\r\n    _error: function(err){\r\n      return write('error:' + err.toString());\r\n    },\r\n    _boolean: function(bool){\r\n      return write('bool:' + bool.toString());\r\n    },\r\n    _string: function(string){\r\n      write('string:' + string.length + ':');\r\n      write(string.toString());\r\n    },\r\n    _function: function(fn){\r\n      write('fn:');\r\n      if (isNativeFunction(fn)) {\r\n        this.dispatch('[native]');\r\n      } else {\r\n        this.dispatch(fn.toString());\r\n      }\r\n\r\n      if (options.respectFunctionNames !== false) {\r\n        // Make sure we can still distinguish native functions\r\n        // by their name, otherwise String and Function will\r\n        // have the same hash\r\n        this.dispatch(\"function-name:\" + String(fn.name));\r\n      }\r\n\r\n      if (options.respectFunctionProperties) {\r\n        this._object(fn);\r\n      }\r\n    },\r\n    _number: function(number){\r\n      return write('number:' + number.toString());\r\n    },\r\n    _xml: function(xml){\r\n      return write('xml:' + xml.toString());\r\n    },\r\n    _null: function() {\r\n      return write('Null');\r\n    },\r\n    _undefined: function() {\r\n      return write('Undefined');\r\n    },\r\n    _regexp: function(regex){\r\n      return write('regex:' + regex.toString());\r\n    },\r\n    _uint8array: function(arr){\r\n      write('uint8array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _uint8clampedarray: function(arr){\r\n      write('uint8clampedarray:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _int8array: function(arr){\r\n      write('int8array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _uint16array: function(arr){\r\n      write('uint16array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _int16array: function(arr){\r\n      write('int16array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _uint32array: function(arr){\r\n      write('uint32array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _int32array: function(arr){\r\n      write('int32array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _float32array: function(arr){\r\n      write('float32array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _float64array: function(arr){\r\n      write('float64array:');\r\n      return this.dispatch(Array.prototype.slice.call(arr));\r\n    },\r\n    _arraybuffer: function(arr){\r\n      write('arraybuffer:');\r\n      return this.dispatch(new Uint8Array(arr));\r\n    },\r\n    _url: function(url) {\r\n      return write('url:' + url.toString(), 'utf8');\r\n    },\r\n    _map: function(map) {\r\n      write('map:');\r\n      var arr = Array.from(map);\r\n      return this._array(arr, options.unorderedSets !== false);\r\n    },\r\n    _set: function(set) {\r\n      write('set:');\r\n      var arr = Array.from(set);\r\n      return this._array(arr, options.unorderedSets !== false);\r\n    },\r\n    _file: function(file) {\r\n      write('file:');\r\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\r\n    },\r\n    _blob: function() {\r\n      if (options.ignoreUnknown) {\r\n        return write('[blob]');\r\n      }\r\n\r\n      throw Error('Hashing Blob objects is currently not supported\\n' +\r\n        '(see https://github.com/puleos/object-hash/issues/26)\\n' +\r\n        'Use \"options.replacer\" or \"options.ignoreUnknown\"\\n');\r\n    },\r\n    _domwindow: function() { return write('domwindow'); },\r\n    _bigint: function(number){\r\n      return write('bigint:' + number.toString());\r\n    },\r\n    /* Node.js standard native objects */\r\n    _process: function() { return write('process'); },\r\n    _timer: function() { return write('timer'); },\r\n    _pipe: function() { return write('pipe'); },\r\n    _tcp: function() { return write('tcp'); },\r\n    _udp: function() { return write('udp'); },\r\n    _tty: function() { return write('tty'); },\r\n    _statwatcher: function() { return write('statwatcher'); },\r\n    _securecontext: function() { return write('securecontext'); },\r\n    _connection: function() { return write('connection'); },\r\n    _zlib: function() { return write('zlib'); },\r\n    _context: function() { return write('context'); },\r\n    _nodescript: function() { return write('nodescript'); },\r\n    _httpparser: function() { return write('httpparser'); },\r\n    _dataview: function() { return write('dataview'); },\r\n    _signal: function() { return write('signal'); },\r\n    _fsevent: function() { return write('fsevent'); },\r\n    _tlswrap: function() { return write('tlswrap'); },\r\n  };\r\n}\r\n\r\n// Mini-implementation of stream.PassThrough\r\n// We are far from having need for the full implementation, and we can\r\n// make assumptions like \"many writes, then only one final read\"\r\n// and we can ignore encoding specifics\r\nfunction PassThrough() {\r\n  return {\r\n    buf: '',\r\n\r\n    write: function(b) {\r\n      this.buf += b;\r\n    },\r\n\r\n    end: function(b) {\r\n      this.buf += b;\r\n    },\r\n\r\n    read: function() {\r\n      return this.buf;\r\n    }\r\n  };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWhhc2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRCw4QkFBOEIsYUFBYTtBQUMzQyxxQkFBcUIsYUFBYTtBQUNsQztBQUNBLHlCQUF5QixhQUFhO0FBQ3RDLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZCQUE2Qix3REFBd0Q7QUFDckY7QUFDQSxXQUFXO0FBQ1gsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBLGVBQWU7QUFDZiw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYsZ0ZBQWdGO0FBQ2hGLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSyxHQUFHLEtBQUssS0FBSyxLQUFLLEdBQUcsS0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQseUJBQXlCLHdCQUF3QjtBQUNqRCx3QkFBd0IsdUJBQXVCO0FBQy9DLHVCQUF1QixzQkFBc0I7QUFDN0MsdUJBQXVCLHNCQUFzQjtBQUM3Qyx1QkFBdUIsc0JBQXNCO0FBQzdDLCtCQUErQiw4QkFBOEI7QUFDN0QsaUNBQWlDLGdDQUFnQztBQUNqRSw4QkFBOEIsNkJBQTZCO0FBQzNELHdCQUF3Qix1QkFBdUI7QUFDL0MsMkJBQTJCLDBCQUEwQjtBQUNyRCw4QkFBOEIsNkJBQTZCO0FBQzNELDhCQUE4Qiw2QkFBNkI7QUFDM0QsNEJBQTRCLDJCQUEyQjtBQUN2RCwwQkFBMEIseUJBQXlCO0FBQ25ELDJCQUEyQiwwQkFBMEI7QUFDckQsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL29iamVjdC1oYXNoL2luZGV4LmpzP2ZjMTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9ydGVkIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIE9wdGlvbnM6XHJcbiAqXHJcbiAqICAtIGBhbGdvcml0aG1gIGhhc2ggYWxnbyB0byBiZSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2U6IConc2hhMScsICdtZDUnXHJcbiAqICAtIGBleGNsdWRlVmFsdWVzYCB7dHJ1ZXwqZmFsc2V9IGhhc2ggb2JqZWN0IGtleXMsIHZhbHVlcyBpZ25vcmVkXHJcbiAqICAtIGBlbmNvZGluZ2AgaGFzaCBlbmNvZGluZywgc3VwcG9ydHMgJ2J1ZmZlcicsICcqaGV4JywgJ2JpbmFyeScsICdiYXNlNjQnXHJcbiAqICAtIGBpZ25vcmVVbmtub3duYCB7dHJ1ZXwqZmFsc2V9IGlnbm9yZSB1bmtub3duIG9iamVjdCB0eXBlc1xyXG4gKiAgLSBgcmVwbGFjZXJgIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZXMgdmFsdWVzIGJlZm9yZSBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzYCB7KnRydWV8ZmFsc2V9IGNvbnNpZGVyIGZ1bmN0aW9uIHByb3BlcnRpZXMgd2hlbiBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0RnVuY3Rpb25OYW1lc2Ageyp0cnVlfGZhbHNlfSBjb25zaWRlciAnbmFtZScgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGZvciBoYXNoaW5nXHJcbiAqICAtIGByZXNwZWN0VHlwZWAgeyp0cnVlfGZhbHNlfSBSZXNwZWN0IHNwZWNpYWwgcHJvcGVydGllcyAocHJvdG90eXBlLCBjb25zdHJ1Y3RvcilcclxuICogICAgd2hlbiBoYXNoaW5nIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdHlwZXNcclxuICogIC0gYHVub3JkZXJlZEFycmF5c2Age3RydWV8KmZhbHNlfSBTb3J0IGFsbCBhcnJheXMgYmVmb3JlIGhhc2hpbmdcclxuICogIC0gYHVub3JkZXJlZFNldHNgIHsqdHJ1ZXxmYWxzZX0gU29ydCBgU2V0YCBhbmQgYE1hcGAgaW5zdGFuY2VzIGJlZm9yZSBoYXNoaW5nXHJcbiAqICAqID0gZGVmYXVsdFxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IHZhbHVlIHRvIGhhc2hcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgaGFzaGluZyBvcHRpb25zXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gaGFzaCB2YWx1ZVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gb2JqZWN0SGFzaDtcclxuXHJcbmZ1bmN0aW9uIG9iamVjdEhhc2gob2JqZWN0LCBvcHRpb25zKXtcclxuICBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhvYmplY3QsIG9wdGlvbnMpO1xyXG5cclxuICByZXR1cm4gaGFzaChvYmplY3QsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogRXhwb3J0ZWQgc3VnYXIgbWV0aG9kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IHZhbHVlIHRvIGhhc2hcclxuICogQHJldHVybiB7c3RyaW5nfSBoYXNoIHZhbHVlXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLnNoYTEgPSBmdW5jdGlvbihvYmplY3Qpe1xyXG4gIHJldHVybiBvYmplY3RIYXNoKG9iamVjdCk7XHJcbn07XHJcbmV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7ZXhjbHVkZVZhbHVlczogdHJ1ZSwgYWxnb3JpdGhtOiAnc2hhMScsIGVuY29kaW5nOiAnaGV4J30pO1xyXG59O1xyXG5leHBvcnRzLk1ENSA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7YWxnb3JpdGhtOiAnbWQ1JywgZW5jb2Rpbmc6ICdoZXgnfSk7XHJcbn07XHJcbmV4cG9ydHMua2V5c01ENSA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgcmV0dXJuIG9iamVjdEhhc2gob2JqZWN0LCB7YWxnb3JpdGhtOiAnbWQ1JywgZW5jb2Rpbmc6ICdoZXgnLCBleGNsdWRlVmFsdWVzOiB0cnVlfSk7XHJcbn07XHJcblxyXG4vLyBJbnRlcm5hbHNcclxudmFyIGhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMgPyBjcnlwdG8uZ2V0SGFzaGVzKCkuc2xpY2UoKSA6IFsnc2hhMScsICdtZDUnXTtcclxuaGFzaGVzLnB1c2goJ3Bhc3N0aHJvdWdoJyk7XHJcbnZhciBlbmNvZGluZ3MgPSBbJ2J1ZmZlcicsICdoZXgnLCAnYmluYXJ5JywgJ2Jhc2U2NCddO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvYmplY3QsIHNvdXJjZU9wdGlvbnMpe1xyXG4gIHNvdXJjZU9wdGlvbnMgPSBzb3VyY2VPcHRpb25zIHx8IHt9O1xyXG5cclxuICAvLyBjcmVhdGUgYSBjb3B5IHJhdGhlciB0aGFuIG11dGF0aW5nXHJcbiAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICBvcHRpb25zLmFsZ29yaXRobSA9IHNvdXJjZU9wdGlvbnMuYWxnb3JpdGhtIHx8ICdzaGExJztcclxuICBvcHRpb25zLmVuY29kaW5nID0gc291cmNlT3B0aW9ucy5lbmNvZGluZyB8fCAnaGV4JztcclxuICBvcHRpb25zLmV4Y2x1ZGVWYWx1ZXMgPSBzb3VyY2VPcHRpb25zLmV4Y2x1ZGVWYWx1ZXMgPyB0cnVlIDogZmFsc2U7XHJcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xyXG4gIG9wdGlvbnMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgb3B0aW9ucy5pZ25vcmVVbmtub3duID0gc291cmNlT3B0aW9ucy5pZ25vcmVVbmtub3duICE9PSB0cnVlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIGZhbHNlXHJcbiAgb3B0aW9ucy5yZXNwZWN0VHlwZSA9IHNvdXJjZU9wdGlvbnMucmVzcGVjdFR5cGUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIHRydWVcclxuICBvcHRpb25zLnJlc3BlY3RGdW5jdGlvbk5hbWVzID0gc291cmNlT3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25OYW1lcyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XHJcbiAgb3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzID0gc291cmNlT3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcclxuICBvcHRpb25zLnVub3JkZXJlZEFycmF5cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkQXJyYXlzICE9PSB0cnVlID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRvIGZhbHNlXHJcbiAgb3B0aW9ucy51bm9yZGVyZWRTZXRzID0gc291cmNlT3B0aW9ucy51bm9yZGVyZWRTZXRzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0byBmYWxzZVxyXG4gIG9wdGlvbnMudW5vcmRlcmVkT2JqZWN0cyA9IHNvdXJjZU9wdGlvbnMudW5vcmRlcmVkT2JqZWN0cyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdG8gdHJ1ZVxyXG4gIG9wdGlvbnMucmVwbGFjZXIgPSBzb3VyY2VPcHRpb25zLnJlcGxhY2VyIHx8IHVuZGVmaW5lZDtcclxuICBvcHRpb25zLmV4Y2x1ZGVLZXlzID0gc291cmNlT3B0aW9ucy5leGNsdWRlS2V5cyB8fCB1bmRlZmluZWQ7XHJcblxyXG4gIGlmKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBhcmd1bWVudCByZXF1aXJlZC4nKTtcclxuICB9XHJcblxyXG4gIC8vIGlmIHRoZXJlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBpbiB0aGUgaGFzaGVzIGxpc3QsIGFjY2VwdCBpdFxyXG4gIC8vIChpLmUuIFNIQTI1NiBmb3Igc2hhMjU2KVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoaGFzaGVzW2ldLnRvTG93ZXJDYXNlKCkgPT09IG9wdGlvbnMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSBoYXNoZXNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZihoYXNoZXMuaW5kZXhPZihvcHRpb25zLmFsZ29yaXRobSkgPT09IC0xKXtcclxuICAgIHRocm93IG5ldyBFcnJvcignQWxnb3JpdGhtIFwiJyArIG9wdGlvbnMuYWxnb3JpdGhtICsgJ1wiICBub3Qgc3VwcG9ydGVkLiAnICtcclxuICAgICAgJ3N1cHBvcnRlZCB2YWx1ZXM6ICcgKyBoYXNoZXMuam9pbignLCAnKSk7XHJcbiAgfVxyXG5cclxuICBpZihlbmNvZGluZ3MuaW5kZXhPZihvcHRpb25zLmVuY29kaW5nKSA9PT0gLTEgJiZcclxuICAgICBvcHRpb25zLmFsZ29yaXRobSAhPT0gJ3Bhc3N0aHJvdWdoJyl7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIgIG5vdCBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAnc3VwcG9ydGVkIHZhbHVlczogJyArIGVuY29kaW5ncy5qb2luKCcsICcpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvcHRpb25zO1xyXG59XHJcblxyXG4vKiogQ2hlY2sgaWYgdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIGEgbmF0aXZlIGZ1bmN0aW9uICovXHJcbmZ1bmN0aW9uIGlzTmF0aXZlRnVuY3Rpb24oZikge1xyXG4gIGlmICgodHlwZW9mIGYpICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBleHAgPSAvXmZ1bmN0aW9uXFxzK1xcdypcXHMqXFwoXFxzKlxcKVxccyp7XFxzK1xcW25hdGl2ZSBjb2RlXFxdXFxzK30kL2k7XHJcbiAgcmV0dXJuIGV4cC5leGVjKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGYpKSAhPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNoKG9iamVjdCwgb3B0aW9ucykge1xyXG4gIHZhciBoYXNoaW5nU3RyZWFtO1xyXG5cclxuICBpZiAob3B0aW9ucy5hbGdvcml0aG0gIT09ICdwYXNzdGhyb3VnaCcpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0gPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRpb25zLmFsZ29yaXRobSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGhhc2hpbmdTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgaGFzaGluZ1N0cmVhbS53cml0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0ud3JpdGUgPSBoYXNoaW5nU3RyZWFtLnVwZGF0ZTtcclxuICAgIGhhc2hpbmdTdHJlYW0uZW5kICAgPSBoYXNoaW5nU3RyZWFtLnVwZGF0ZTtcclxuICB9XHJcblxyXG4gIHZhciBoYXNoZXIgPSB0eXBlSGFzaGVyKG9wdGlvbnMsIGhhc2hpbmdTdHJlYW0pO1xyXG4gIGhhc2hlci5kaXNwYXRjaChvYmplY3QpO1xyXG4gIGlmICghaGFzaGluZ1N0cmVhbS51cGRhdGUpIHtcclxuICAgIGhhc2hpbmdTdHJlYW0uZW5kKCcnKTtcclxuICB9XHJcblxyXG4gIGlmIChoYXNoaW5nU3RyZWFtLmRpZ2VzdCkge1xyXG4gICAgcmV0dXJuIGhhc2hpbmdTdHJlYW0uZGlnZXN0KG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInID8gdW5kZWZpbmVkIDogb3B0aW9ucy5lbmNvZGluZyk7XHJcbiAgfVxyXG5cclxuICB2YXIgYnVmID0gaGFzaGluZ1N0cmVhbS5yZWFkKCk7XHJcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XHJcbiAgICByZXR1cm4gYnVmO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBzdHJlYW1pbmcgQVBJXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIFZhbHVlIHRvIHNlcmlhbGl6ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgT3B0aW9ucywgYXMgZm9yIGhhc2goKVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc3RyZWFtICBBIHN0cmVhbSB0byB3cml0ZSB0aGUgc2VyaWFsaXppYXRpb24gdG9cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMud3JpdGVUb1N0cmVhbSA9IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucywgc3RyZWFtKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBzdHJlYW0gPSBvcHRpb25zO1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdHMob2JqZWN0LCBvcHRpb25zKTtcclxuXHJcbiAgcmV0dXJuIHR5cGVIYXNoZXIob3B0aW9ucywgc3RyZWFtKS5kaXNwYXRjaChvYmplY3QpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdHlwZUhhc2hlcihvcHRpb25zLCB3cml0ZVRvLCBjb250ZXh0KXtcclxuICBjb250ZXh0ID0gY29udGV4dCB8fCBbXTtcclxuICB2YXIgd3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIGlmICh3cml0ZVRvLnVwZGF0ZSkge1xyXG4gICAgICByZXR1cm4gd3JpdGVUby51cGRhdGUoc3RyLCAndXRmOCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHdyaXRlVG8ud3JpdGUoc3RyLCAndXRmOCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICBpZiAob3B0aW9ucy5yZXBsYWNlcikge1xyXG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5yZXBsYWNlcih2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICB0eXBlID0gJ251bGwnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL2NvbnNvbGUubG9nKFwiW0RFQlVHXSBEaXNwYXRjaDogXCIsIHZhbHVlLCBcIi0+XCIsIHR5cGUsIFwiIC0+IFwiLCBcIl9cIiArIHR5cGUpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXNbJ18nICsgdHlwZV0odmFsdWUpO1xyXG4gICAgfSxcclxuICAgIF9vYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICB2YXIgcGF0dGVybiA9ICgvXFxbb2JqZWN0ICguKilcXF0vaSk7XHJcbiAgICAgIHZhciBvYmpTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcclxuICAgICAgdmFyIG9ialR5cGUgPSBwYXR0ZXJuLmV4ZWMob2JqU3RyaW5nKTtcclxuICAgICAgaWYgKCFvYmpUeXBlKSB7IC8vIG9iamVjdCB0eXBlIGRpZCBub3QgbWF0Y2ggW29iamVjdCAuLi5dXHJcbiAgICAgICAgb2JqVHlwZSA9ICd1bmtub3duOlsnICsgb2JqU3RyaW5nICsgJ10nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9ialR5cGUgPSBvYmpUeXBlWzFdOyAvLyB0YWtlIG9ubHkgdGhlIGNsYXNzIG5hbWVcclxuICAgICAgfVxyXG5cclxuICAgICAgb2JqVHlwZSA9IG9ialR5cGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIHZhciBvYmplY3ROdW1iZXIgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKChvYmplY3ROdW1iZXIgPSBjb250ZXh0LmluZGV4T2Yob2JqZWN0KSkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKCdbQ0lSQ1VMQVI6JyArIG9iamVjdE51bWJlciArICddJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKG9iamVjdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHtcclxuICAgICAgICB3cml0ZSgnYnVmZmVyOicpO1xyXG4gICAgICAgIHJldHVybiB3cml0ZShvYmplY3QpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihvYmpUeXBlICE9PSAnb2JqZWN0JyAmJiBvYmpUeXBlICE9PSAnZnVuY3Rpb24nICYmIG9ialR5cGUgIT09ICdhc3luY2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmKHRoaXNbJ18nICsgb2JqVHlwZV0pIHtcclxuICAgICAgICAgIHRoaXNbJ18nICsgb2JqVHlwZV0ob2JqZWN0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaWdub3JlVW5rbm93bikge1xyXG4gICAgICAgICAgcmV0dXJuIHdyaXRlKCdbJyArIG9ialR5cGUgKyAnXScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb2JqZWN0IHR5cGUgXCInICsgb2JqVHlwZSArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnVub3JkZXJlZE9iamVjdHMpIHtcclxuICAgICAgICAgIGtleXMgPSBrZXlzLnNvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGluY29ycG9yYXRlIHNwZWNpYWwgcHJvcGVydGllcywgc29cclxuICAgICAgICAvLyBUeXBlcyB3aXRoIGRpZmZlcmVudCBwcm90b3R5cGVzIHdpbGwgcHJvZHVjZVxyXG4gICAgICAgIC8vIGEgZGlmZmVyZW50IGhhc2ggYW5kIG9iamVjdHMgZGVyaXZlZCBmcm9tXHJcbiAgICAgICAgLy8gZGlmZmVyZW50IGZ1bmN0aW9ucyAoYG5ldyBGb29gLCBgbmV3IEJhcmApIHdpbGxcclxuICAgICAgICAvLyBwcm9kdWNlIGRpZmZlcmVudCBoYXNoZXMuXHJcbiAgICAgICAgLy8gV2UgbmV2ZXIgZG8gdGhpcyBmb3IgbmF0aXZlIGZ1bmN0aW9ucyBzaW5jZSBzb21lXHJcbiAgICAgICAgLy8gc2VlbSB0byBicmVhayBiZWNhdXNlIG9mIHRoYXQuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcGVjdFR5cGUgIT09IGZhbHNlICYmICFpc05hdGl2ZUZ1bmN0aW9uKG9iamVjdCkpIHtcclxuICAgICAgICAgIGtleXMuc3BsaWNlKDAsIDAsICdwcm90b3R5cGUnLCAnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5leGNsdWRlS2V5cykge1xyXG4gICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gIW9wdGlvbnMuZXhjbHVkZUtleXMoa2V5KTsgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3cml0ZSgnb2JqZWN0OicgKyBrZXlzLmxlbmd0aCArICc6Jyk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goa2V5KTtcclxuICAgICAgICAgIHdyaXRlKCc6Jyk7XHJcbiAgICAgICAgICBpZighb3B0aW9ucy5leGNsdWRlVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2gob2JqZWN0W2tleV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd3JpdGUoJywnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9hcnJheTogZnVuY3Rpb24oYXJyLCB1bm9yZGVyZWQpe1xyXG4gICAgICB1bm9yZGVyZWQgPSB0eXBlb2YgdW5vcmRlcmVkICE9PSAndW5kZWZpbmVkJyA/IHVub3JkZXJlZCA6XHJcbiAgICAgICAgb3B0aW9ucy51bm9yZGVyZWRBcnJheXMgIT09IGZhbHNlOyAvLyBkZWZhdWx0IHRvIG9wdGlvbnMudW5vcmRlcmVkQXJyYXlzXHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHdyaXRlKCdhcnJheTonICsgYXJyLmxlbmd0aCArICc6Jyk7XHJcbiAgICAgIGlmICghdW5vcmRlcmVkIHx8IGFyci5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGlzcGF0Y2goZW50cnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0aGUgdW5vcmRlcmVkIGNhc2UgaXMgYSBsaXR0bGUgbW9yZSBjb21wbGljYXRlZDpcclxuICAgICAgLy8gc2luY2UgdGhlcmUgaXMgbm8gY2Fub25pY2FsIG9yZGVyaW5nIG9uIG9iamVjdHMsXHJcbiAgICAgIC8vIGkuZS4ge2E6MX0gPCB7YToyfSBhbmQge2E6MX0gPiB7YToyfSBhcmUgYm90aCBmYWxzZSxcclxuICAgICAgLy8gd2UgZmlyc3Qgc2VyaWFsaXplIGVhY2ggZW50cnkgdXNpbmcgYSBQYXNzVGhyb3VnaCBzdHJlYW1cclxuICAgICAgLy8gYmVmb3JlIHNvcnRpbmcuXHJcbiAgICAgIC8vIGFsc286IHdlIGNhbuKAmXQgdXNlIHRoZSBzYW1lIGNvbnRleHQgYXJyYXkgZm9yIGFsbCBlbnRyaWVzXHJcbiAgICAgIC8vIHNpbmNlIHRoZSBvcmRlciBvZiBoYXNoaW5nIHNob3VsZCAqbm90KiBtYXR0ZXIuIGluc3RlYWQsXHJcbiAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGFkZGl0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGNvbnRleHQgYXJyYXlcclxuICAgICAgLy8gYW5kIGFkZCBhbGwgb2YgdGhlbSB0byB0aGUgZ2xvYmFsIGNvbnRleHQgYXJyYXkgd2hlbiB3ZeKAmXJlIGRvbmVcclxuICAgICAgdmFyIGNvbnRleHRBZGRpdGlvbnMgPSBbXTtcclxuICAgICAgdmFyIGVudHJpZXMgPSBhcnIubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XHJcbiAgICAgICAgdmFyIHN0cm0gPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuICAgICAgICB2YXIgbG9jYWxDb250ZXh0ID0gY29udGV4dC5zbGljZSgpOyAvLyBtYWtlIGNvcHlcclxuICAgICAgICB2YXIgaGFzaGVyID0gdHlwZUhhc2hlcihvcHRpb25zLCBzdHJtLCBsb2NhbENvbnRleHQpO1xyXG4gICAgICAgIGhhc2hlci5kaXNwYXRjaChlbnRyeSk7XHJcbiAgICAgICAgLy8gdGFrZSBvbmx5IHdoYXQgd2FzIGFkZGVkIHRvIGxvY2FsQ29udGV4dCBhbmQgYXBwZW5kIGl0IHRvIGNvbnRleHRBZGRpdGlvbnNcclxuICAgICAgICBjb250ZXh0QWRkaXRpb25zID0gY29udGV4dEFkZGl0aW9ucy5jb25jYXQobG9jYWxDb250ZXh0LnNsaWNlKGNvbnRleHQubGVuZ3RoKSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cm0ucmVhZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jb25jYXQoY29udGV4dEFkZGl0aW9ucyk7XHJcbiAgICAgIGVudHJpZXMuc29ydCgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoZW50cmllcywgZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIF9kYXRlOiBmdW5jdGlvbihkYXRlKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdkYXRlOicgKyBkYXRlLnRvSlNPTigpKTtcclxuICAgIH0sXHJcbiAgICBfc3ltYm9sOiBmdW5jdGlvbihzeW0pe1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ3N5bWJvbDonICsgc3ltLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9lcnJvcjogZnVuY3Rpb24oZXJyKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdlcnJvcjonICsgZXJyLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9ib29sZWFuOiBmdW5jdGlvbihib29sKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdib29sOicgKyBib29sLnRvU3RyaW5nKCkpO1xyXG4gICAgfSxcclxuICAgIF9zdHJpbmc6IGZ1bmN0aW9uKHN0cmluZyl7XHJcbiAgICAgIHdyaXRlKCdzdHJpbmc6JyArIHN0cmluZy5sZW5ndGggKyAnOicpO1xyXG4gICAgICB3cml0ZShzdHJpbmcudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX2Z1bmN0aW9uOiBmdW5jdGlvbihmbil7XHJcbiAgICAgIHdyaXRlKCdmbjonKTtcclxuICAgICAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnW25hdGl2ZV0nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoKGZuLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25OYW1lcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN0aWxsIGRpc3Rpbmd1aXNoIG5hdGl2ZSBmdW5jdGlvbnNcclxuICAgICAgICAvLyBieSB0aGVpciBuYW1lLCBvdGhlcndpc2UgU3RyaW5nIGFuZCBGdW5jdGlvbiB3aWxsXHJcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBoYXNoXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImZ1bmN0aW9uLW5hbWU6XCIgKyBTdHJpbmcoZm4ubmFtZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5yZXNwZWN0RnVuY3Rpb25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0KGZuKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9udW1iZXI6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnbnVtYmVyOicgKyBudW1iZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX3htbDogZnVuY3Rpb24oeG1sKXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCd4bWw6JyArIHhtbC50b1N0cmluZygpKTtcclxuICAgIH0sXHJcbiAgICBfbnVsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnTnVsbCcpO1xyXG4gICAgfSxcclxuICAgIF91bmRlZmluZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ1VuZGVmaW5lZCcpO1xyXG4gICAgfSxcclxuICAgIF9yZWdleHA6IGZ1bmN0aW9uKHJlZ2V4KXtcclxuICAgICAgcmV0dXJuIHdyaXRlKCdyZWdleDonICsgcmVnZXgudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgX3VpbnQ4YXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50OGFycmF5OicpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpKTtcclxuICAgIH0sXHJcbiAgICBfdWludDhjbGFtcGVkYXJyYXk6IGZ1bmN0aW9uKGFycil7XHJcbiAgICAgIHdyaXRlKCd1aW50OGNsYW1wZWRhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2ludDhhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ2ludDhhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX3VpbnQxNmFycmF5OiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgndWludDE2YXJyYXk6Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xyXG4gICAgfSxcclxuICAgIF9pbnQxNmFycmF5OiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgnaW50MTZhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX3VpbnQzMmFycmF5OiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgndWludDMyYXJyYXk6Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycikpO1xyXG4gICAgfSxcclxuICAgIF9pbnQzMmFycmF5OiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgnaW50MzJhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2Zsb2F0MzJhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ2Zsb2F0MzJhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2Zsb2F0NjRhcnJheTogZnVuY3Rpb24oYXJyKXtcclxuICAgICAgd3JpdGUoJ2Zsb2F0NjRhcnJheTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKSk7XHJcbiAgICB9LFxyXG4gICAgX2FycmF5YnVmZmVyOiBmdW5jdGlvbihhcnIpe1xyXG4gICAgICB3cml0ZSgnYXJyYXlidWZmZXI6Jyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKG5ldyBVaW50OEFycmF5KGFycikpO1xyXG4gICAgfSxcclxuICAgIF91cmw6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICByZXR1cm4gd3JpdGUoJ3VybDonICsgdXJsLnRvU3RyaW5nKCksICd1dGY4Jyk7XHJcbiAgICB9LFxyXG4gICAgX21hcDogZnVuY3Rpb24obWFwKSB7XHJcbiAgICAgIHdyaXRlKCdtYXA6Jyk7XHJcbiAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKG1hcCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheShhcnIsIG9wdGlvbnMudW5vcmRlcmVkU2V0cyAhPT0gZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIF9zZXQ6IGZ1bmN0aW9uKHNldCkge1xyXG4gICAgICB3cml0ZSgnc2V0OicpO1xyXG4gICAgICB2YXIgYXJyID0gQXJyYXkuZnJvbShzZXQpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkoYXJyLCBvcHRpb25zLnVub3JkZXJlZFNldHMgIT09IGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBfZmlsZTogZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICB3cml0ZSgnZmlsZTonKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goW2ZpbGUubmFtZSwgZmlsZS5zaXplLCBmaWxlLnR5cGUsIGZpbGUubGFzdE1vZGZpZWRdKTtcclxuICAgIH0sXHJcbiAgICBfYmxvYjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmlnbm9yZVVua25vd24pIHtcclxuICAgICAgICByZXR1cm4gd3JpdGUoJ1tibG9iXScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvcignSGFzaGluZyBCbG9iIG9iamVjdHMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcXG4nICtcclxuICAgICAgICAnKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHVsZW9zL29iamVjdC1oYXNoL2lzc3Vlcy8yNilcXG4nICtcclxuICAgICAgICAnVXNlIFwib3B0aW9ucy5yZXBsYWNlclwiIG9yIFwib3B0aW9ucy5pZ25vcmVVbmtub3duXCJcXG4nKTtcclxuICAgIH0sXHJcbiAgICBfZG9td2luZG93OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdkb213aW5kb3cnKTsgfSxcclxuICAgIF9iaWdpbnQ6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiB3cml0ZSgnYmlnaW50OicgKyBudW1iZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9LFxyXG4gICAgLyogTm9kZS5qcyBzdGFuZGFyZCBuYXRpdmUgb2JqZWN0cyAqL1xyXG4gICAgX3Byb2Nlc3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3Byb2Nlc3MnKTsgfSxcclxuICAgIF90aW1lcjogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGltZXInKTsgfSxcclxuICAgIF9waXBlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdwaXBlJyk7IH0sXHJcbiAgICBfdGNwOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCd0Y3AnKTsgfSxcclxuICAgIF91ZHA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3VkcCcpOyB9LFxyXG4gICAgX3R0eTogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndHR5Jyk7IH0sXHJcbiAgICBfc3RhdHdhdGNoZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ3N0YXR3YXRjaGVyJyk7IH0sXHJcbiAgICBfc2VjdXJlY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnc2VjdXJlY29udGV4dCcpOyB9LFxyXG4gICAgX2Nvbm5lY3Rpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2Nvbm5lY3Rpb24nKTsgfSxcclxuICAgIF96bGliOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCd6bGliJyk7IH0sXHJcbiAgICBfY29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgnY29udGV4dCcpOyB9LFxyXG4gICAgX25vZGVzY3JpcHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ25vZGVzY3JpcHQnKTsgfSxcclxuICAgIF9odHRwcGFyc2VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdodHRwcGFyc2VyJyk7IH0sXHJcbiAgICBfZGF0YXZpZXc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGUoJ2RhdGF2aWV3Jyk7IH0sXHJcbiAgICBfc2lnbmFsOiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdzaWduYWwnKTsgfSxcclxuICAgIF9mc2V2ZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlKCdmc2V2ZW50Jyk7IH0sXHJcbiAgICBfdGxzd3JhcDogZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZSgndGxzd3JhcCcpOyB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8vIE1pbmktaW1wbGVtZW50YXRpb24gb2Ygc3RyZWFtLlBhc3NUaHJvdWdoXHJcbi8vIFdlIGFyZSBmYXIgZnJvbSBoYXZpbmcgbmVlZCBmb3IgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24sIGFuZCB3ZSBjYW5cclxuLy8gbWFrZSBhc3N1bXB0aW9ucyBsaWtlIFwibWFueSB3cml0ZXMsIHRoZW4gb25seSBvbmUgZmluYWwgcmVhZFwiXHJcbi8vIGFuZCB3ZSBjYW4gaWdub3JlIGVuY29kaW5nIHNwZWNpZmljc1xyXG5mdW5jdGlvbiBQYXNzVGhyb3VnaCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYnVmOiAnJyxcclxuXHJcbiAgICB3cml0ZTogZnVuY3Rpb24oYikge1xyXG4gICAgICB0aGlzLmJ1ZiArPSBiO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmQ6IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgdGhpcy5idWYgKz0gYjtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmJ1ZjtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/object-hash/index.js\n");

/***/ })

};
;