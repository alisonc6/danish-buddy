"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/https-proxy-agent";
exports.ids = ["vendor-chunks/https-proxy-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.HttpsProxyAgent = void 0;\r\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\r\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\r\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\r\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/agent-base/dist/index.js\");\r\nconst url_1 = __webpack_require__(/*! url */ \"url\");\r\nconst parse_proxy_response_1 = __webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\");\r\nconst debug = (0, debug_1.default)('https-proxy-agent');\r\nconst setServernameFromNonIpHost = (options) => {\r\n    if (options.servername === undefined &&\r\n        options.host &&\r\n        !net.isIP(options.host)) {\r\n        return {\r\n            ...options,\r\n            servername: options.host,\r\n        };\r\n    }\r\n    return options;\r\n};\r\n/**\r\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\r\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\r\n *\r\n * Outgoing HTTP requests are first tunneled through the proxy server using the\r\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\r\n * and then the proxy server connects to the destination target and issues the\r\n * HTTP request from the proxy server.\r\n *\r\n * `https:` requests have their socket connection upgraded to TLS once\r\n * the connection to the proxy server has been established.\r\n */\r\nclass HttpsProxyAgent extends agent_base_1.Agent {\r\n    constructor(proxy, opts) {\r\n        super(opts);\r\n        this.options = { path: undefined };\r\n        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;\r\n        this.proxyHeaders = opts?.headers ?? {};\r\n        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\r\n        // Trim off the brackets from IPv6 addresses\r\n        const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\r\n        const port = this.proxy.port\r\n            ? parseInt(this.proxy.port, 10)\r\n            : this.proxy.protocol === 'https:'\r\n                ? 443\r\n                : 80;\r\n        this.connectOpts = {\r\n            // Attempt to negotiate http/1.1 for proxy servers that support http/2\r\n            ALPNProtocols: ['http/1.1'],\r\n            ...(opts ? omit(opts, 'headers') : null),\r\n            host,\r\n            port,\r\n        };\r\n    }\r\n    /**\r\n     * Called when the node-core HTTP client library is creating a\r\n     * new HTTP request.\r\n     */\r\n    async connect(req, opts) {\r\n        const { proxy } = this;\r\n        if (!opts.host) {\r\n            throw new TypeError('No \"host\" provided');\r\n        }\r\n        // Create a socket connection to the proxy server.\r\n        let socket;\r\n        if (proxy.protocol === 'https:') {\r\n            debug('Creating `tls.Socket`: %o', this.connectOpts);\r\n            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));\r\n        }\r\n        else {\r\n            debug('Creating `net.Socket`: %o', this.connectOpts);\r\n            socket = net.connect(this.connectOpts);\r\n        }\r\n        const headers = typeof this.proxyHeaders === 'function'\r\n            ? this.proxyHeaders()\r\n            : { ...this.proxyHeaders };\r\n        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\r\n        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\r\n        // Inject the `Proxy-Authorization` header if necessary.\r\n        if (proxy.username || proxy.password) {\r\n            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\r\n            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\r\n        }\r\n        headers.Host = `${host}:${opts.port}`;\r\n        if (!headers['Proxy-Connection']) {\r\n            headers['Proxy-Connection'] = this.keepAlive\r\n                ? 'Keep-Alive'\r\n                : 'close';\r\n        }\r\n        for (const name of Object.keys(headers)) {\r\n            payload += `${name}: ${headers[name]}\\r\\n`;\r\n        }\r\n        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\r\n        socket.write(`${payload}\\r\\n`);\r\n        const { connect, buffered } = await proxyResponsePromise;\r\n        req.emit('proxyConnect', connect);\r\n        this.emit('proxyConnect', connect, req);\r\n        if (connect.statusCode === 200) {\r\n            req.once('socket', resume);\r\n            if (opts.secureEndpoint) {\r\n                // The proxy is connecting to a TLS server, so upgrade\r\n                // this socket connection to a TLS connection.\r\n                debug('Upgrading socket connection to TLS');\r\n                return tls.connect({\r\n                    ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),\r\n                    socket,\r\n                });\r\n            }\r\n            return socket;\r\n        }\r\n        // Some other status code that's not 200... need to re-play the HTTP\r\n        // header \"data\" events onto the socket once the HTTP machinery is\r\n        // attached so that the node core `http` can parse and handle the\r\n        // error status code.\r\n        // Close the original socket, and a new \"fake\" socket is returned\r\n        // instead, so that the proxy doesn't get the HTTP request\r\n        // written to it (which may contain `Authorization` headers or other\r\n        // sensitive data).\r\n        //\r\n        // See: https://hackerone.com/reports/541502\r\n        socket.destroy();\r\n        const fakeSocket = new net.Socket({ writable: false });\r\n        fakeSocket.readable = true;\r\n        // Need to wait for the \"socket\" event to re-play the \"data\" events.\r\n        req.once('socket', (s) => {\r\n            debug('Replaying proxy buffer for failed request');\r\n            (0, assert_1.default)(s.listenerCount('data') > 0);\r\n            // Replay the \"buffered\" Buffer onto the fake `socket`, since at\r\n            // this point the HTTP module machinery has been hooked up for\r\n            // the user.\r\n            s.push(buffered);\r\n            s.push(null);\r\n        });\r\n        return fakeSocket;\r\n    }\r\n}\r\nHttpsProxyAgent.protocols = ['http', 'https'];\r\nexports.HttpsProxyAgent = HttpsProxyAgent;\r\nfunction resume(socket) {\r\n    socket.resume();\r\n}\r\nfunction omit(obj, ...keys) {\r\n    const ret = {};\r\n    let key;\r\n    for (key in obj) {\r\n        if (!keys.includes(key)) {\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIseUJBQXlCLG1CQUFPLENBQUMsZ0JBQUs7QUFDdEMseUJBQXlCLG1CQUFPLENBQUMsZ0JBQUs7QUFDdEMsaUNBQWlDLG1CQUFPLENBQUMsc0JBQVE7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQVk7QUFDekMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLCtCQUErQixtQkFBTyxDQUFDLG1HQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQsVUFBVTtBQUMzRCxpQ0FBaUMsS0FBSyxHQUFHLFdBQVc7QUFDcEQ7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUMsR0FBRyxtQ0FBbUM7QUFDckcsc0RBQXNELHFDQUFxQztBQUMzRjtBQUNBLDBCQUEwQixLQUFLLEdBQUcsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxJQUFJLGNBQWM7QUFDakQ7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/OWNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkh0dHBzUHJveHlBZ2VudCA9IHZvaWQgMDtcclxuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xyXG5jb25zdCB0bHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRsc1wiKSk7XHJcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xyXG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XHJcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xyXG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbmNvbnN0IHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9wYXJzZS1wcm94eS1yZXNwb25zZVwiKTtcclxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQnKTtcclxuY29uc3Qgc2V0U2VydmVybmFtZUZyb21Ob25JcEhvc3QgPSAob3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKG9wdGlvbnMuc2VydmVybmFtZSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgb3B0aW9ucy5ob3N0ICYmXHJcbiAgICAgICAgIW5ldC5pc0lQKG9wdGlvbnMuaG9zdCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3QsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG59O1xyXG4vKipcclxuICogVGhlIGBIdHRwc1Byb3h5QWdlbnRgIGltcGxlbWVudHMgYW4gSFRUUCBBZ2VudCBzdWJjbGFzcyB0aGF0IGNvbm5lY3RzIHRvXHJcbiAqIHRoZSBzcGVjaWZpZWQgXCJIVFRQKHMpIHByb3h5IHNlcnZlclwiIGluIG9yZGVyIHRvIHByb3h5IEhUVFBTIHJlcXVlc3RzLlxyXG4gKlxyXG4gKiBPdXRnb2luZyBIVFRQIHJlcXVlc3RzIGFyZSBmaXJzdCB0dW5uZWxlZCB0aHJvdWdoIHRoZSBwcm94eSBzZXJ2ZXIgdXNpbmcgdGhlXHJcbiAqIGBDT05ORUNUYCBIVFRQIHJlcXVlc3QgbWV0aG9kIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlcixcclxuICogYW5kIHRoZW4gdGhlIHByb3h5IHNlcnZlciBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24gdGFyZ2V0IGFuZCBpc3N1ZXMgdGhlXHJcbiAqIEhUVFAgcmVxdWVzdCBmcm9tIHRoZSBwcm94eSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIGBodHRwczpgIHJlcXVlc3RzIGhhdmUgdGhlaXIgc29ja2V0IGNvbm5lY3Rpb24gdXBncmFkZWQgdG8gVExTIG9uY2VcclxuICogdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cclxuICovXHJcbmNsYXNzIEh0dHBzUHJveHlBZ2VudCBleHRlbmRzIGFnZW50X2Jhc2VfMS5BZ2VudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm94eSwgb3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgcGF0aDogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgdGhpcy5wcm94eSA9IHR5cGVvZiBwcm94eSA9PT0gJ3N0cmluZycgPyBuZXcgdXJsXzEuVVJMKHByb3h5KSA6IHByb3h5O1xyXG4gICAgICAgIHRoaXMucHJveHlIZWFkZXJzID0gb3B0cz8uaGVhZGVycyA/PyB7fTtcclxuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCB0aGlzLnByb3h5LmhyZWYpO1xyXG4gICAgICAgIC8vIFRyaW0gb2ZmIHRoZSBicmFja2V0cyBmcm9tIElQdjYgYWRkcmVzc2VzXHJcbiAgICAgICAgY29uc3QgaG9zdCA9ICh0aGlzLnByb3h5Lmhvc3RuYW1lIHx8IHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcclxuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5wcm94eS5wb3J0XHJcbiAgICAgICAgICAgID8gcGFyc2VJbnQodGhpcy5wcm94eS5wb3J0LCAxMClcclxuICAgICAgICAgICAgOiB0aGlzLnByb3h5LnByb3RvY29sID09PSAnaHR0cHM6J1xyXG4gICAgICAgICAgICAgICAgPyA0NDNcclxuICAgICAgICAgICAgICAgIDogODA7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0T3B0cyA9IHtcclxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMlxyXG4gICAgICAgICAgICBBTFBOUHJvdG9jb2xzOiBbJ2h0dHAvMS4xJ10sXHJcbiAgICAgICAgICAgIC4uLihvcHRzID8gb21pdChvcHRzLCAnaGVhZGVycycpIDogbnVsbCksXHJcbiAgICAgICAgICAgIGhvc3QsXHJcbiAgICAgICAgICAgIHBvcnQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIG5vZGUtY29yZSBIVFRQIGNsaWVudCBsaWJyYXJ5IGlzIGNyZWF0aW5nIGFcclxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNvbm5lY3QocmVxLCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm94eSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIW9wdHMuaG9zdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBcImhvc3RcIiBwcm92aWRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBzb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLlxyXG4gICAgICAgIGxldCBzb2NrZXQ7XHJcbiAgICAgICAgaWYgKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xyXG4gICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYHRscy5Tb2NrZXRgOiAlbycsIHRoaXMuY29ubmVjdE9wdHMpO1xyXG4gICAgICAgICAgICBzb2NrZXQgPSB0bHMuY29ubmVjdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdCh0aGlzLmNvbm5lY3RPcHRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYG5ldC5Tb2NrZXRgOiAlbycsIHRoaXMuY29ubmVjdE9wdHMpO1xyXG4gICAgICAgICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHR5cGVvZiB0aGlzLnByb3h5SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICA/IHRoaXMucHJveHlIZWFkZXJzKClcclxuICAgICAgICAgICAgOiB7IC4uLnRoaXMucHJveHlIZWFkZXJzIH07XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IG5ldC5pc0lQdjYob3B0cy5ob3N0KSA/IGBbJHtvcHRzLmhvc3R9XWAgOiBvcHRzLmhvc3Q7XHJcbiAgICAgICAgbGV0IHBheWxvYWQgPSBgQ09OTkVDVCAke2hvc3R9OiR7b3B0cy5wb3J0fSBIVFRQLzEuMVxcclxcbmA7XHJcbiAgICAgICAgLy8gSW5qZWN0IHRoZSBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICBpZiAocHJveHkudXNlcm5hbWUgfHwgcHJveHkucGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgY29uc3QgYXV0aCA9IGAke2RlY29kZVVSSUNvbXBvbmVudChwcm94eS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LnBhc3N3b3JkKX1gO1xyXG4gICAgICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtCdWZmZXIuZnJvbShhdXRoKS50b1N0cmluZygnYmFzZTY0Jyl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGVhZGVycy5Ib3N0ID0gYCR7aG9zdH06JHtvcHRzLnBvcnR9YDtcclxuICAgICAgICBpZiAoIWhlYWRlcnNbJ1Byb3h5LUNvbm5lY3Rpb24nXSkge1xyXG4gICAgICAgICAgICBoZWFkZXJzWydQcm94eS1Db25uZWN0aW9uJ10gPSB0aGlzLmtlZXBBbGl2ZVxyXG4gICAgICAgICAgICAgICAgPyAnS2VlcC1BbGl2ZSdcclxuICAgICAgICAgICAgICAgIDogJ2Nsb3NlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICAgIHBheWxvYWQgKz0gYCR7bmFtZX06ICR7aGVhZGVyc1tuYW1lXX1cXHJcXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm94eVJlc3BvbnNlUHJvbWlzZSA9ICgwLCBwYXJzZV9wcm94eV9yZXNwb25zZV8xLnBhcnNlUHJveHlSZXNwb25zZSkoc29ja2V0KTtcclxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7cGF5bG9hZH1cXHJcXG5gKTtcclxuICAgICAgICBjb25zdCB7IGNvbm5lY3QsIGJ1ZmZlcmVkIH0gPSBhd2FpdCBwcm94eVJlc3BvbnNlUHJvbWlzZTtcclxuICAgICAgICByZXEuZW1pdCgncHJveHlDb25uZWN0JywgY29ubmVjdCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcm94eUNvbm5lY3QnLCBjb25uZWN0LCByZXEpO1xyXG4gICAgICAgIGlmIChjb25uZWN0LnN0YXR1c0NvZGUgPT09IDIwMCkge1xyXG4gICAgICAgICAgICByZXEub25jZSgnc29ja2V0JywgcmVzdW1lKTtcclxuICAgICAgICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzb2NrZXQgY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0bHMuY29ubmVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ub21pdChzZXRTZXJ2ZXJuYW1lRnJvbU5vbklwSG9zdChvcHRzKSwgJ2hvc3QnLCAncGF0aCcsICdwb3J0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29tZSBvdGhlciBzdGF0dXMgY29kZSB0aGF0J3Mgbm90IDIwMC4uLiBuZWVkIHRvIHJlLXBsYXkgdGhlIEhUVFBcclxuICAgICAgICAvLyBoZWFkZXIgXCJkYXRhXCIgZXZlbnRzIG9udG8gdGhlIHNvY2tldCBvbmNlIHRoZSBIVFRQIG1hY2hpbmVyeSBpc1xyXG4gICAgICAgIC8vIGF0dGFjaGVkIHNvIHRoYXQgdGhlIG5vZGUgY29yZSBgaHR0cGAgY2FuIHBhcnNlIGFuZCBoYW5kbGUgdGhlXHJcbiAgICAgICAgLy8gZXJyb3Igc3RhdHVzIGNvZGUuXHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIG9yaWdpbmFsIHNvY2tldCwgYW5kIGEgbmV3IFwiZmFrZVwiIHNvY2tldCBpcyByZXR1cm5lZFxyXG4gICAgICAgIC8vIGluc3RlYWQsIHNvIHRoYXQgdGhlIHByb3h5IGRvZXNuJ3QgZ2V0IHRoZSBIVFRQIHJlcXVlc3RcclxuICAgICAgICAvLyB3cml0dGVuIHRvIGl0ICh3aGljaCBtYXkgY29udGFpbiBgQXV0aG9yaXphdGlvbmAgaGVhZGVycyBvciBvdGhlclxyXG4gICAgICAgIC8vIHNlbnNpdGl2ZSBkYXRhKS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9oYWNrZXJvbmUuY29tL3JlcG9ydHMvNTQxNTAyXHJcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcclxuICAgICAgICBjb25zdCBmYWtlU29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XHJcbiAgICAgICAgZmFrZVNvY2tldC5yZWFkYWJsZSA9IHRydWU7XHJcbiAgICAgICAgLy8gTmVlZCB0byB3YWl0IGZvciB0aGUgXCJzb2NrZXRcIiBldmVudCB0byByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMuXHJcbiAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIChzKSA9PiB7XHJcbiAgICAgICAgICAgIGRlYnVnKCdSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCcpO1xyXG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkocy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKTtcclxuICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSBcImJ1ZmZlcmVkXCIgQnVmZmVyIG9udG8gdGhlIGZha2UgYHNvY2tldGAsIHNpbmNlIGF0XHJcbiAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgdGhlIEhUVFAgbW9kdWxlIG1hY2hpbmVyeSBoYXMgYmVlbiBob29rZWQgdXAgZm9yXHJcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyLlxyXG4gICAgICAgICAgICBzLnB1c2goYnVmZmVyZWQpO1xyXG4gICAgICAgICAgICBzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZha2VTb2NrZXQ7XHJcbiAgICB9XHJcbn1cclxuSHR0cHNQcm94eUFnZW50LnByb3RvY29scyA9IFsnaHR0cCcsICdodHRwcyddO1xyXG5leHBvcnRzLkh0dHBzUHJveHlBZ2VudCA9IEh0dHBzUHJveHlBZ2VudDtcclxuZnVuY3Rpb24gcmVzdW1lKHNvY2tldCkge1xyXG4gICAgc29ja2V0LnJlc3VtZSgpO1xyXG59XHJcbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGxldCBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parseProxyResponse = void 0;\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\r\nconst debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');\r\nfunction parseProxyResponse(socket) {\r\n    return new Promise((resolve, reject) => {\r\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\r\n        // the CONNECT response, so that if the response is anything other than an \"200\"\r\n        // response code, then we can re-play the \"data\" events on the socket once the\r\n        // HTTP parser is hooked up...\r\n        let buffersLength = 0;\r\n        const buffers = [];\r\n        function read() {\r\n            const b = socket.read();\r\n            if (b)\r\n                ondata(b);\r\n            else\r\n                socket.once('readable', read);\r\n        }\r\n        function cleanup() {\r\n            socket.removeListener('end', onend);\r\n            socket.removeListener('error', onerror);\r\n            socket.removeListener('readable', read);\r\n        }\r\n        function onend() {\r\n            cleanup();\r\n            debug('onend');\r\n            reject(new Error('Proxy connection ended before receiving CONNECT response'));\r\n        }\r\n        function onerror(err) {\r\n            cleanup();\r\n            debug('onerror %o', err);\r\n            reject(err);\r\n        }\r\n        function ondata(b) {\r\n            buffers.push(b);\r\n            buffersLength += b.length;\r\n            const buffered = Buffer.concat(buffers, buffersLength);\r\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\r\n            if (endOfHeaders === -1) {\r\n                // keep buffering\r\n                debug('have not received end of HTTP headers yet...');\r\n                read();\r\n                return;\r\n            }\r\n            const headerParts = buffered\r\n                .slice(0, endOfHeaders)\r\n                .toString('ascii')\r\n                .split('\\r\\n');\r\n            const firstLine = headerParts.shift();\r\n            if (!firstLine) {\r\n                socket.destroy();\r\n                return reject(new Error('No header received from proxy CONNECT response'));\r\n            }\r\n            const firstLineParts = firstLine.split(' ');\r\n            const statusCode = +firstLineParts[1];\r\n            const statusText = firstLineParts.slice(2).join(' ');\r\n            const headers = {};\r\n            for (const header of headerParts) {\r\n                if (!header)\r\n                    continue;\r\n                const firstColon = header.indexOf(':');\r\n                if (firstColon === -1) {\r\n                    socket.destroy();\r\n                    return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\r\n                }\r\n                const key = header.slice(0, firstColon).toLowerCase();\r\n                const value = header.slice(firstColon + 1).trimStart();\r\n                const current = headers[key];\r\n                if (typeof current === 'string') {\r\n                    headers[key] = [current, value];\r\n                }\r\n                else if (Array.isArray(current)) {\r\n                    current.push(value);\r\n                }\r\n                else {\r\n                    headers[key] = value;\r\n                }\r\n            }\r\n            debug('got proxy server response: %o %o', firstLine, headers);\r\n            cleanup();\r\n            resolve({\r\n                connect: {\r\n                    statusCode,\r\n                    statusText,\r\n                    headers,\r\n                },\r\n                buffered,\r\n            });\r\n        }\r\n        socket.on('error', onerror);\r\n        socket.on('end', onend);\r\n        read();\r\n    });\r\n}\r\nexports.parseProxyResponse = parseProxyResponse;\r\n//# sourceMappingURL=parse-proxy-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzPzIzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5wYXJzZVByb3h5UmVzcG9uc2UgPSB2b2lkIDA7XHJcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcclxuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcclxuZnVuY3Rpb24gcGFyc2VQcm94eVJlc3BvbnNlKHNvY2tldCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XHJcbiAgICAgICAgLy8gdGhlIENPTk5FQ1QgcmVzcG9uc2UsIHNvIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYW4gXCIyMDBcIlxyXG4gICAgICAgIC8vIHJlc3BvbnNlIGNvZGUsIHRoZW4gd2UgY2FuIHJlLXBsYXkgdGhlIFwiZGF0YVwiIGV2ZW50cyBvbiB0aGUgc29ja2V0IG9uY2UgdGhlXHJcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXHJcbiAgICAgICAgbGV0IGJ1ZmZlcnNMZW5ndGggPSAwO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xyXG4gICAgICAgICAgICBjb25zdCBiID0gc29ja2V0LnJlYWQoKTtcclxuICAgICAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNvY2tldC5vbmNlKCdyZWFkYWJsZScsIHJlYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xyXG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcclxuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xyXG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xyXG4gICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgIGRlYnVnKCdvbmVuZCcpO1xyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcclxuICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICBkZWJ1Zygnb25lcnJvciAlbycsIGVycik7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvbmRhdGEoYikge1xyXG4gICAgICAgICAgICBidWZmZXJzLnB1c2goYik7XHJcbiAgICAgICAgICAgIGJ1ZmZlcnNMZW5ndGggKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJzTGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XHJcbiAgICAgICAgICAgIGlmIChlbmRPZkhlYWRlcnMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGJ1ZmZlcmluZ1xyXG4gICAgICAgICAgICAgICAgZGVidWcoJ2hhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uJyk7XHJcbiAgICAgICAgICAgICAgICByZWFkKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFydHMgPSBidWZmZXJlZFxyXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGVuZE9mSGVhZGVycylcclxuICAgICAgICAgICAgICAgIC50b1N0cmluZygnYXNjaWknKVxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXHJcXG4nKTtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gaGVhZGVyUGFydHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKCFmaXJzdExpbmUpIHtcclxuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaGVhZGVyIHJlY2VpdmVkIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmVQYXJ0cyA9IGZpcnN0TGluZS5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gK2ZpcnN0TGluZVBhcnRzWzFdO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gZmlyc3RMaW5lUGFydHMuc2xpY2UoMikuam9pbignICcpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlclBhcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sb24gPSBoZWFkZXIuaW5kZXhPZignOicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29sb24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiBcIiR7aGVhZGVyfVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnNsaWNlKDAsIGZpcnN0Q29sb24pLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zbGljZShmaXJzdENvbG9uICsgMSkudHJpbVN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gaGVhZGVyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFtjdXJyZW50LCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlYnVnKCdnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbycsIGZpcnN0TGluZSwgaGVhZGVycyk7XHJcbiAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyZWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XHJcbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XHJcbiAgICAgICAgcmVhZCgpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wYXJzZVByb3h5UmVzcG9uc2UgPSBwYXJzZVByb3h5UmVzcG9uc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXByb3h5LXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ })

};
;