"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gcp-metadata";
exports.ids = ["vendor-chunks/gcp-metadata"];
exports.modules = {

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!**************************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GCE_LINUX_BIOS_PATHS = void 0;\r\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\r\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\r\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\r\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\r\nexports.detectGCPResidency = detectGCPResidency;\r\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\r\nconst os_1 = __webpack_require__(/*! os */ \"os\");\r\n/**\r\n * Known paths unique to Google Compute Engine Linux instances\r\n */\r\nexports.GCE_LINUX_BIOS_PATHS = {\r\n    BIOS_DATE: '/sys/class/dmi/id/bios_date',\r\n    BIOS_VENDOR: '/sys/class/dmi/id/bios_vendor',\r\n};\r\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\r\n/**\r\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\r\n *\r\n * Uses the:\r\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\r\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\r\n *\r\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\r\n */\r\nfunction isGoogleCloudServerless() {\r\n    /**\r\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\r\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\r\n     *\r\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\r\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\r\n     *\r\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\r\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\r\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\r\n     */\r\n    const isGFEnvironment = process.env.CLOUD_RUN_JOB ||\r\n        process.env.FUNCTION_NAME ||\r\n        process.env.K_SERVICE;\r\n    return !!isGFEnvironment;\r\n}\r\n/**\r\n * Determines if the process is running on a Linux Google Compute Engine instance.\r\n *\r\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\r\n */\r\nfunction isGoogleComputeEngineLinux() {\r\n    if ((0, os_1.platform)() !== 'linux')\r\n        return false;\r\n    try {\r\n        // ensure this file exist\r\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\r\n        // ensure this file exist and matches\r\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, 'utf8');\r\n        return /Google/.test(biosVendor);\r\n    }\r\n    catch {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Determines if the process is running on a Google Compute Engine instance with a known\r\n * MAC address.\r\n *\r\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\r\n */\r\nfunction isGoogleComputeEngineMACAddress() {\r\n    const interfaces = (0, os_1.networkInterfaces)();\r\n    for (const item of Object.values(interfaces)) {\r\n        if (!item)\r\n            continue;\r\n        for (const { mac } of item) {\r\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Determines if the process is running on a Google Compute Engine instance.\r\n *\r\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\r\n */\r\nfunction isGoogleComputeEngine() {\r\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\r\n}\r\n/**\r\n * Determines if the process is running on Google Cloud Platform.\r\n *\r\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\r\n */\r\nfunction detectGCPResidency() {\r\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\r\n}\r\n//# sourceMappingURL=gcp-residency.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9nY3AtcmVzaWRlbmN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLHVDQUF1QztBQUN2Qyw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvR0FBb0c7QUFDMUcsTUFBTSw0RkFBNEY7QUFDbEc7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9HQUFvRztBQUNsSDtBQUNBO0FBQ0EsY0FBYyw2RUFBNkU7QUFDM0Y7QUFDQTtBQUNBLGNBQWMsb0dBQW9HO0FBQ2xILGNBQWMscUZBQXFGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL2djcC1tZXRhZGF0YS9idWlsZC9zcmMvZ2NwLXJlc2lkZW5jeS5qcz9iYjA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMgPSB2b2lkIDA7XHJcbmV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBpc0dvb2dsZUNsb3VkU2VydmVybGVzcztcclxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4O1xyXG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MgPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzO1xyXG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZTtcclxuZXhwb3J0cy5kZXRlY3RHQ1BSZXNpZGVuY3kgPSBkZXRlY3RHQ1BSZXNpZGVuY3k7XHJcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbi8qKlxyXG4gKiBLbm93biBwYXRocyB1bmlxdWUgdG8gR29vZ2xlIENvbXB1dGUgRW5naW5lIExpbnV4IGluc3RhbmNlc1xyXG4gKi9cclxuZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUyA9IHtcclxuICAgIEJJT1NfREFURTogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfZGF0ZScsXHJcbiAgICBCSU9TX1ZFTkRPUjogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfdmVuZG9yJyxcclxufTtcclxuY29uc3QgR0NFX01BQ19BRERSRVNTX1JFR0VYID0gL140MjowMS87XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ2xvdWQgU2VydmVybGVzcyBlbnZpcm9ubWVudCAoQ2xvdWQgUnVuIG9yIENsb3VkIEZ1bmN0aW9ucyBpbnN0YW5jZSkuXHJcbiAqXHJcbiAqIFVzZXMgdGhlOlxyXG4gKiAtIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcnVuL2RvY3MvY29udGFpbmVyLWNvbnRyYWN0I2Vudi12YXJzIENsb3VkIFJ1biBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxyXG4gKiAtIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciBDbG91ZCBGdW5jdGlvbnMgZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cclxuICpcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDUCBzZXJ2ZXJsZXNzLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBgQ0xPVURfUlVOX0pPQmAgaXMgdXNlZCBmb3IgQ2xvdWQgUnVuIEpvYnNcclxuICAgICAqIC0gU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcnVuL2RvY3MvY29udGFpbmVyLWNvbnRyYWN0I2Vudi12YXJzIENsb3VkIFJ1biBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxyXG4gICAgICpcclxuICAgICAqIGBGVU5DVElPTl9OQU1FYCBpcyB1c2VkIGluIG9sZGVyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XHJcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgUHl0aG9uIDMuNyBhbmQgR28gMS4xMX0uXHJcbiAgICAgKlxyXG4gICAgICogYEtfU0VSVklDRWAgaXMgdXNlZCBpbiBDbG91ZCBSdW4gYW5kIG5ld2VyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudHM6XHJcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cclxuICAgICAqIC0gU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZnVuY3Rpb25zL2RvY3MvZW52LXZhciBDbG91ZCBGdW5jdGlvbnMgbmV3ZXIgcnVudGltZXN9LlxyXG4gICAgICovXHJcbiAgICBjb25zdCBpc0dGRW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5DTE9VRF9SVU5fSk9CIHx8XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuRlVOQ1RJT05fTkFNRSB8fFxyXG4gICAgICAgIHByb2Nlc3MuZW52LktfU0VSVklDRTtcclxuICAgIHJldHVybiAhIWlzR0ZFbnZpcm9ubWVudDtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgTGludXggR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gTGludXggR0NFLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4KCkge1xyXG4gICAgaWYgKCgwLCBvc18xLnBsYXRmb3JtKSgpICE9PSAnbGludXgnKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoaXMgZmlsZSBleGlzdFxyXG4gICAgICAgICgwLCBmc18xLnN0YXRTeW5jKShleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTLkJJT1NfREFURSk7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoaXMgZmlsZSBleGlzdCBhbmQgbWF0Y2hlc1xyXG4gICAgICAgIGNvbnN0IGJpb3NWZW5kb3IgPSAoMCwgZnNfMS5yZWFkRmlsZVN5bmMpKGV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMuQklPU19WRU5ET1IsICd1dGY4Jyk7XHJcbiAgICAgICAgcmV0dXJuIC9Hb29nbGUvLnRlc3QoYmlvc1ZlbmRvcik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2Ugd2l0aCBhIGtub3duXHJcbiAqIE1BQyBhZGRyZXNzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFIChhcyBkZXRlcm1pbmVkIGJ5IE1BQyBhZGRyZXNzKSwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzKCkge1xyXG4gICAgY29uc3QgaW50ZXJmYWNlcyA9ICgwLCBvc18xLm5ldHdvcmtJbnRlcmZhY2VzKSgpO1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIE9iamVjdC52YWx1ZXMoaW50ZXJmYWNlcykpIHtcclxuICAgICAgICBpZiAoIWl0ZW0pXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBtYWMgfSBvZiBpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChHQ0VfTUFDX0FERFJFU1NfUkVHRVgudGVzdChtYWMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpIHtcclxuICAgIHJldHVybiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCgpIHx8IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MoKTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdvb2dsZSBDbG91ZCBQbGF0Zm9ybS5cclxuICpcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDUCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlY3RHQ1BSZXNpZGVuY3koKSB7XHJcbiAgICByZXR1cm4gaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MoKSB8fCBpc0dvb2dsZUNvbXB1dGVFbmdpbmUoKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nY3AtcmVzaWRlbmN5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gcp-metadata/build/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\r\nexports.instance = instance;\r\nexports.project = project;\r\nexports.universe = universe;\r\nexports.bulk = bulk;\r\nexports.isAvailable = isAvailable;\r\nexports.resetIsAvailableCache = resetIsAvailableCache;\r\nexports.getGCPResidency = getGCPResidency;\r\nexports.setGCPResidency = setGCPResidency;\r\nexports.requestTimeout = requestTimeout;\r\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/cjs/src/index.js\");\r\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(rsc)/./node_modules/json-bigint/index.js\");\r\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\");\r\nconst logger = __webpack_require__(/*! google-logging-utils */ \"(rsc)/./node_modules/google-logging-utils/build/src/index.js\");\r\nexports.BASE_PATH = '/computeMetadata/v1';\r\nexports.HOST_ADDRESS = 'http://169.254.169.254';\r\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\r\nexports.HEADER_NAME = 'Metadata-Flavor';\r\nexports.HEADER_VALUE = 'Google';\r\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\r\nconst log = logger.log('gcp metadata');\r\n/**\r\n * Metadata server detection override options.\r\n *\r\n * Available via `process.env.METADATA_SERVER_DETECTION`.\r\n */\r\nexports.METADATA_SERVER_DETECTION = Object.freeze({\r\n    'assume-present': \"don't try to ping the metadata server, but assume it's present\",\r\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\r\n    'bios-only': \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\r\n    'ping-only': 'skip the BIOS probe, and go straight to pinging',\r\n});\r\n/**\r\n * Returns the base URL while taking into account the GCE_METADATA_HOST\r\n * environment variable if it exists.\r\n *\r\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\r\n */\r\nfunction getBaseUrl(baseUrl) {\r\n    if (!baseUrl) {\r\n        baseUrl =\r\n            process.env.GCE_METADATA_IP ||\r\n                process.env.GCE_METADATA_HOST ||\r\n                exports.HOST_ADDRESS;\r\n    }\r\n    // If no scheme is provided default to HTTP:\r\n    if (!/^https?:\\/\\//.test(baseUrl)) {\r\n        baseUrl = `http://${baseUrl}`;\r\n    }\r\n    return new URL(exports.BASE_PATH, baseUrl).href;\r\n}\r\n// Accepts an options object passed from the user to the API. In previous\r\n// versions of the API, it referred to a `Request` or an `Axios` request\r\n// options object.  Now it refers to an object with very limited property\r\n// names. This is here to help ensure users don't pass invalid options when\r\n// they  upgrade from 0.4 to 0.5 to 0.8.\r\nfunction validate(options) {\r\n    Object.keys(options).forEach(key => {\r\n        switch (key) {\r\n            case 'params':\r\n            case 'property':\r\n            case 'headers':\r\n                break;\r\n            case 'qs':\r\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\r\n            default:\r\n                throw new Error(`'${key}' is not a valid configuration option.`);\r\n        }\r\n    });\r\n}\r\nasync function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {\r\n    const headers = new Headers(exports.HEADERS);\r\n    let metadataKey = '';\r\n    let params = {};\r\n    if (typeof type === 'object') {\r\n        const metadataAccessor = type;\r\n        new Headers(metadataAccessor.headers).forEach((value, key) => headers.set(key, value));\r\n        metadataKey = metadataAccessor.metadataKey;\r\n        params = metadataAccessor.params || params;\r\n        noResponseRetries = metadataAccessor.noResponseRetries || noResponseRetries;\r\n        fastFail = metadataAccessor.fastFail || fastFail;\r\n    }\r\n    else {\r\n        metadataKey = type;\r\n    }\r\n    if (typeof options === 'string') {\r\n        metadataKey += `/${options}`;\r\n    }\r\n    else {\r\n        validate(options);\r\n        if (options.property) {\r\n            metadataKey += `/${options.property}`;\r\n        }\r\n        new Headers(options.headers).forEach((value, key) => headers.set(key, value));\r\n        params = options.params || params;\r\n    }\r\n    const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\r\n    const req = {\r\n        url: `${getBaseUrl()}/${metadataKey}`,\r\n        headers,\r\n        retryConfig: { noResponseRetries },\r\n        params,\r\n        responseType: 'text',\r\n        timeout: requestTimeout(),\r\n    };\r\n    log.info('instance request %j', req);\r\n    const res = await requestMethod(req);\r\n    log.info('instance metadata is %s', res.data);\r\n    const metadataFlavor = res.headers.get(exports.HEADER_NAME);\r\n    if (metadataFlavor !== exports.HEADER_VALUE) {\r\n        throw new RangeError(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${metadataFlavor ? `'${metadataFlavor}'` : 'no header'}`);\r\n    }\r\n    if (typeof res.data === 'string') {\r\n        try {\r\n            return jsonBigint.parse(res.data);\r\n        }\r\n        catch {\r\n            /* ignore */\r\n        }\r\n    }\r\n    return res.data;\r\n}\r\nasync function fastFailMetadataRequest(options) {\r\n    const secondaryOptions = {\r\n        ...options,\r\n        url: options.url\r\n            ?.toString()\r\n            .replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS)),\r\n    };\r\n    // We race a connection between DNS/IP to metadata server. There are a couple\r\n    // reasons for this:\r\n    //\r\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\r\n    //    detect the runtime environment significantly faster.\r\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\r\n    //    on a user's local machine.\r\n    //\r\n    // Returns first resolved promise or if all promises get rejected we return an AggregateError.\r\n    //\r\n    // Note, however, if a failure happens prior to a success, a rejection should\r\n    // occur, this is for folks running locally.\r\n    //\r\n    const r1 = (0, gaxios_1.request)(options);\r\n    const r2 = (0, gaxios_1.request)(secondaryOptions);\r\n    return Promise.any([r1, r2]);\r\n}\r\n/**\r\n * Obtain metadata for the current GCE instance.\r\n *\r\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\r\n *\r\n * @example\r\n * ```\r\n * const serviceAccount: {} = await instance('service-accounts/');\r\n * const serviceAccountEmail: string = await instance('service-accounts/default/email');\r\n * ```\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction instance(options) {\r\n    return metadataAccessor('instance', options);\r\n}\r\n/**\r\n * Obtain metadata for the current GCP project.\r\n *\r\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\r\n *\r\n * @example\r\n * ```\r\n * const projectId: string = await project('project-id');\r\n * const numericProjectId: number = await project('numeric-project-id');\r\n * ```\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction project(options) {\r\n    return metadataAccessor('project', options);\r\n}\r\n/**\r\n * Obtain metadata for the current universe.\r\n *\r\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\r\n *\r\n * @example\r\n * ```\r\n * const universeDomain: string = await universe('universe-domain');\r\n * ```\r\n */\r\nfunction universe(options) {\r\n    return metadataAccessor('universe', options);\r\n}\r\n/**\r\n * Retrieve metadata items in parallel.\r\n *\r\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\r\n *\r\n * @example\r\n * ```\r\n * const data = await bulk([\r\n *   {\r\n *     metadataKey: 'instance',\r\n *   },\r\n *   {\r\n *     metadataKey: 'project/project-id',\r\n *   },\r\n * ] as const);\r\n *\r\n * // data.instance;\r\n * // data['project/project-id'];\r\n * ```\r\n *\r\n * @param properties The metadata properties to retrieve\r\n * @returns The metadata in `metadatakey:value` format\r\n */\r\nasync function bulk(properties) {\r\n    const r = {};\r\n    await Promise.all(properties.map(item => {\r\n        return (async () => {\r\n            const res = await metadataAccessor(item);\r\n            const key = item.metadataKey;\r\n            r[key] = res;\r\n        })();\r\n    }));\r\n    return r;\r\n}\r\n/*\r\n * How many times should we retry detecting GCP environment.\r\n */\r\nfunction detectGCPAvailableRetries() {\r\n    return process.env.DETECT_GCP_RETRIES\r\n        ? Number(process.env.DETECT_GCP_RETRIES)\r\n        : 0;\r\n}\r\nlet cachedIsAvailableResponse;\r\n/**\r\n * Determine if the metadata server is currently available.\r\n */\r\nasync function isAvailable() {\r\n    if (process.env.METADATA_SERVER_DETECTION) {\r\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\r\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\r\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join('`, `')}\\`, or unset`);\r\n        }\r\n        switch (value) {\r\n            case 'assume-present':\r\n                return true;\r\n            case 'none':\r\n                return false;\r\n            case 'bios-only':\r\n                return getGCPResidency();\r\n            case 'ping-only':\r\n            // continue, we want to ping the server\r\n        }\r\n    }\r\n    try {\r\n        // If a user is instantiating several GCP libraries at the same time,\r\n        // this may result in multiple calls to isAvailable(), to detect the\r\n        // runtime environment. We use the same promise for each of these calls\r\n        // to reduce the network load.\r\n        if (cachedIsAvailableResponse === undefined) {\r\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), \r\n            // If the default HOST_ADDRESS has been overridden, we should not\r\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\r\n            // a non-GCP environment):\r\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\r\n        }\r\n        await cachedIsAvailableResponse;\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        const err = e;\r\n        if (process.env.DEBUG_AUTH) {\r\n            console.info(err);\r\n        }\r\n        if (err.type === 'request-timeout') {\r\n            // If running in a GCP environment, metadata endpoint should return\r\n            // within ms.\r\n            return false;\r\n        }\r\n        if (err.response && err.response.status === 404) {\r\n            return false;\r\n        }\r\n        else {\r\n            if (!(err.response && err.response.status === 404) &&\r\n                // A warning is emitted if we see an unexpected err.code, or err.code\r\n                // is not populated:\r\n                (!err.code ||\r\n                    ![\r\n                        'EHOSTDOWN',\r\n                        'EHOSTUNREACH',\r\n                        'ENETUNREACH',\r\n                        'ENOENT',\r\n                        'ENOTFOUND',\r\n                        'ECONNREFUSED',\r\n                    ].includes(err.code))) {\r\n                let code = 'UNKNOWN';\r\n                if (err.code)\r\n                    code = err.code;\r\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, 'MetadataLookupWarning');\r\n            }\r\n            // Failure to resolve the metadata service means that it is not available.\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * reset the memoized isAvailable() lookup.\r\n */\r\nfunction resetIsAvailableCache() {\r\n    cachedIsAvailableResponse = undefined;\r\n}\r\n/**\r\n * A cache for the detected GCP Residency.\r\n */\r\nexports.gcpResidencyCache = null;\r\n/**\r\n * Detects GCP Residency.\r\n * Caches results to reduce costs for subsequent calls.\r\n *\r\n * @see setGCPResidency for setting\r\n */\r\nfunction getGCPResidency() {\r\n    if (exports.gcpResidencyCache === null) {\r\n        setGCPResidency();\r\n    }\r\n    return exports.gcpResidencyCache;\r\n}\r\n/**\r\n * Sets the detected GCP Residency.\r\n * Useful for forcing metadata server detection behavior.\r\n *\r\n * Set `null` to autodetect the environment (default behavior).\r\n * @see getGCPResidency for getting\r\n */\r\nfunction setGCPResidency(value = null) {\r\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\r\n}\r\n/**\r\n * Obtain the timeout for requests to the metadata server.\r\n *\r\n * In certain environments and conditions requests can take longer than\r\n * the default timeout to complete. This function will determine the\r\n * appropriate timeout based on the environment.\r\n *\r\n * @returns {number} a request timeout duration in milliseconds.\r\n */\r\nfunction requestTimeout() {\r\n    return getGCPResidency() ? 0 : 3000;\r\n}\r\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(rsc)/./node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports);\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxpQ0FBaUMsR0FBRyxlQUFlLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCO0FBQ3hNLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFRO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3hDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFpQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsMEZBQXNCO0FBQzdDLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZUFBZSxtQkFBbUIsNkNBQTZDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Y2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9pbmRleC5qcz9hZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSBleHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04gPSBleHBvcnRzLkhFQURFUlMgPSBleHBvcnRzLkhFQURFUl9WQUxVRSA9IGV4cG9ydHMuSEVBREVSX05BTUUgPSBleHBvcnRzLlNFQ09OREFSWV9IT1NUX0FERFJFU1MgPSBleHBvcnRzLkhPU1RfQUREUkVTUyA9IGV4cG9ydHMuQkFTRV9QQVRIID0gdm9pZCAwO1xyXG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XHJcbmV4cG9ydHMucHJvamVjdCA9IHByb2plY3Q7XHJcbmV4cG9ydHMudW5pdmVyc2UgPSB1bml2ZXJzZTtcclxuZXhwb3J0cy5idWxrID0gYnVsaztcclxuZXhwb3J0cy5pc0F2YWlsYWJsZSA9IGlzQXZhaWxhYmxlO1xyXG5leHBvcnRzLnJlc2V0SXNBdmFpbGFibGVDYWNoZSA9IHJlc2V0SXNBdmFpbGFibGVDYWNoZTtcclxuZXhwb3J0cy5nZXRHQ1BSZXNpZGVuY3kgPSBnZXRHQ1BSZXNpZGVuY3k7XHJcbmV4cG9ydHMuc2V0R0NQUmVzaWRlbmN5ID0gc2V0R0NQUmVzaWRlbmN5O1xyXG5leHBvcnRzLnJlcXVlc3RUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXQ7XHJcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcclxuY29uc3QganNvbkJpZ2ludCA9IHJlcXVpcmUoXCJqc29uLWJpZ2ludFwiKTtcclxuY29uc3QgZ2NwX3Jlc2lkZW5jeV8xID0gcmVxdWlyZShcIi4vZ2NwLXJlc2lkZW5jeVwiKTtcclxuY29uc3QgbG9nZ2VyID0gcmVxdWlyZShcImdvb2dsZS1sb2dnaW5nLXV0aWxzXCIpO1xyXG5leHBvcnRzLkJBU0VfUEFUSCA9ICcvY29tcHV0ZU1ldGFkYXRhL3YxJztcclxuZXhwb3J0cy5IT1NUX0FERFJFU1MgPSAnaHR0cDovLzE2OS4yNTQuMTY5LjI1NCc7XHJcbmV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9ICdodHRwOi8vbWV0YWRhdGEuZ29vZ2xlLmludGVybmFsLic7XHJcbmV4cG9ydHMuSEVBREVSX05BTUUgPSAnTWV0YWRhdGEtRmxhdm9yJztcclxuZXhwb3J0cy5IRUFERVJfVkFMVUUgPSAnR29vZ2xlJztcclxuZXhwb3J0cy5IRUFERVJTID0gT2JqZWN0LmZyZWV6ZSh7IFtleHBvcnRzLkhFQURFUl9OQU1FXTogZXhwb3J0cy5IRUFERVJfVkFMVUUgfSk7XHJcbmNvbnN0IGxvZyA9IGxvZ2dlci5sb2coJ2djcCBtZXRhZGF0YScpO1xyXG4vKipcclxuICogTWV0YWRhdGEgc2VydmVyIGRldGVjdGlvbiBvdmVycmlkZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBBdmFpbGFibGUgdmlhIGBwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OYC5cclxuICovXHJcbmV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTiA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgJ2Fzc3VtZS1wcmVzZW50JzogXCJkb24ndCB0cnkgdG8gcGluZyB0aGUgbWV0YWRhdGEgc2VydmVyLCBidXQgYXNzdW1lIGl0J3MgcHJlc2VudFwiLFxyXG4gICAgbm9uZTogXCJkb24ndCB0cnkgdG8gcGluZyB0aGUgbWV0YWRhdGEgc2VydmVyLCBidXQgZG9uJ3QgdHJ5IHRvIHVzZSBpdCBlaXRoZXJcIixcclxuICAgICdiaW9zLW9ubHknOiBcInRyZWF0IHRoZSByZXN1bHQgb2YgYSBCSU9TIHByb2JlIGFzIGNhbm9uaWNhbCAoZG9uJ3QgZmFsbCBiYWNrIHRvIHBpbmdpbmcpXCIsXHJcbiAgICAncGluZy1vbmx5JzogJ3NraXAgdGhlIEJJT1MgcHJvYmUsIGFuZCBnbyBzdHJhaWdodCB0byBwaW5naW5nJyxcclxufSk7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiYXNlIFVSTCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBHQ0VfTUVUQURBVEFfSE9TVFxyXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBiYXNlIFVSTCwgZS5nLiwgaHR0cDovLzE2OS4yNTQuMTY5LjI1NC9jb21wdXRlTWV0YWRhdGEvdjEuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcclxuICAgIGlmICghYmFzZVVybCkge1xyXG4gICAgICAgIGJhc2VVcmwgPVxyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSVAgfHxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9IT1NUIHx8XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLkhPU1RfQUREUkVTUztcclxuICAgIH1cclxuICAgIC8vIElmIG5vIHNjaGVtZSBpcyBwcm92aWRlZCBkZWZhdWx0IHRvIEhUVFA6XHJcbiAgICBpZiAoIS9eaHR0cHM/OlxcL1xcLy8udGVzdChiYXNlVXJsKSkge1xyXG4gICAgICAgIGJhc2VVcmwgPSBgaHR0cDovLyR7YmFzZVVybH1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBVUkwoZXhwb3J0cy5CQVNFX1BBVEgsIGJhc2VVcmwpLmhyZWY7XHJcbn1cclxuLy8gQWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgdXNlciB0byB0aGUgQVBJLiBJbiBwcmV2aW91c1xyXG4vLyB2ZXJzaW9ucyBvZiB0aGUgQVBJLCBpdCByZWZlcnJlZCB0byBhIGBSZXF1ZXN0YCBvciBhbiBgQXhpb3NgIHJlcXVlc3RcclxuLy8gb3B0aW9ucyBvYmplY3QuICBOb3cgaXQgcmVmZXJzIHRvIGFuIG9iamVjdCB3aXRoIHZlcnkgbGltaXRlZCBwcm9wZXJ0eVxyXG4vLyBuYW1lcy4gVGhpcyBpcyBoZXJlIHRvIGhlbHAgZW5zdXJlIHVzZXJzIGRvbid0IHBhc3MgaW52YWxpZCBvcHRpb25zIHdoZW5cclxuLy8gdGhleSAgdXBncmFkZSBmcm9tIDAuNCB0byAwLjUgdG8gMC44LlxyXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XHJcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAncGFyYW1zJzpcclxuICAgICAgICAgICAgY2FzZSAncHJvcGVydHknOlxyXG4gICAgICAgICAgICBjYXNlICdoZWFkZXJzJzpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdxcyc6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncXMnIGlzIG5vdCBhIHZhbGlkIGNvbmZpZ3VyYXRpb24gb3B0aW9uLiBQbGVhc2UgdXNlICdwYXJhbXMnIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtrZXl9JyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBtZXRhZGF0YUFjY2Vzc29yKHR5cGUsIG9wdGlvbnMgPSB7fSwgbm9SZXNwb25zZVJldHJpZXMgPSAzLCBmYXN0RmFpbCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoZXhwb3J0cy5IRUFERVJTKTtcclxuICAgIGxldCBtZXRhZGF0YUtleSA9ICcnO1xyXG4gICAgbGV0IHBhcmFtcyA9IHt9O1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhQWNjZXNzb3IgPSB0eXBlO1xyXG4gICAgICAgIG5ldyBIZWFkZXJzKG1ldGFkYXRhQWNjZXNzb3IuaGVhZGVycykuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgIG1ldGFkYXRhS2V5ID0gbWV0YWRhdGFBY2Nlc3Nvci5tZXRhZGF0YUtleTtcclxuICAgICAgICBwYXJhbXMgPSBtZXRhZGF0YUFjY2Vzc29yLnBhcmFtcyB8fCBwYXJhbXM7XHJcbiAgICAgICAgbm9SZXNwb25zZVJldHJpZXMgPSBtZXRhZGF0YUFjY2Vzc29yLm5vUmVzcG9uc2VSZXRyaWVzIHx8IG5vUmVzcG9uc2VSZXRyaWVzO1xyXG4gICAgICAgIGZhc3RGYWlsID0gbWV0YWRhdGFBY2Nlc3Nvci5mYXN0RmFpbCB8fCBmYXN0RmFpbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1ldGFkYXRhS2V5ID0gdHlwZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBtZXRhZGF0YUtleSArPSBgLyR7b3B0aW9uc31gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJvcGVydHkpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGFLZXkgKz0gYC8ke29wdGlvbnMucHJvcGVydHl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBoZWFkZXJzLnNldChrZXksIHZhbHVlKSk7XHJcbiAgICAgICAgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IGZhc3RGYWlsID8gZmFzdEZhaWxNZXRhZGF0YVJlcXVlc3QgOiBnYXhpb3NfMS5yZXF1ZXN0O1xyXG4gICAgY29uc3QgcmVxID0ge1xyXG4gICAgICAgIHVybDogYCR7Z2V0QmFzZVVybCgpfS8ke21ldGFkYXRhS2V5fWAsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgICByZXRyeUNvbmZpZzogeyBub1Jlc3BvbnNlUmV0cmllcyB9LFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcclxuICAgICAgICB0aW1lb3V0OiByZXF1ZXN0VGltZW91dCgpLFxyXG4gICAgfTtcclxuICAgIGxvZy5pbmZvKCdpbnN0YW5jZSByZXF1ZXN0ICVqJywgcmVxKTtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3RNZXRob2QocmVxKTtcclxuICAgIGxvZy5pbmZvKCdpbnN0YW5jZSBtZXRhZGF0YSBpcyAlcycsIHJlcy5kYXRhKTtcclxuICAgIGNvbnN0IG1ldGFkYXRhRmxhdm9yID0gcmVzLmhlYWRlcnMuZ2V0KGV4cG9ydHMuSEVBREVSX05BTUUpO1xyXG4gICAgaWYgKG1ldGFkYXRhRmxhdm9yICE9PSBleHBvcnRzLkhFQURFUl9WQUxVRSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZyb20gbWV0YWRhdGEgc2VydmljZTogaW5jb3JyZWN0ICR7ZXhwb3J0cy5IRUFERVJfTkFNRX0gaGVhZGVyLiBFeHBlY3RlZCAnJHtleHBvcnRzLkhFQURFUl9WQUxVRX0nLCBnb3QgJHttZXRhZGF0YUZsYXZvciA/IGAnJHttZXRhZGF0YUZsYXZvcn0nYCA6ICdubyBoZWFkZXInfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByZXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbkJpZ2ludC5wYXJzZShyZXMuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIHtcclxuICAgICAgICAgICAgLyogaWdub3JlICovXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5kYXRhO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0KG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHNlY29uZGFyeU9wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsXHJcbiAgICAgICAgICAgID8udG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAucmVwbGFjZShnZXRCYXNlVXJsKCksIGdldEJhc2VVcmwoZXhwb3J0cy5TRUNPTkRBUllfSE9TVF9BRERSRVNTKSksXHJcbiAgICB9O1xyXG4gICAgLy8gV2UgcmFjZSBhIGNvbm5lY3Rpb24gYmV0d2VlbiBETlMvSVAgdG8gbWV0YWRhdGEgc2VydmVyLiBUaGVyZSBhcmUgYSBjb3VwbGVcclxuICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XHJcbiAgICAvL1xyXG4gICAgLy8gMS4gdGhlIEROUyBpcyBzbG93IGluIHNvbWUgR0NQIGVudmlyb25tZW50czsgYnkgY2hlY2tpbmcgYm90aCwgd2UgbWlnaHRcclxuICAgIC8vICAgIGRldGVjdCB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBzaWduaWZpY2FudGx5IGZhc3Rlci5cclxuICAgIC8vIDIuIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhlIElQLCB3aGljaCBpcyB0YXJwaXR0ZWQgYW5kIHNsb3cgdG8gcmVzcG9uZFxyXG4gICAgLy8gICAgb24gYSB1c2VyJ3MgbG9jYWwgbWFjaGluZS5cclxuICAgIC8vXHJcbiAgICAvLyBSZXR1cm5zIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb3IgaWYgYWxsIHByb21pc2VzIGdldCByZWplY3RlZCB3ZSByZXR1cm4gYW4gQWdncmVnYXRlRXJyb3IuXHJcbiAgICAvL1xyXG4gICAgLy8gTm90ZSwgaG93ZXZlciwgaWYgYSBmYWlsdXJlIGhhcHBlbnMgcHJpb3IgdG8gYSBzdWNjZXNzLCBhIHJlamVjdGlvbiBzaG91bGRcclxuICAgIC8vIG9jY3VyLCB0aGlzIGlzIGZvciBmb2xrcyBydW5uaW5nIGxvY2FsbHkuXHJcbiAgICAvL1xyXG4gICAgY29uc3QgcjEgPSAoMCwgZ2F4aW9zXzEucmVxdWVzdCkob3B0aW9ucyk7XHJcbiAgICBjb25zdCByMiA9ICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShzZWNvbmRhcnlPcHRpb25zKTtcclxuICAgIHJldHVybiBQcm9taXNlLmFueShbcjEsIHIyXSk7XHJcbn1cclxuLyoqXHJcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NFIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgXHJcbiAqIGNvbnN0IHNlcnZpY2VBY2NvdW50OiB7fSA9IGF3YWl0IGluc3RhbmNlKCdzZXJ2aWNlLWFjY291bnRzLycpO1xyXG4gKiBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsOiBzdHJpbmcgPSBhd2FpdCBpbnN0YW5jZSgnc2VydmljZS1hY2NvdW50cy9kZWZhdWx0L2VtYWlsJyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuZnVuY3Rpb24gaW5zdGFuY2Uob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhQWNjZXNzb3IoJ2luc3RhbmNlJywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIE9idGFpbiBtZXRhZGF0YSBmb3IgdGhlIGN1cnJlbnQgR0NQIHByb2plY3QuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvbWV0YWRhdGEvcHJlZGVmaW5lZC1tZXRhZGF0YS1rZXlzfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICogY29uc3QgcHJvamVjdElkOiBzdHJpbmcgPSBhd2FpdCBwcm9qZWN0KCdwcm9qZWN0LWlkJyk7XHJcbiAqIGNvbnN0IG51bWVyaWNQcm9qZWN0SWQ6IG51bWJlciA9IGF3YWl0IHByb2plY3QoJ251bWVyaWMtcHJvamVjdC1pZCcpO1xyXG4gKiBgYGBcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmZ1bmN0aW9uIHByb2plY3Qob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhQWNjZXNzb3IoJ3Byb2plY3QnLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogT2J0YWluIG1ldGFkYXRhIGZvciB0aGUgY3VycmVudCB1bml2ZXJzZS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKiBjb25zdCB1bml2ZXJzZURvbWFpbjogc3RyaW5nID0gYXdhaXQgdW5pdmVyc2UoJ3VuaXZlcnNlLWRvbWFpbicpO1xyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHVuaXZlcnNlKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBtZXRhZGF0YUFjY2Vzc29yKCd1bml2ZXJzZScsIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSBtZXRhZGF0YSBpdGVtcyBpbiBwYXJhbGxlbC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXN9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgYnVsayhbXHJcbiAqICAge1xyXG4gKiAgICAgbWV0YWRhdGFLZXk6ICdpbnN0YW5jZScsXHJcbiAqICAgfSxcclxuICogICB7XHJcbiAqICAgICBtZXRhZGF0YUtleTogJ3Byb2plY3QvcHJvamVjdC1pZCcsXHJcbiAqICAgfSxcclxuICogXSBhcyBjb25zdCk7XHJcbiAqXHJcbiAqIC8vIGRhdGEuaW5zdGFuY2U7XHJcbiAqIC8vIGRhdGFbJ3Byb2plY3QvcHJvamVjdC1pZCddO1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHByb3BlcnRpZXMgVGhlIG1ldGFkYXRhIHByb3BlcnRpZXMgdG8gcmV0cmlldmVcclxuICogQHJldHVybnMgVGhlIG1ldGFkYXRhIGluIGBtZXRhZGF0YWtleTp2YWx1ZWAgZm9ybWF0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBidWxrKHByb3BlcnRpZXMpIHtcclxuICAgIGNvbnN0IHIgPSB7fTtcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb3BlcnRpZXMubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtZXRhZGF0YUFjY2Vzc29yKGl0ZW0pO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtLm1ldGFkYXRhS2V5O1xyXG4gICAgICAgICAgICByW2tleV0gPSByZXM7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH0pKTtcclxuICAgIHJldHVybiByO1xyXG59XHJcbi8qXHJcbiAqIEhvdyBtYW55IHRpbWVzIHNob3VsZCB3ZSByZXRyeSBkZXRlY3RpbmcgR0NQIGVudmlyb25tZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZWN0R0NQQXZhaWxhYmxlUmV0cmllcygpIHtcclxuICAgIHJldHVybiBwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVNcclxuICAgICAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVMpXHJcbiAgICAgICAgOiAwO1xyXG59XHJcbmxldCBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlO1xyXG4vKipcclxuICogRGV0ZXJtaW5lIGlmIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04udHJpbSgpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW4gZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5rbm93biBcXGBNRVRBREFUQV9TRVJWRVJfREVURUNUSU9OXFxgIGVudiB2YXJpYWJsZS4gR290IFxcYCR7dmFsdWV9XFxgLCBidXQgaXQgc2hvdWxkIGJlIFxcYCR7T2JqZWN0LmtleXMoZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OKS5qb2luKCdgLCBgJyl9XFxgLCBvciB1bnNldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Fzc3VtZS1wcmVzZW50JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlICdub25lJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgY2FzZSAnYmlvcy1vbmx5JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRHQ1BSZXNpZGVuY3koKTtcclxuICAgICAgICAgICAgY2FzZSAncGluZy1vbmx5JzpcclxuICAgICAgICAgICAgLy8gY29udGludWUsIHdlIHdhbnQgdG8gcGluZyB0aGUgc2VydmVyXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgaXMgaW5zdGFudGlhdGluZyBzZXZlcmFsIEdDUCBsaWJyYXJpZXMgYXQgdGhlIHNhbWUgdGltZSxcclxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbXVsdGlwbGUgY2FsbHMgdG8gaXNBdmFpbGFibGUoKSwgdG8gZGV0ZWN0IHRoZVxyXG4gICAgICAgIC8vIHJ1bnRpbWUgZW52aXJvbm1lbnQuIFdlIHVzZSB0aGUgc2FtZSBwcm9taXNlIGZvciBlYWNoIG9mIHRoZXNlIGNhbGxzXHJcbiAgICAgICAgLy8gdG8gcmVkdWNlIHRoZSBuZXR3b3JrIGxvYWQuXHJcbiAgICAgICAgaWYgKGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID0gbWV0YWRhdGFBY2Nlc3NvcignaW5zdGFuY2UnLCB1bmRlZmluZWQsIGRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMoKSwgXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWZhdWx0IEhPU1RfQUREUkVTUyBoYXMgYmVlbiBvdmVycmlkZGVuLCB3ZSBzaG91bGQgbm90XHJcbiAgICAgICAgICAgIC8vIG1ha2UgYW4gZWZmb3J0IHRvIHRyeSBTRUNPTkRBUllfSE9TVF9BRERSRVNTIChhcyB3ZSBhcmUgbGlrZWx5IGluXHJcbiAgICAgICAgICAgIC8vIGEgbm9uLUdDUCBlbnZpcm9ubWVudCk6XHJcbiAgICAgICAgICAgICEocHJvY2Vzcy5lbnYuR0NFX01FVEFEQVRBX0lQIHx8IHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9IT1NUKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGVyciA9IGU7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHX0FVVEgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcnIudHlwZSA9PT0gJ3JlcXVlc3QtdGltZW91dCcpIHtcclxuICAgICAgICAgICAgLy8gSWYgcnVubmluZyBpbiBhIEdDUCBlbnZpcm9ubWVudCwgbWV0YWRhdGEgZW5kcG9pbnQgc2hvdWxkIHJldHVyblxyXG4gICAgICAgICAgICAvLyB3aXRoaW4gbXMuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCEoZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgJiZcclxuICAgICAgICAgICAgICAgIC8vIEEgd2FybmluZyBpcyBlbWl0dGVkIGlmIHdlIHNlZSBhbiB1bmV4cGVjdGVkIGVyci5jb2RlLCBvciBlcnIuY29kZVxyXG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IHBvcHVsYXRlZDpcclxuICAgICAgICAgICAgICAgICghZXJyLmNvZGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUhPU1RET1dOJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VIT1NUVU5SRUFDSCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTkVUVU5SRUFDSCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTk9FTlQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5PVEZPVU5EJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VDT05OUkVGVVNFRCcsXHJcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnIuY29kZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9ICdVTktOT1dOJztcclxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSlcclxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gZXJyLmNvZGU7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGByZWNlaXZlZCB1bmV4cGVjdGVkIGVycm9yID0gJHtlcnIubWVzc2FnZX0gY29kZSA9ICR7Y29kZX1gLCAnTWV0YWRhdGFMb29rdXBXYXJuaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmFpbHVyZSB0byByZXNvbHZlIHRoZSBtZXRhZGF0YSBzZXJ2aWNlIG1lYW5zIHRoYXQgaXQgaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogcmVzZXQgdGhlIG1lbW9pemVkIGlzQXZhaWxhYmxlKCkgbG9va3VwLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRJc0F2YWlsYWJsZUNhY2hlKCkge1xyXG4gICAgY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogQSBjYWNoZSBmb3IgdGhlIGRldGVjdGVkIEdDUCBSZXNpZGVuY3kuXHJcbiAqL1xyXG5leHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gbnVsbDtcclxuLyoqXHJcbiAqIERldGVjdHMgR0NQIFJlc2lkZW5jeS5cclxuICogQ2FjaGVzIHJlc3VsdHMgdG8gcmVkdWNlIGNvc3RzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxyXG4gKlxyXG4gKiBAc2VlIHNldEdDUFJlc2lkZW5jeSBmb3Igc2V0dGluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R0NQUmVzaWRlbmN5KCkge1xyXG4gICAgaWYgKGV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICBzZXRHQ1BSZXNpZGVuY3koKTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBkZXRlY3RlZCBHQ1AgUmVzaWRlbmN5LlxyXG4gKiBVc2VmdWwgZm9yIGZvcmNpbmcgbWV0YWRhdGEgc2VydmVyIGRldGVjdGlvbiBiZWhhdmlvci5cclxuICpcclxuICogU2V0IGBudWxsYCB0byBhdXRvZGV0ZWN0IHRoZSBlbnZpcm9ubWVudCAoZGVmYXVsdCBiZWhhdmlvcikuXHJcbiAqIEBzZWUgZ2V0R0NQUmVzaWRlbmN5IGZvciBnZXR0aW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRHQ1BSZXNpZGVuY3kodmFsdWUgPSBudWxsKSB7XHJcbiAgICBleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID0gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6ICgwLCBnY3BfcmVzaWRlbmN5XzEuZGV0ZWN0R0NQUmVzaWRlbmN5KSgpO1xyXG59XHJcbi8qKlxyXG4gKiBPYnRhaW4gdGhlIHRpbWVvdXQgZm9yIHJlcXVlc3RzIHRvIHRoZSBtZXRhZGF0YSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEluIGNlcnRhaW4gZW52aXJvbm1lbnRzIGFuZCBjb25kaXRpb25zIHJlcXVlc3RzIGNhbiB0YWtlIGxvbmdlciB0aGFuXHJcbiAqIHRoZSBkZWZhdWx0IHRpbWVvdXQgdG8gY29tcGxldGUuIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlXHJcbiAqIGFwcHJvcHJpYXRlIHRpbWVvdXQgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIHJlcXVlc3QgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXF1ZXN0VGltZW91dCgpIHtcclxuICAgIHJldHVybiBnZXRHQ1BSZXNpZGVuY3koKSA/IDAgOiAzMDAwO1xyXG59XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gcp-metadata/build/src/index.js\n");

/***/ })

};
;