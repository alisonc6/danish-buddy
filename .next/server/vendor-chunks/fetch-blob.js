/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fetch-blob";
exports.ids = ["vendor-chunks/fetch-blob"];
exports.modules = {

/***/ "(rsc)/./node_modules/fetch-blob/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fetch-blob/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\r\n * @license\r\n * web-streams-polyfill v3.3.3\r\n * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.\r\n * This code is released under the MIT license.\r\n * SPDX-License-Identifier: MIT\r\n */\r\n(function (global, factory) {\r\n     true ? factory(exports) :\r\n    0;\r\n})(this, (function (exports) { 'use strict';\r\n\r\n    function noop() {\r\n        return undefined;\r\n    }\r\n\r\n    function typeIsObject(x) {\r\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n    }\r\n    const rethrowAssertionErrorRejection = noop;\r\n    function setFunctionName(fn, name) {\r\n        try {\r\n            Object.defineProperty(fn, 'name', {\r\n                value: name,\r\n                configurable: true\r\n            });\r\n        }\r\n        catch (_a) {\r\n            // This property is non-configurable in older browsers, so ignore if this throws.\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\r\n        }\r\n    }\r\n\r\n    const originalPromise = Promise;\r\n    const originalPromiseThen = Promise.prototype.then;\r\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\r\n    // https://webidl.spec.whatwg.org/#a-new-promise\r\n    function newPromise(executor) {\r\n        return new originalPromise(executor);\r\n    }\r\n    // https://webidl.spec.whatwg.org/#a-promise-resolved-with\r\n    function promiseResolvedWith(value) {\r\n        return newPromise(resolve => resolve(value));\r\n    }\r\n    // https://webidl.spec.whatwg.org/#a-promise-rejected-with\r\n    function promiseRejectedWith(reason) {\r\n        return originalPromiseReject(reason);\r\n    }\r\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\r\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\r\n        // approximation.\r\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\r\n    }\r\n    // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\r\n    // from that handler. To prevent this, return null instead of void from all handlers.\r\n    // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\r\n    function uponPromise(promise, onFulfilled, onRejected) {\r\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\r\n    }\r\n    function uponFulfillment(promise, onFulfilled) {\r\n        uponPromise(promise, onFulfilled);\r\n    }\r\n    function uponRejection(promise, onRejected) {\r\n        uponPromise(promise, undefined, onRejected);\r\n    }\r\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\r\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\r\n    }\r\n    function setPromiseIsHandledToTrue(promise) {\r\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\r\n    }\r\n    let _queueMicrotask = callback => {\r\n        if (typeof queueMicrotask === 'function') {\r\n            _queueMicrotask = queueMicrotask;\r\n        }\r\n        else {\r\n            const resolvedPromise = promiseResolvedWith(undefined);\r\n            _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);\r\n        }\r\n        return _queueMicrotask(callback);\r\n    };\r\n    function reflectCall(F, V, args) {\r\n        if (typeof F !== 'function') {\r\n            throw new TypeError('Argument is not a function');\r\n        }\r\n        return Function.prototype.apply.call(F, V, args);\r\n    }\r\n    function promiseCall(F, V, args) {\r\n        try {\r\n            return promiseResolvedWith(reflectCall(F, V, args));\r\n        }\r\n        catch (value) {\r\n            return promiseRejectedWith(value);\r\n        }\r\n    }\r\n\r\n    // Original from Chromium\r\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\r\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\r\n    /**\r\n     * Simple queue structure.\r\n     *\r\n     * Avoids scalability issues with using a packed array directly by using\r\n     * multiple arrays in a linked list and keeping the array size bounded.\r\n     */\r\n    class SimpleQueue {\r\n        constructor() {\r\n            this._cursor = 0;\r\n            this._size = 0;\r\n            // _front and _back are always defined.\r\n            this._front = {\r\n                _elements: [],\r\n                _next: undefined\r\n            };\r\n            this._back = this._front;\r\n            // The cursor is used to avoid calling Array.shift().\r\n            // It contains the index of the front element of the array inside the\r\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\r\n            this._cursor = 0;\r\n            // When there is only one node, size === elements.length - cursor.\r\n            this._size = 0;\r\n        }\r\n        get length() {\r\n            return this._size;\r\n        }\r\n        // For exception safety, this method is structured in order:\r\n        // 1. Read state\r\n        // 2. Calculate required state mutations\r\n        // 3. Perform state mutations\r\n        push(element) {\r\n            const oldBack = this._back;\r\n            let newBack = oldBack;\r\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\r\n                newBack = {\r\n                    _elements: [],\r\n                    _next: undefined\r\n                };\r\n            }\r\n            // push() is the mutation most likely to throw an exception, so it\r\n            // goes first.\r\n            oldBack._elements.push(element);\r\n            if (newBack !== oldBack) {\r\n                this._back = newBack;\r\n                oldBack._next = newBack;\r\n            }\r\n            ++this._size;\r\n        }\r\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\r\n        // exception safety.\r\n        shift() { // must not be called on an empty queue\r\n            const oldFront = this._front;\r\n            let newFront = oldFront;\r\n            const oldCursor = this._cursor;\r\n            let newCursor = oldCursor + 1;\r\n            const elements = oldFront._elements;\r\n            const element = elements[oldCursor];\r\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\r\n                newFront = oldFront._next;\r\n                newCursor = 0;\r\n            }\r\n            // No mutations before this point.\r\n            --this._size;\r\n            this._cursor = newCursor;\r\n            if (oldFront !== newFront) {\r\n                this._front = newFront;\r\n            }\r\n            // Permit shifted element to be garbage collected.\r\n            elements[oldCursor] = undefined;\r\n            return element;\r\n        }\r\n        // The tricky thing about forEach() is that it can be called\r\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\r\n        // see that push() within the callback has no negative effects since the end\r\n        // of the queue is checked for on every iteration. If shift() is called\r\n        // repeatedly within the callback then the next iteration may return an\r\n        // element that has been removed. In this case the callback will be called\r\n        // with undefined values until we either \"catch up\" with elements that still\r\n        // exist or reach the back of the queue.\r\n        forEach(callback) {\r\n            let i = this._cursor;\r\n            let node = this._front;\r\n            let elements = node._elements;\r\n            while (i !== elements.length || node._next !== undefined) {\r\n                if (i === elements.length) {\r\n                    node = node._next;\r\n                    elements = node._elements;\r\n                    i = 0;\r\n                    if (elements.length === 0) {\r\n                        break;\r\n                    }\r\n                }\r\n                callback(elements[i]);\r\n                ++i;\r\n            }\r\n        }\r\n        // Return the element that would be returned if shift() was called now,\r\n        // without modifying the queue.\r\n        peek() { // must not be called on an empty queue\r\n            const front = this._front;\r\n            const cursor = this._cursor;\r\n            return front._elements[cursor];\r\n        }\r\n    }\r\n\r\n    const AbortSteps = Symbol('[[AbortSteps]]');\r\n    const ErrorSteps = Symbol('[[ErrorSteps]]');\r\n    const CancelSteps = Symbol('[[CancelSteps]]');\r\n    const PullSteps = Symbol('[[PullSteps]]');\r\n    const ReleaseSteps = Symbol('[[ReleaseSteps]]');\r\n\r\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\r\n        reader._ownerReadableStream = stream;\r\n        stream._reader = reader;\r\n        if (stream._state === 'readable') {\r\n            defaultReaderClosedPromiseInitialize(reader);\r\n        }\r\n        else if (stream._state === 'closed') {\r\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n        }\r\n        else {\r\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n        }\r\n    }\r\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\r\n    // check.\r\n    function ReadableStreamReaderGenericCancel(reader, reason) {\r\n        const stream = reader._ownerReadableStream;\r\n        return ReadableStreamCancel(stream, reason);\r\n    }\r\n    function ReadableStreamReaderGenericRelease(reader) {\r\n        const stream = reader._ownerReadableStream;\r\n        if (stream._state === 'readable') {\r\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\r\n        }\r\n        else {\r\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\r\n        }\r\n        stream._readableStreamController[ReleaseSteps]();\r\n        stream._reader = undefined;\r\n        reader._ownerReadableStream = undefined;\r\n    }\r\n    // Helper functions for the readers.\r\n    function readerLockException(name) {\r\n        return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n    }\r\n    // Helper functions for the ReadableStreamDefaultReader.\r\n    function defaultReaderClosedPromiseInitialize(reader) {\r\n        reader._closedPromise = newPromise((resolve, reject) => {\r\n            reader._closedPromise_resolve = resolve;\r\n            reader._closedPromise_reject = reject;\r\n        });\r\n    }\r\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n        defaultReaderClosedPromiseInitialize(reader);\r\n        defaultReaderClosedPromiseReject(reader, reason);\r\n    }\r\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n        defaultReaderClosedPromiseInitialize(reader);\r\n        defaultReaderClosedPromiseResolve(reader);\r\n    }\r\n    function defaultReaderClosedPromiseReject(reader, reason) {\r\n        if (reader._closedPromise_reject === undefined) {\r\n            return;\r\n        }\r\n        setPromiseIsHandledToTrue(reader._closedPromise);\r\n        reader._closedPromise_reject(reason);\r\n        reader._closedPromise_resolve = undefined;\r\n        reader._closedPromise_reject = undefined;\r\n    }\r\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\r\n    }\r\n    function defaultReaderClosedPromiseResolve(reader) {\r\n        if (reader._closedPromise_resolve === undefined) {\r\n            return;\r\n        }\r\n        reader._closedPromise_resolve(undefined);\r\n        reader._closedPromise_resolve = undefined;\r\n        reader._closedPromise_reject = undefined;\r\n    }\r\n\r\n    /// <reference lib=\"es2015.core\" />\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\r\n    const NumberIsFinite = Number.isFinite || function (x) {\r\n        return typeof x === 'number' && isFinite(x);\r\n    };\r\n\r\n    /// <reference lib=\"es2015.core\" />\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\r\n    const MathTrunc = Math.trunc || function (v) {\r\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\r\n    };\r\n\r\n    // https://heycam.github.io/webidl/#idl-dictionaries\r\n    function isDictionary(x) {\r\n        return typeof x === 'object' || typeof x === 'function';\r\n    }\r\n    function assertDictionary(obj, context) {\r\n        if (obj !== undefined && !isDictionary(obj)) {\r\n            throw new TypeError(`${context} is not an object.`);\r\n        }\r\n    }\r\n    // https://heycam.github.io/webidl/#idl-callback-functions\r\n    function assertFunction(x, context) {\r\n        if (typeof x !== 'function') {\r\n            throw new TypeError(`${context} is not a function.`);\r\n        }\r\n    }\r\n    // https://heycam.github.io/webidl/#idl-object\r\n    function isObject(x) {\r\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n    }\r\n    function assertObject(x, context) {\r\n        if (!isObject(x)) {\r\n            throw new TypeError(`${context} is not an object.`);\r\n        }\r\n    }\r\n    function assertRequiredArgument(x, position, context) {\r\n        if (x === undefined) {\r\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\r\n        }\r\n    }\r\n    function assertRequiredField(x, field, context) {\r\n        if (x === undefined) {\r\n            throw new TypeError(`${field} is required in '${context}'.`);\r\n        }\r\n    }\r\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\r\n    function convertUnrestrictedDouble(value) {\r\n        return Number(value);\r\n    }\r\n    function censorNegativeZero(x) {\r\n        return x === 0 ? 0 : x;\r\n    }\r\n    function integerPart(x) {\r\n        return censorNegativeZero(MathTrunc(x));\r\n    }\r\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\r\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\r\n        const lowerBound = 0;\r\n        const upperBound = Number.MAX_SAFE_INTEGER;\r\n        let x = Number(value);\r\n        x = censorNegativeZero(x);\r\n        if (!NumberIsFinite(x)) {\r\n            throw new TypeError(`${context} is not a finite number`);\r\n        }\r\n        x = integerPart(x);\r\n        if (x < lowerBound || x > upperBound) {\r\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\r\n        }\r\n        if (!NumberIsFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n        // TODO Use BigInt if supported?\r\n        // let xBigInt = BigInt(integerPart(x));\r\n        // xBigInt = BigInt.asUintN(64, xBigInt);\r\n        // return Number(xBigInt);\r\n        return x;\r\n    }\r\n\r\n    function assertReadableStream(x, context) {\r\n        if (!IsReadableStream(x)) {\r\n            throw new TypeError(`${context} is not a ReadableStream.`);\r\n        }\r\n    }\r\n\r\n    // Abstract operations for the ReadableStream.\r\n    function AcquireReadableStreamDefaultReader(stream) {\r\n        return new ReadableStreamDefaultReader(stream);\r\n    }\r\n    // ReadableStream API exposed for controllers.\r\n    function ReadableStreamAddReadRequest(stream, readRequest) {\r\n        stream._reader._readRequests.push(readRequest);\r\n    }\r\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n        const reader = stream._reader;\r\n        const readRequest = reader._readRequests.shift();\r\n        if (done) {\r\n            readRequest._closeSteps();\r\n        }\r\n        else {\r\n            readRequest._chunkSteps(chunk);\r\n        }\r\n    }\r\n    function ReadableStreamGetNumReadRequests(stream) {\r\n        return stream._reader._readRequests.length;\r\n    }\r\n    function ReadableStreamHasDefaultReader(stream) {\r\n        const reader = stream._reader;\r\n        if (reader === undefined) {\r\n            return false;\r\n        }\r\n        if (!IsReadableStreamDefaultReader(reader)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A default reader vended by a {@link ReadableStream}.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableStreamDefaultReader {\r\n        constructor(stream) {\r\n            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\r\n            assertReadableStream(stream, 'First parameter');\r\n            if (IsReadableStreamLocked(stream)) {\r\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n            }\r\n            ReadableStreamReaderGenericInitialize(this, stream);\r\n            this._readRequests = new SimpleQueue();\r\n        }\r\n        /**\r\n         * Returns a promise that will be fulfilled when the stream becomes closed,\r\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\r\n         */\r\n        get closed() {\r\n            if (!IsReadableStreamDefaultReader(this)) {\r\n                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\r\n            }\r\n            return this._closedPromise;\r\n        }\r\n        /**\r\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\r\n         */\r\n        cancel(reason = undefined) {\r\n            if (!IsReadableStreamDefaultReader(this)) {\r\n                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return promiseRejectedWith(readerLockException('cancel'));\r\n            }\r\n            return ReadableStreamReaderGenericCancel(this, reason);\r\n        }\r\n        /**\r\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\r\n         *\r\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\r\n         */\r\n        read() {\r\n            if (!IsReadableStreamDefaultReader(this)) {\r\n                return promiseRejectedWith(defaultReaderBrandCheckException('read'));\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return promiseRejectedWith(readerLockException('read from'));\r\n            }\r\n            let resolvePromise;\r\n            let rejectPromise;\r\n            const promise = newPromise((resolve, reject) => {\r\n                resolvePromise = resolve;\r\n                rejectPromise = reject;\r\n            });\r\n            const readRequest = {\r\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\r\n                _closeSteps: () => resolvePromise({ value: undefined, done: true }),\r\n                _errorSteps: e => rejectPromise(e)\r\n            };\r\n            ReadableStreamDefaultReaderRead(this, readRequest);\r\n            return promise;\r\n        }\r\n        /**\r\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\r\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\r\n         * from now on; otherwise, the reader will appear closed.\r\n         *\r\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\r\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\r\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\r\n         */\r\n        releaseLock() {\r\n            if (!IsReadableStreamDefaultReader(this)) {\r\n                throw defaultReaderBrandCheckException('releaseLock');\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return;\r\n            }\r\n            ReadableStreamDefaultReaderRelease(this);\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\r\n        cancel: { enumerable: true },\r\n        read: { enumerable: true },\r\n        releaseLock: { enumerable: true },\r\n        closed: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\r\n    setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\r\n    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableStreamDefaultReader',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the readers.\r\n    function IsReadableStreamDefaultReader(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableStreamDefaultReader;\r\n    }\r\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\r\n        const stream = reader._ownerReadableStream;\r\n        stream._disturbed = true;\r\n        if (stream._state === 'closed') {\r\n            readRequest._closeSteps();\r\n        }\r\n        else if (stream._state === 'errored') {\r\n            readRequest._errorSteps(stream._storedError);\r\n        }\r\n        else {\r\n            stream._readableStreamController[PullSteps](readRequest);\r\n        }\r\n    }\r\n    function ReadableStreamDefaultReaderRelease(reader) {\r\n        ReadableStreamReaderGenericRelease(reader);\r\n        const e = new TypeError('Reader was released');\r\n        ReadableStreamDefaultReaderErrorReadRequests(reader, e);\r\n    }\r\n    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\r\n        const readRequests = reader._readRequests;\r\n        reader._readRequests = new SimpleQueue();\r\n        readRequests.forEach(readRequest => {\r\n            readRequest._errorSteps(e);\r\n        });\r\n    }\r\n    // Helper functions for the ReadableStreamDefaultReader.\r\n    function defaultReaderBrandCheckException(name) {\r\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\r\n    }\r\n\r\n    /// <reference lib=\"es2018.asynciterable\" />\r\n    /* eslint-disable @typescript-eslint/no-empty-function */\r\n    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\r\n\r\n    /// <reference lib=\"es2018.asynciterable\" />\r\n    class ReadableStreamAsyncIteratorImpl {\r\n        constructor(reader, preventCancel) {\r\n            this._ongoingPromise = undefined;\r\n            this._isFinished = false;\r\n            this._reader = reader;\r\n            this._preventCancel = preventCancel;\r\n        }\r\n        next() {\r\n            const nextSteps = () => this._nextSteps();\r\n            this._ongoingPromise = this._ongoingPromise ?\r\n                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\r\n                nextSteps();\r\n            return this._ongoingPromise;\r\n        }\r\n        return(value) {\r\n            const returnSteps = () => this._returnSteps(value);\r\n            return this._ongoingPromise ?\r\n                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\r\n                returnSteps();\r\n        }\r\n        _nextSteps() {\r\n            if (this._isFinished) {\r\n                return Promise.resolve({ value: undefined, done: true });\r\n            }\r\n            const reader = this._reader;\r\n            let resolvePromise;\r\n            let rejectPromise;\r\n            const promise = newPromise((resolve, reject) => {\r\n                resolvePromise = resolve;\r\n                rejectPromise = reject;\r\n            });\r\n            const readRequest = {\r\n                _chunkSteps: chunk => {\r\n                    this._ongoingPromise = undefined;\r\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\r\n                    // FIXME Is this a bug in the specification, or in the test?\r\n                    _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\r\n                },\r\n                _closeSteps: () => {\r\n                    this._ongoingPromise = undefined;\r\n                    this._isFinished = true;\r\n                    ReadableStreamReaderGenericRelease(reader);\r\n                    resolvePromise({ value: undefined, done: true });\r\n                },\r\n                _errorSteps: reason => {\r\n                    this._ongoingPromise = undefined;\r\n                    this._isFinished = true;\r\n                    ReadableStreamReaderGenericRelease(reader);\r\n                    rejectPromise(reason);\r\n                }\r\n            };\r\n            ReadableStreamDefaultReaderRead(reader, readRequest);\r\n            return promise;\r\n        }\r\n        _returnSteps(value) {\r\n            if (this._isFinished) {\r\n                return Promise.resolve({ value, done: true });\r\n            }\r\n            this._isFinished = true;\r\n            const reader = this._reader;\r\n            if (!this._preventCancel) {\r\n                const result = ReadableStreamReaderGenericCancel(reader, value);\r\n                ReadableStreamReaderGenericRelease(reader);\r\n                return transformPromiseWith(result, () => ({ value, done: true }));\r\n            }\r\n            ReadableStreamReaderGenericRelease(reader);\r\n            return promiseResolvedWith({ value, done: true });\r\n        }\r\n    }\r\n    const ReadableStreamAsyncIteratorPrototype = {\r\n        next() {\r\n            if (!IsReadableStreamAsyncIterator(this)) {\r\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\r\n            }\r\n            return this._asyncIteratorImpl.next();\r\n        },\r\n        return(value) {\r\n            if (!IsReadableStreamAsyncIterator(this)) {\r\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\r\n            }\r\n            return this._asyncIteratorImpl.return(value);\r\n        }\r\n    };\r\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\r\n    // Abstract operations for the ReadableStream.\r\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\r\n        const reader = AcquireReadableStreamDefaultReader(stream);\r\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\r\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\r\n        iterator._asyncIteratorImpl = impl;\r\n        return iterator;\r\n    }\r\n    function IsReadableStreamAsyncIterator(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\r\n            return false;\r\n        }\r\n        try {\r\n            // noinspection SuspiciousTypeOfGuard\r\n            return x._asyncIteratorImpl instanceof\r\n                ReadableStreamAsyncIteratorImpl;\r\n        }\r\n        catch (_a) {\r\n            return false;\r\n        }\r\n    }\r\n    // Helper functions for the ReadableStream.\r\n    function streamAsyncIteratorBrandCheckException(name) {\r\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\r\n    }\r\n\r\n    /// <reference lib=\"es2015.core\" />\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\r\n    const NumberIsNaN = Number.isNaN || function (x) {\r\n        // eslint-disable-next-line no-self-compare\r\n        return x !== x;\r\n    };\r\n\r\n    var _a, _b, _c;\r\n    function CreateArrayFromList(elements) {\r\n        // We use arrays to represent lists, so this is basically a no-op.\r\n        // Do a slice though just in case we happen to depend on the unique-ness.\r\n        return elements.slice();\r\n    }\r\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\r\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n    }\r\n    let TransferArrayBuffer = (O) => {\r\n        if (typeof O.transfer === 'function') {\r\n            TransferArrayBuffer = buffer => buffer.transfer();\r\n        }\r\n        else if (typeof structuredClone === 'function') {\r\n            TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });\r\n        }\r\n        else {\r\n            // Not implemented correctly\r\n            TransferArrayBuffer = buffer => buffer;\r\n        }\r\n        return TransferArrayBuffer(O);\r\n    };\r\n    let IsDetachedBuffer = (O) => {\r\n        if (typeof O.detached === 'boolean') {\r\n            IsDetachedBuffer = buffer => buffer.detached;\r\n        }\r\n        else {\r\n            // Not implemented correctly\r\n            IsDetachedBuffer = buffer => buffer.byteLength === 0;\r\n        }\r\n        return IsDetachedBuffer(O);\r\n    };\r\n    function ArrayBufferSlice(buffer, begin, end) {\r\n        // ArrayBuffer.prototype.slice is not available on IE10\r\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\r\n        if (buffer.slice) {\r\n            return buffer.slice(begin, end);\r\n        }\r\n        const length = end - begin;\r\n        const slice = new ArrayBuffer(length);\r\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\r\n        return slice;\r\n    }\r\n    function GetMethod(receiver, prop) {\r\n        const func = receiver[prop];\r\n        if (func === undefined || func === null) {\r\n            return undefined;\r\n        }\r\n        if (typeof func !== 'function') {\r\n            throw new TypeError(`${String(prop)} is not a function`);\r\n        }\r\n        return func;\r\n    }\r\n    function CreateAsyncFromSyncIterator(syncIteratorRecord) {\r\n        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\r\n        // we use yield* inside an async generator function to achieve the same result.\r\n        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\r\n        const syncIterable = {\r\n            [Symbol.iterator]: () => syncIteratorRecord.iterator\r\n        };\r\n        // Create an async generator function and immediately invoke it.\r\n        const asyncIterator = (async function* () {\r\n            return yield* syncIterable;\r\n        }());\r\n        // Return as an async iterator record.\r\n        const nextMethod = asyncIterator.next;\r\n        return { iterator: asyncIterator, nextMethod, done: false };\r\n    }\r\n    // Aligns with core-js/modules/es.symbol.async-iterator.js\r\n    const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, 'Symbol.asyncIterator')) !== null && _c !== void 0 ? _c : '@@asyncIterator';\r\n    function GetIterator(obj, hint = 'sync', method) {\r\n        if (method === undefined) {\r\n            if (hint === 'async') {\r\n                method = GetMethod(obj, SymbolAsyncIterator);\r\n                if (method === undefined) {\r\n                    const syncMethod = GetMethod(obj, Symbol.iterator);\r\n                    const syncIteratorRecord = GetIterator(obj, 'sync', syncMethod);\r\n                    return CreateAsyncFromSyncIterator(syncIteratorRecord);\r\n                }\r\n            }\r\n            else {\r\n                method = GetMethod(obj, Symbol.iterator);\r\n            }\r\n        }\r\n        if (method === undefined) {\r\n            throw new TypeError('The object is not iterable');\r\n        }\r\n        const iterator = reflectCall(method, obj, []);\r\n        if (!typeIsObject(iterator)) {\r\n            throw new TypeError('The iterator method must return an object');\r\n        }\r\n        const nextMethod = iterator.next;\r\n        return { iterator, nextMethod, done: false };\r\n    }\r\n    function IteratorNext(iteratorRecord) {\r\n        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\r\n        if (!typeIsObject(result)) {\r\n            throw new TypeError('The iterator.next() method must return an object');\r\n        }\r\n        return result;\r\n    }\r\n    function IteratorComplete(iterResult) {\r\n        return Boolean(iterResult.done);\r\n    }\r\n    function IteratorValue(iterResult) {\r\n        return iterResult.value;\r\n    }\r\n\r\n    function IsNonNegativeNumber(v) {\r\n        if (typeof v !== 'number') {\r\n            return false;\r\n        }\r\n        if (NumberIsNaN(v)) {\r\n            return false;\r\n        }\r\n        if (v < 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function CloneAsUint8Array(O) {\r\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\r\n        return new Uint8Array(buffer);\r\n    }\r\n\r\n    function DequeueValue(container) {\r\n        const pair = container._queue.shift();\r\n        container._queueTotalSize -= pair.size;\r\n        if (container._queueTotalSize < 0) {\r\n            container._queueTotalSize = 0;\r\n        }\r\n        return pair.value;\r\n    }\r\n    function EnqueueValueWithSize(container, value, size) {\r\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\r\n            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n        }\r\n        container._queue.push({ value, size });\r\n        container._queueTotalSize += size;\r\n    }\r\n    function PeekQueueValue(container) {\r\n        const pair = container._queue.peek();\r\n        return pair.value;\r\n    }\r\n    function ResetQueue(container) {\r\n        container._queue = new SimpleQueue();\r\n        container._queueTotalSize = 0;\r\n    }\r\n\r\n    function isDataViewConstructor(ctor) {\r\n        return ctor === DataView;\r\n    }\r\n    function isDataView(view) {\r\n        return isDataViewConstructor(view.constructor);\r\n    }\r\n    function arrayBufferViewElementSize(ctor) {\r\n        if (isDataViewConstructor(ctor)) {\r\n            return 1;\r\n        }\r\n        return ctor.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    /**\r\n     * A pull-into request in a {@link ReadableByteStreamController}.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableStreamBYOBRequest {\r\n        constructor() {\r\n            throw new TypeError('Illegal constructor');\r\n        }\r\n        /**\r\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\r\n         */\r\n        get view() {\r\n            if (!IsReadableStreamBYOBRequest(this)) {\r\n                throw byobRequestBrandCheckException('view');\r\n            }\r\n            return this._view;\r\n        }\r\n        respond(bytesWritten) {\r\n            if (!IsReadableStreamBYOBRequest(this)) {\r\n                throw byobRequestBrandCheckException('respond');\r\n            }\r\n            assertRequiredArgument(bytesWritten, 1, 'respond');\r\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\r\n            if (this._associatedReadableByteStreamController === undefined) {\r\n                throw new TypeError('This BYOB request has been invalidated');\r\n            }\r\n            if (IsDetachedBuffer(this._view.buffer)) {\r\n                throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\r\n            }\r\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n        }\r\n        respondWithNewView(view) {\r\n            if (!IsReadableStreamBYOBRequest(this)) {\r\n                throw byobRequestBrandCheckException('respondWithNewView');\r\n            }\r\n            assertRequiredArgument(view, 1, 'respondWithNewView');\r\n            if (!ArrayBuffer.isView(view)) {\r\n                throw new TypeError('You can only respond with array buffer views');\r\n            }\r\n            if (this._associatedReadableByteStreamController === undefined) {\r\n                throw new TypeError('This BYOB request has been invalidated');\r\n            }\r\n            if (IsDetachedBuffer(view.buffer)) {\r\n                throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\r\n            }\r\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\r\n        respond: { enumerable: true },\r\n        respondWithNewView: { enumerable: true },\r\n        view: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');\r\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableStreamBYOBRequest',\r\n            configurable: true\r\n        });\r\n    }\r\n    /**\r\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableByteStreamController {\r\n        constructor() {\r\n            throw new TypeError('Illegal constructor');\r\n        }\r\n        /**\r\n         * Returns the current BYOB pull request, or `null` if there isn't one.\r\n         */\r\n        get byobRequest() {\r\n            if (!IsReadableByteStreamController(this)) {\r\n                throw byteStreamControllerBrandCheckException('byobRequest');\r\n            }\r\n            return ReadableByteStreamControllerGetBYOBRequest(this);\r\n        }\r\n        /**\r\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\r\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\r\n         */\r\n        get desiredSize() {\r\n            if (!IsReadableByteStreamController(this)) {\r\n                throw byteStreamControllerBrandCheckException('desiredSize');\r\n            }\r\n            return ReadableByteStreamControllerGetDesiredSize(this);\r\n        }\r\n        /**\r\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\r\n         * the stream, but once those are read, the stream will become closed.\r\n         */\r\n        close() {\r\n            if (!IsReadableByteStreamController(this)) {\r\n                throw byteStreamControllerBrandCheckException('close');\r\n            }\r\n            if (this._closeRequested) {\r\n                throw new TypeError('The stream has already been closed; do not close it again!');\r\n            }\r\n            const state = this._controlledReadableByteStream._state;\r\n            if (state !== 'readable') {\r\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\r\n            }\r\n            ReadableByteStreamControllerClose(this);\r\n        }\r\n        enqueue(chunk) {\r\n            if (!IsReadableByteStreamController(this)) {\r\n                throw byteStreamControllerBrandCheckException('enqueue');\r\n            }\r\n            assertRequiredArgument(chunk, 1, 'enqueue');\r\n            if (!ArrayBuffer.isView(chunk)) {\r\n                throw new TypeError('chunk must be an array buffer view');\r\n            }\r\n            if (chunk.byteLength === 0) {\r\n                throw new TypeError('chunk must have non-zero byteLength');\r\n            }\r\n            if (chunk.buffer.byteLength === 0) {\r\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\r\n            }\r\n            if (this._closeRequested) {\r\n                throw new TypeError('stream is closed or draining');\r\n            }\r\n            const state = this._controlledReadableByteStream._state;\r\n            if (state !== 'readable') {\r\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\r\n            }\r\n            ReadableByteStreamControllerEnqueue(this, chunk);\r\n        }\r\n        /**\r\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\r\n         */\r\n        error(e = undefined) {\r\n            if (!IsReadableByteStreamController(this)) {\r\n                throw byteStreamControllerBrandCheckException('error');\r\n            }\r\n            ReadableByteStreamControllerError(this, e);\r\n        }\r\n        /** @internal */\r\n        [CancelSteps](reason) {\r\n            ReadableByteStreamControllerClearPendingPullIntos(this);\r\n            ResetQueue(this);\r\n            const result = this._cancelAlgorithm(reason);\r\n            ReadableByteStreamControllerClearAlgorithms(this);\r\n            return result;\r\n        }\r\n        /** @internal */\r\n        [PullSteps](readRequest) {\r\n            const stream = this._controlledReadableByteStream;\r\n            if (this._queueTotalSize > 0) {\r\n                ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\r\n                return;\r\n            }\r\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n            if (autoAllocateChunkSize !== undefined) {\r\n                let buffer;\r\n                try {\r\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n                }\r\n                catch (bufferE) {\r\n                    readRequest._errorSteps(bufferE);\r\n                    return;\r\n                }\r\n                const pullIntoDescriptor = {\r\n                    buffer,\r\n                    bufferByteLength: autoAllocateChunkSize,\r\n                    byteOffset: 0,\r\n                    byteLength: autoAllocateChunkSize,\r\n                    bytesFilled: 0,\r\n                    minimumFill: 1,\r\n                    elementSize: 1,\r\n                    viewConstructor: Uint8Array,\r\n                    readerType: 'default'\r\n                };\r\n                this._pendingPullIntos.push(pullIntoDescriptor);\r\n            }\r\n            ReadableStreamAddReadRequest(stream, readRequest);\r\n            ReadableByteStreamControllerCallPullIfNeeded(this);\r\n        }\r\n        /** @internal */\r\n        [ReleaseSteps]() {\r\n            if (this._pendingPullIntos.length > 0) {\r\n                const firstPullInto = this._pendingPullIntos.peek();\r\n                firstPullInto.readerType = 'none';\r\n                this._pendingPullIntos = new SimpleQueue();\r\n                this._pendingPullIntos.push(firstPullInto);\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableByteStreamController.prototype, {\r\n        close: { enumerable: true },\r\n        enqueue: { enumerable: true },\r\n        error: { enumerable: true },\r\n        byobRequest: { enumerable: true },\r\n        desiredSize: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableByteStreamController.prototype.close, 'close');\r\n    setFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');\r\n    setFunctionName(ReadableByteStreamController.prototype.error, 'error');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableByteStreamController',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the ReadableByteStreamController.\r\n    function IsReadableByteStreamController(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableByteStreamController;\r\n    }\r\n    function IsReadableStreamBYOBRequest(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableStreamBYOBRequest;\r\n    }\r\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n        if (!shouldPull) {\r\n            return;\r\n        }\r\n        if (controller._pulling) {\r\n            controller._pullAgain = true;\r\n            return;\r\n        }\r\n        controller._pulling = true;\r\n        // TODO: Test controller argument\r\n        const pullPromise = controller._pullAlgorithm();\r\n        uponPromise(pullPromise, () => {\r\n            controller._pulling = false;\r\n            if (controller._pullAgain) {\r\n                controller._pullAgain = false;\r\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n            }\r\n            return null;\r\n        }, e => {\r\n            ReadableByteStreamControllerError(controller, e);\r\n            return null;\r\n        });\r\n    }\r\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n        controller._pendingPullIntos = new SimpleQueue();\r\n    }\r\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n        let done = false;\r\n        if (stream._state === 'closed') {\r\n            done = true;\r\n        }\r\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n        if (pullIntoDescriptor.readerType === 'default') {\r\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n        }\r\n        else {\r\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n        }\r\n    }\r\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\r\n        const elementSize = pullIntoDescriptor.elementSize;\r\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n    }\r\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n        controller._queue.push({ buffer, byteOffset, byteLength });\r\n        controller._queueTotalSize += byteLength;\r\n    }\r\n    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n        let clonedChunk;\r\n        try {\r\n            clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\r\n        }\r\n        catch (cloneE) {\r\n            ReadableByteStreamControllerError(controller, cloneE);\r\n            throw cloneE;\r\n        }\r\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\r\n    }\r\n    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\r\n        if (firstDescriptor.bytesFilled > 0) {\r\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\r\n        }\r\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n    }\r\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n        let totalBytesToCopyRemaining = maxBytesToCopy;\r\n        let ready = false;\r\n        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\r\n        const maxAlignedBytes = maxBytesFilled - remainderBytes;\r\n        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\r\n        // of the queue, so the underlying source can keep filling it.\r\n        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\r\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n            ready = true;\r\n        }\r\n        const queue = controller._queue;\r\n        while (totalBytesToCopyRemaining > 0) {\r\n            const headOfQueue = queue.peek();\r\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n            if (headOfQueue.byteLength === bytesToCopy) {\r\n                queue.shift();\r\n            }\r\n            else {\r\n                headOfQueue.byteOffset += bytesToCopy;\r\n                headOfQueue.byteLength -= bytesToCopy;\r\n            }\r\n            controller._queueTotalSize -= bytesToCopy;\r\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n            totalBytesToCopyRemaining -= bytesToCopy;\r\n        }\r\n        return ready;\r\n    }\r\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n        pullIntoDescriptor.bytesFilled += size;\r\n    }\r\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\r\n            ReadableByteStreamControllerClearAlgorithms(controller);\r\n            ReadableStreamClose(controller._controlledReadableByteStream);\r\n        }\r\n        else {\r\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n        }\r\n    }\r\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n        if (controller._byobRequest === null) {\r\n            return;\r\n        }\r\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n        controller._byobRequest._view = null;\r\n        controller._byobRequest = null;\r\n    }\r\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n        while (controller._pendingPullIntos.length > 0) {\r\n            if (controller._queueTotalSize === 0) {\r\n                return;\r\n            }\r\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\r\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\r\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n            }\r\n        }\r\n    }\r\n    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\r\n        const reader = controller._controlledReadableByteStream._reader;\r\n        while (reader._readRequests.length > 0) {\r\n            if (controller._queueTotalSize === 0) {\r\n                return;\r\n            }\r\n            const readRequest = reader._readRequests.shift();\r\n            ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\r\n        }\r\n    }\r\n    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\r\n        const stream = controller._controlledReadableByteStream;\r\n        const ctor = view.constructor;\r\n        const elementSize = arrayBufferViewElementSize(ctor);\r\n        const { byteOffset, byteLength } = view;\r\n        const minimumFill = min * elementSize;\r\n        let buffer;\r\n        try {\r\n            buffer = TransferArrayBuffer(view.buffer);\r\n        }\r\n        catch (e) {\r\n            readIntoRequest._errorSteps(e);\r\n            return;\r\n        }\r\n        const pullIntoDescriptor = {\r\n            buffer,\r\n            bufferByteLength: buffer.byteLength,\r\n            byteOffset,\r\n            byteLength,\r\n            bytesFilled: 0,\r\n            minimumFill,\r\n            elementSize,\r\n            viewConstructor: ctor,\r\n            readerType: 'byob'\r\n        };\r\n        if (controller._pendingPullIntos.length > 0) {\r\n            controller._pendingPullIntos.push(pullIntoDescriptor);\r\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\r\n            // - No change happens on desiredSize\r\n            // - The source has already been notified of that there's at least 1 pending read(view)\r\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\r\n            return;\r\n        }\r\n        if (stream._state === 'closed') {\r\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n            readIntoRequest._closeSteps(emptyView);\r\n            return;\r\n        }\r\n        if (controller._queueTotalSize > 0) {\r\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\r\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n                ReadableByteStreamControllerHandleQueueDrain(controller);\r\n                readIntoRequest._chunkSteps(filledView);\r\n                return;\r\n            }\r\n            if (controller._closeRequested) {\r\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n                ReadableByteStreamControllerError(controller, e);\r\n                readIntoRequest._errorSteps(e);\r\n                return;\r\n            }\r\n        }\r\n        controller._pendingPullIntos.push(pullIntoDescriptor);\r\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n    }\r\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n        if (firstDescriptor.readerType === 'none') {\r\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n        }\r\n        const stream = controller._controlledReadableByteStream;\r\n        if (ReadableStreamHasBYOBReader(stream)) {\r\n            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n            }\r\n        }\r\n    }\r\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n        if (pullIntoDescriptor.readerType === 'none') {\r\n            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\r\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n            return;\r\n        }\r\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\r\n            // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\r\n            // of the queue, so the underlying source can keep filling it.\r\n            return;\r\n        }\r\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n        if (remainderSize > 0) {\r\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);\r\n        }\r\n        pullIntoDescriptor.bytesFilled -= remainderSize;\r\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n    }\r\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n        const firstDescriptor = controller._pendingPullIntos.peek();\r\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n        const state = controller._controlledReadableByteStream._state;\r\n        if (state === 'closed') {\r\n            ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n        }\r\n        else {\r\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n        }\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n    }\r\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n        const descriptor = controller._pendingPullIntos.shift();\r\n        return descriptor;\r\n    }\r\n    function ReadableByteStreamControllerShouldCallPull(controller) {\r\n        const stream = controller._controlledReadableByteStream;\r\n        if (stream._state !== 'readable') {\r\n            return false;\r\n        }\r\n        if (controller._closeRequested) {\r\n            return false;\r\n        }\r\n        if (!controller._started) {\r\n            return false;\r\n        }\r\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n            return true;\r\n        }\r\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n            return true;\r\n        }\r\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\r\n        if (desiredSize > 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\r\n        controller._pullAlgorithm = undefined;\r\n        controller._cancelAlgorithm = undefined;\r\n    }\r\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\r\n    function ReadableByteStreamControllerClose(controller) {\r\n        const stream = controller._controlledReadableByteStream;\r\n        if (controller._closeRequested || stream._state !== 'readable') {\r\n            return;\r\n        }\r\n        if (controller._queueTotalSize > 0) {\r\n            controller._closeRequested = true;\r\n            return;\r\n        }\r\n        if (controller._pendingPullIntos.length > 0) {\r\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\r\n            if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\r\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n                ReadableByteStreamControllerError(controller, e);\r\n                throw e;\r\n            }\r\n        }\r\n        ReadableByteStreamControllerClearAlgorithms(controller);\r\n        ReadableStreamClose(stream);\r\n    }\r\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n        const stream = controller._controlledReadableByteStream;\r\n        if (controller._closeRequested || stream._state !== 'readable') {\r\n            return;\r\n        }\r\n        const { buffer, byteOffset, byteLength } = chunk;\r\n        if (IsDetachedBuffer(buffer)) {\r\n            throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\r\n        }\r\n        const transferredBuffer = TransferArrayBuffer(buffer);\r\n        if (controller._pendingPullIntos.length > 0) {\r\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\r\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\r\n                throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk');\r\n            }\r\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\r\n            if (firstPendingPullInto.readerType === 'none') {\r\n                ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\r\n            }\r\n        }\r\n        if (ReadableStreamHasDefaultReader(stream)) {\r\n            ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\r\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n            }\r\n            else {\r\n                if (controller._pendingPullIntos.length > 0) {\r\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n                }\r\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n            }\r\n        }\r\n        else if (ReadableStreamHasBYOBReader(stream)) {\r\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\r\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n        }\r\n        else {\r\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n        }\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n    }\r\n    function ReadableByteStreamControllerError(controller, e) {\r\n        const stream = controller._controlledReadableByteStream;\r\n        if (stream._state !== 'readable') {\r\n            return;\r\n        }\r\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n        ResetQueue(controller);\r\n        ReadableByteStreamControllerClearAlgorithms(controller);\r\n        ReadableStreamError(stream, e);\r\n    }\r\n    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\r\n        const entry = controller._queue.shift();\r\n        controller._queueTotalSize -= entry.byteLength;\r\n        ReadableByteStreamControllerHandleQueueDrain(controller);\r\n        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n        readRequest._chunkSteps(view);\r\n    }\r\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\r\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\r\n            const firstDescriptor = controller._pendingPullIntos.peek();\r\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\r\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\r\n            controller._byobRequest = byobRequest;\r\n        }\r\n        return controller._byobRequest;\r\n    }\r\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\r\n        const state = controller._controlledReadableByteStream._state;\r\n        if (state === 'errored') {\r\n            return null;\r\n        }\r\n        if (state === 'closed') {\r\n            return 0;\r\n        }\r\n        return controller._strategyHWM - controller._queueTotalSize;\r\n    }\r\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n        const firstDescriptor = controller._pendingPullIntos.peek();\r\n        const state = controller._controlledReadableByteStream._state;\r\n        if (state === 'closed') {\r\n            if (bytesWritten !== 0) {\r\n                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n            }\r\n        }\r\n        else {\r\n            if (bytesWritten === 0) {\r\n                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\r\n            }\r\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\r\n                throw new RangeError('bytesWritten out of range');\r\n            }\r\n        }\r\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n    }\r\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n        const firstDescriptor = controller._pendingPullIntos.peek();\r\n        const state = controller._controlledReadableByteStream._state;\r\n        if (state === 'closed') {\r\n            if (view.byteLength !== 0) {\r\n                throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\r\n            }\r\n        }\r\n        else {\r\n            if (view.byteLength === 0) {\r\n                throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\r\n            }\r\n        }\r\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n            throw new RangeError('The region specified by view does not match byobRequest');\r\n        }\r\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\r\n            throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n        }\r\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\r\n            throw new RangeError('The region specified by view is larger than byobRequest');\r\n        }\r\n        const viewByteLength = view.byteLength;\r\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\r\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\r\n    }\r\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\r\n        controller._controlledReadableByteStream = stream;\r\n        controller._pullAgain = false;\r\n        controller._pulling = false;\r\n        controller._byobRequest = null;\r\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n        controller._queue = controller._queueTotalSize = undefined;\r\n        ResetQueue(controller);\r\n        controller._closeRequested = false;\r\n        controller._started = false;\r\n        controller._strategyHWM = highWaterMark;\r\n        controller._pullAlgorithm = pullAlgorithm;\r\n        controller._cancelAlgorithm = cancelAlgorithm;\r\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\r\n        controller._pendingPullIntos = new SimpleQueue();\r\n        stream._readableStreamController = controller;\r\n        const startResult = startAlgorithm();\r\n        uponPromise(promiseResolvedWith(startResult), () => {\r\n            controller._started = true;\r\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n            return null;\r\n        }, r => {\r\n            ReadableByteStreamControllerError(controller, r);\r\n            return null;\r\n        });\r\n    }\r\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\r\n        const controller = Object.create(ReadableByteStreamController.prototype);\r\n        let startAlgorithm;\r\n        let pullAlgorithm;\r\n        let cancelAlgorithm;\r\n        if (underlyingByteSource.start !== undefined) {\r\n            startAlgorithm = () => underlyingByteSource.start(controller);\r\n        }\r\n        else {\r\n            startAlgorithm = () => undefined;\r\n        }\r\n        if (underlyingByteSource.pull !== undefined) {\r\n            pullAlgorithm = () => underlyingByteSource.pull(controller);\r\n        }\r\n        else {\r\n            pullAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        if (underlyingByteSource.cancel !== undefined) {\r\n            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\r\n        }\r\n        else {\r\n            cancelAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n        if (autoAllocateChunkSize === 0) {\r\n            throw new TypeError('autoAllocateChunkSize must be greater than 0');\r\n        }\r\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\r\n    }\r\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\r\n        request._associatedReadableByteStreamController = controller;\r\n        request._view = view;\r\n    }\r\n    // Helper functions for the ReadableStreamBYOBRequest.\r\n    function byobRequestBrandCheckException(name) {\r\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\r\n    }\r\n    // Helper functions for the ReadableByteStreamController.\r\n    function byteStreamControllerBrandCheckException(name) {\r\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\r\n    }\r\n\r\n    function convertReaderOptions(options, context) {\r\n        assertDictionary(options, context);\r\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\r\n        return {\r\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\r\n        };\r\n    }\r\n    function convertReadableStreamReaderMode(mode, context) {\r\n        mode = `${mode}`;\r\n        if (mode !== 'byob') {\r\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\r\n        }\r\n        return mode;\r\n    }\r\n    function convertByobReadOptions(options, context) {\r\n        var _a;\r\n        assertDictionary(options, context);\r\n        const min = (_a = options === null || options === void 0 ? void 0 : options.min) !== null && _a !== void 0 ? _a : 1;\r\n        return {\r\n            min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)\r\n        };\r\n    }\r\n\r\n    // Abstract operations for the ReadableStream.\r\n    function AcquireReadableStreamBYOBReader(stream) {\r\n        return new ReadableStreamBYOBReader(stream);\r\n    }\r\n    // ReadableStream API exposed for controllers.\r\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\r\n        stream._reader._readIntoRequests.push(readIntoRequest);\r\n    }\r\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n        const reader = stream._reader;\r\n        const readIntoRequest = reader._readIntoRequests.shift();\r\n        if (done) {\r\n            readIntoRequest._closeSteps(chunk);\r\n        }\r\n        else {\r\n            readIntoRequest._chunkSteps(chunk);\r\n        }\r\n    }\r\n    function ReadableStreamGetNumReadIntoRequests(stream) {\r\n        return stream._reader._readIntoRequests.length;\r\n    }\r\n    function ReadableStreamHasBYOBReader(stream) {\r\n        const reader = stream._reader;\r\n        if (reader === undefined) {\r\n            return false;\r\n        }\r\n        if (!IsReadableStreamBYOBReader(reader)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A BYOB reader vended by a {@link ReadableStream}.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableStreamBYOBReader {\r\n        constructor(stream) {\r\n            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\r\n            assertReadableStream(stream, 'First parameter');\r\n            if (IsReadableStreamLocked(stream)) {\r\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n            }\r\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\r\n                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\r\n                    'source');\r\n            }\r\n            ReadableStreamReaderGenericInitialize(this, stream);\r\n            this._readIntoRequests = new SimpleQueue();\r\n        }\r\n        /**\r\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\r\n         * the reader's lock is released before the stream finishes closing.\r\n         */\r\n        get closed() {\r\n            if (!IsReadableStreamBYOBReader(this)) {\r\n                return promiseRejectedWith(byobReaderBrandCheckException('closed'));\r\n            }\r\n            return this._closedPromise;\r\n        }\r\n        /**\r\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\r\n         */\r\n        cancel(reason = undefined) {\r\n            if (!IsReadableStreamBYOBReader(this)) {\r\n                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return promiseRejectedWith(readerLockException('cancel'));\r\n            }\r\n            return ReadableStreamReaderGenericCancel(this, reason);\r\n        }\r\n        read(view, rawOptions = {}) {\r\n            if (!IsReadableStreamBYOBReader(this)) {\r\n                return promiseRejectedWith(byobReaderBrandCheckException('read'));\r\n            }\r\n            if (!ArrayBuffer.isView(view)) {\r\n                return promiseRejectedWith(new TypeError('view must be an array buffer view'));\r\n            }\r\n            if (view.byteLength === 0) {\r\n                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\r\n            }\r\n            if (view.buffer.byteLength === 0) {\r\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\r\n            }\r\n            if (IsDetachedBuffer(view.buffer)) {\r\n                return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\r\n            }\r\n            let options;\r\n            try {\r\n                options = convertByobReadOptions(rawOptions, 'options');\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            const min = options.min;\r\n            if (min === 0) {\r\n                return promiseRejectedWith(new TypeError('options.min must be greater than 0'));\r\n            }\r\n            if (!isDataView(view)) {\r\n                if (min > view.length) {\r\n                    return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s length'));\r\n                }\r\n            }\r\n            else if (min > view.byteLength) {\r\n                return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s byteLength'));\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return promiseRejectedWith(readerLockException('read from'));\r\n            }\r\n            let resolvePromise;\r\n            let rejectPromise;\r\n            const promise = newPromise((resolve, reject) => {\r\n                resolvePromise = resolve;\r\n                rejectPromise = reject;\r\n            });\r\n            const readIntoRequest = {\r\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\r\n                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\r\n                _errorSteps: e => rejectPromise(e)\r\n            };\r\n            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\r\n            return promise;\r\n        }\r\n        /**\r\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\r\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\r\n         * from now on; otherwise, the reader will appear closed.\r\n         *\r\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\r\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\r\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\r\n         */\r\n        releaseLock() {\r\n            if (!IsReadableStreamBYOBReader(this)) {\r\n                throw byobReaderBrandCheckException('releaseLock');\r\n            }\r\n            if (this._ownerReadableStream === undefined) {\r\n                return;\r\n            }\r\n            ReadableStreamBYOBReaderRelease(this);\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\r\n        cancel: { enumerable: true },\r\n        read: { enumerable: true },\r\n        releaseLock: { enumerable: true },\r\n        closed: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\r\n    setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\r\n    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableStreamBYOBReader',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the readers.\r\n    function IsReadableStreamBYOBReader(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableStreamBYOBReader;\r\n    }\r\n    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\r\n        const stream = reader._ownerReadableStream;\r\n        stream._disturbed = true;\r\n        if (stream._state === 'errored') {\r\n            readIntoRequest._errorSteps(stream._storedError);\r\n        }\r\n        else {\r\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\r\n        }\r\n    }\r\n    function ReadableStreamBYOBReaderRelease(reader) {\r\n        ReadableStreamReaderGenericRelease(reader);\r\n        const e = new TypeError('Reader was released');\r\n        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\r\n    }\r\n    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\r\n        const readIntoRequests = reader._readIntoRequests;\r\n        reader._readIntoRequests = new SimpleQueue();\r\n        readIntoRequests.forEach(readIntoRequest => {\r\n            readIntoRequest._errorSteps(e);\r\n        });\r\n    }\r\n    // Helper functions for the ReadableStreamBYOBReader.\r\n    function byobReaderBrandCheckException(name) {\r\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\r\n    }\r\n\r\n    function ExtractHighWaterMark(strategy, defaultHWM) {\r\n        const { highWaterMark } = strategy;\r\n        if (highWaterMark === undefined) {\r\n            return defaultHWM;\r\n        }\r\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\r\n            throw new RangeError('Invalid highWaterMark');\r\n        }\r\n        return highWaterMark;\r\n    }\r\n    function ExtractSizeAlgorithm(strategy) {\r\n        const { size } = strategy;\r\n        if (!size) {\r\n            return () => 1;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    function convertQueuingStrategy(init, context) {\r\n        assertDictionary(init, context);\r\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\r\n        const size = init === null || init === void 0 ? void 0 : init.size;\r\n        return {\r\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\r\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\r\n        };\r\n    }\r\n    function convertQueuingStrategySize(fn, context) {\r\n        assertFunction(fn, context);\r\n        return chunk => convertUnrestrictedDouble(fn(chunk));\r\n    }\r\n\r\n    function convertUnderlyingSink(original, context) {\r\n        assertDictionary(original, context);\r\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\r\n        const close = original === null || original === void 0 ? void 0 : original.close;\r\n        const start = original === null || original === void 0 ? void 0 : original.start;\r\n        const type = original === null || original === void 0 ? void 0 : original.type;\r\n        const write = original === null || original === void 0 ? void 0 : original.write;\r\n        return {\r\n            abort: abort === undefined ?\r\n                undefined :\r\n                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\r\n            close: close === undefined ?\r\n                undefined :\r\n                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\r\n            start: start === undefined ?\r\n                undefined :\r\n                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\r\n            write: write === undefined ?\r\n                undefined :\r\n                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\r\n            type\r\n        };\r\n    }\r\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (reason) => promiseCall(fn, original, [reason]);\r\n    }\r\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return () => promiseCall(fn, original, []);\r\n    }\r\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (controller) => reflectCall(fn, original, [controller]);\r\n    }\r\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\r\n    }\r\n\r\n    function assertWritableStream(x, context) {\r\n        if (!IsWritableStream(x)) {\r\n            throw new TypeError(`${context} is not a WritableStream.`);\r\n        }\r\n    }\r\n\r\n    function isAbortSignal(value) {\r\n        if (typeof value !== 'object' || value === null) {\r\n            return false;\r\n        }\r\n        try {\r\n            return typeof value.aborted === 'boolean';\r\n        }\r\n        catch (_a) {\r\n            // AbortSignal.prototype.aborted throws if its brand check fails\r\n            return false;\r\n        }\r\n    }\r\n    const supportsAbortController = typeof AbortController === 'function';\r\n    /**\r\n     * Construct a new AbortController, if supported by the platform.\r\n     *\r\n     * @internal\r\n     */\r\n    function createAbortController() {\r\n        if (supportsAbortController) {\r\n            return new AbortController();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * A writable stream represents a destination for data, into which you can write.\r\n     *\r\n     * @public\r\n     */\r\n    class WritableStream {\r\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\r\n            if (rawUnderlyingSink === undefined) {\r\n                rawUnderlyingSink = null;\r\n            }\r\n            else {\r\n                assertObject(rawUnderlyingSink, 'First parameter');\r\n            }\r\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\r\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\r\n            InitializeWritableStream(this);\r\n            const type = underlyingSink.type;\r\n            if (type !== undefined) {\r\n                throw new RangeError('Invalid type is specified');\r\n            }\r\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\r\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\r\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\r\n        }\r\n        /**\r\n         * Returns whether or not the writable stream is locked to a writer.\r\n         */\r\n        get locked() {\r\n            if (!IsWritableStream(this)) {\r\n                throw streamBrandCheckException$2('locked');\r\n            }\r\n            return IsWritableStreamLocked(this);\r\n        }\r\n        /**\r\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\r\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\r\n         * mechanism of the underlying sink.\r\n         *\r\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\r\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\r\n         * the stream) if the stream is currently locked.\r\n         */\r\n        abort(reason = undefined) {\r\n            if (!IsWritableStream(this)) {\r\n                return promiseRejectedWith(streamBrandCheckException$2('abort'));\r\n            }\r\n            if (IsWritableStreamLocked(this)) {\r\n                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\r\n            }\r\n            return WritableStreamAbort(this, reason);\r\n        }\r\n        /**\r\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\r\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\r\n         *\r\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\r\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\r\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\r\n         */\r\n        close() {\r\n            if (!IsWritableStream(this)) {\r\n                return promiseRejectedWith(streamBrandCheckException$2('close'));\r\n            }\r\n            if (IsWritableStreamLocked(this)) {\r\n                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\r\n            }\r\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\r\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\r\n            }\r\n            return WritableStreamClose(this);\r\n        }\r\n        /**\r\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\r\n         * is locked, no other writer can be acquired until this one is released.\r\n         *\r\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\r\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\r\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\r\n         */\r\n        getWriter() {\r\n            if (!IsWritableStream(this)) {\r\n                throw streamBrandCheckException$2('getWriter');\r\n            }\r\n            return AcquireWritableStreamDefaultWriter(this);\r\n        }\r\n    }\r\n    Object.defineProperties(WritableStream.prototype, {\r\n        abort: { enumerable: true },\r\n        close: { enumerable: true },\r\n        getWriter: { enumerable: true },\r\n        locked: { enumerable: true }\r\n    });\r\n    setFunctionName(WritableStream.prototype.abort, 'abort');\r\n    setFunctionName(WritableStream.prototype.close, 'close');\r\n    setFunctionName(WritableStream.prototype.getWriter, 'getWriter');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\r\n            value: 'WritableStream',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the WritableStream.\r\n    function AcquireWritableStreamDefaultWriter(stream) {\r\n        return new WritableStreamDefaultWriter(stream);\r\n    }\r\n    // Throws if and only if startAlgorithm throws.\r\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\r\n        const stream = Object.create(WritableStream.prototype);\r\n        InitializeWritableStream(stream);\r\n        const controller = Object.create(WritableStreamDefaultController.prototype);\r\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n        return stream;\r\n    }\r\n    function InitializeWritableStream(stream) {\r\n        stream._state = 'writable';\r\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\r\n        // 'erroring' or 'errored'. May be set to an undefined value.\r\n        stream._storedError = undefined;\r\n        stream._writer = undefined;\r\n        // Initialize to undefined first because the constructor of the controller checks this\r\n        // variable to validate the caller.\r\n        stream._writableStreamController = undefined;\r\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\r\n        // producer without waiting for the queued writes to finish.\r\n        stream._writeRequests = new SimpleQueue();\r\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\r\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\r\n        stream._inFlightWriteRequest = undefined;\r\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\r\n        // has been detached.\r\n        stream._closeRequest = undefined;\r\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\r\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\r\n        stream._inFlightCloseRequest = undefined;\r\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\r\n        stream._pendingAbortRequest = undefined;\r\n        // The backpressure signal set by the controller.\r\n        stream._backpressure = false;\r\n    }\r\n    function IsWritableStream(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n            return false;\r\n        }\r\n        return x instanceof WritableStream;\r\n    }\r\n    function IsWritableStreamLocked(stream) {\r\n        if (stream._writer === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function WritableStreamAbort(stream, reason) {\r\n        var _a;\r\n        if (stream._state === 'closed' || stream._state === 'errored') {\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        stream._writableStreamController._abortReason = reason;\r\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(reason);\r\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\r\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\r\n        // Widen the type again by casting to WritableStreamState.\r\n        const state = stream._state;\r\n        if (state === 'closed' || state === 'errored') {\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        if (stream._pendingAbortRequest !== undefined) {\r\n            return stream._pendingAbortRequest._promise;\r\n        }\r\n        let wasAlreadyErroring = false;\r\n        if (state === 'erroring') {\r\n            wasAlreadyErroring = true;\r\n            // reason will not be used, so don't keep a reference to it.\r\n            reason = undefined;\r\n        }\r\n        const promise = newPromise((resolve, reject) => {\r\n            stream._pendingAbortRequest = {\r\n                _promise: undefined,\r\n                _resolve: resolve,\r\n                _reject: reject,\r\n                _reason: reason,\r\n                _wasAlreadyErroring: wasAlreadyErroring\r\n            };\r\n        });\r\n        stream._pendingAbortRequest._promise = promise;\r\n        if (!wasAlreadyErroring) {\r\n            WritableStreamStartErroring(stream, reason);\r\n        }\r\n        return promise;\r\n    }\r\n    function WritableStreamClose(stream) {\r\n        const state = stream._state;\r\n        if (state === 'closed' || state === 'errored') {\r\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\r\n        }\r\n        const promise = newPromise((resolve, reject) => {\r\n            const closeRequest = {\r\n                _resolve: resolve,\r\n                _reject: reject\r\n            };\r\n            stream._closeRequest = closeRequest;\r\n        });\r\n        const writer = stream._writer;\r\n        if (writer !== undefined && stream._backpressure && state === 'writable') {\r\n            defaultWriterReadyPromiseResolve(writer);\r\n        }\r\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n        return promise;\r\n    }\r\n    // WritableStream API exposed for controllers.\r\n    function WritableStreamAddWriteRequest(stream) {\r\n        const promise = newPromise((resolve, reject) => {\r\n            const writeRequest = {\r\n                _resolve: resolve,\r\n                _reject: reject\r\n            };\r\n            stream._writeRequests.push(writeRequest);\r\n        });\r\n        return promise;\r\n    }\r\n    function WritableStreamDealWithRejection(stream, error) {\r\n        const state = stream._state;\r\n        if (state === 'writable') {\r\n            WritableStreamStartErroring(stream, error);\r\n            return;\r\n        }\r\n        WritableStreamFinishErroring(stream);\r\n    }\r\n    function WritableStreamStartErroring(stream, reason) {\r\n        const controller = stream._writableStreamController;\r\n        stream._state = 'erroring';\r\n        stream._storedError = reason;\r\n        const writer = stream._writer;\r\n        if (writer !== undefined) {\r\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n        }\r\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\r\n            WritableStreamFinishErroring(stream);\r\n        }\r\n    }\r\n    function WritableStreamFinishErroring(stream) {\r\n        stream._state = 'errored';\r\n        stream._writableStreamController[ErrorSteps]();\r\n        const storedError = stream._storedError;\r\n        stream._writeRequests.forEach(writeRequest => {\r\n            writeRequest._reject(storedError);\r\n        });\r\n        stream._writeRequests = new SimpleQueue();\r\n        if (stream._pendingAbortRequest === undefined) {\r\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n            return;\r\n        }\r\n        const abortRequest = stream._pendingAbortRequest;\r\n        stream._pendingAbortRequest = undefined;\r\n        if (abortRequest._wasAlreadyErroring) {\r\n            abortRequest._reject(storedError);\r\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n            return;\r\n        }\r\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\r\n        uponPromise(promise, () => {\r\n            abortRequest._resolve();\r\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n            return null;\r\n        }, (reason) => {\r\n            abortRequest._reject(reason);\r\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n            return null;\r\n        });\r\n    }\r\n    function WritableStreamFinishInFlightWrite(stream) {\r\n        stream._inFlightWriteRequest._resolve(undefined);\r\n        stream._inFlightWriteRequest = undefined;\r\n    }\r\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n        stream._inFlightWriteRequest._reject(error);\r\n        stream._inFlightWriteRequest = undefined;\r\n        WritableStreamDealWithRejection(stream, error);\r\n    }\r\n    function WritableStreamFinishInFlightClose(stream) {\r\n        stream._inFlightCloseRequest._resolve(undefined);\r\n        stream._inFlightCloseRequest = undefined;\r\n        const state = stream._state;\r\n        if (state === 'erroring') {\r\n            // The error was too late to do anything, so it is ignored.\r\n            stream._storedError = undefined;\r\n            if (stream._pendingAbortRequest !== undefined) {\r\n                stream._pendingAbortRequest._resolve();\r\n                stream._pendingAbortRequest = undefined;\r\n            }\r\n        }\r\n        stream._state = 'closed';\r\n        const writer = stream._writer;\r\n        if (writer !== undefined) {\r\n            defaultWriterClosedPromiseResolve(writer);\r\n        }\r\n    }\r\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n        stream._inFlightCloseRequest._reject(error);\r\n        stream._inFlightCloseRequest = undefined;\r\n        // Never execute sink abort() after sink close().\r\n        if (stream._pendingAbortRequest !== undefined) {\r\n            stream._pendingAbortRequest._reject(error);\r\n            stream._pendingAbortRequest = undefined;\r\n        }\r\n        WritableStreamDealWithRejection(stream, error);\r\n    }\r\n    // TODO(ricea): Fix alphabetical order.\r\n    function WritableStreamCloseQueuedOrInFlight(stream) {\r\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function WritableStreamHasOperationMarkedInFlight(stream) {\r\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function WritableStreamMarkCloseRequestInFlight(stream) {\r\n        stream._inFlightCloseRequest = stream._closeRequest;\r\n        stream._closeRequest = undefined;\r\n    }\r\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n    }\r\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n        if (stream._closeRequest !== undefined) {\r\n            stream._closeRequest._reject(stream._storedError);\r\n            stream._closeRequest = undefined;\r\n        }\r\n        const writer = stream._writer;\r\n        if (writer !== undefined) {\r\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n        }\r\n    }\r\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\r\n        const writer = stream._writer;\r\n        if (writer !== undefined && backpressure !== stream._backpressure) {\r\n            if (backpressure) {\r\n                defaultWriterReadyPromiseReset(writer);\r\n            }\r\n            else {\r\n                defaultWriterReadyPromiseResolve(writer);\r\n            }\r\n        }\r\n        stream._backpressure = backpressure;\r\n    }\r\n    /**\r\n     * A default writer vended by a {@link WritableStream}.\r\n     *\r\n     * @public\r\n     */\r\n    class WritableStreamDefaultWriter {\r\n        constructor(stream) {\r\n            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\r\n            assertWritableStream(stream, 'First parameter');\r\n            if (IsWritableStreamLocked(stream)) {\r\n                throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n            }\r\n            this._ownerWritableStream = stream;\r\n            stream._writer = this;\r\n            const state = stream._state;\r\n            if (state === 'writable') {\r\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\r\n                    defaultWriterReadyPromiseInitialize(this);\r\n                }\r\n                else {\r\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\r\n                }\r\n                defaultWriterClosedPromiseInitialize(this);\r\n            }\r\n            else if (state === 'erroring') {\r\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n                defaultWriterClosedPromiseInitialize(this);\r\n            }\r\n            else if (state === 'closed') {\r\n                defaultWriterReadyPromiseInitializeAsResolved(this);\r\n                defaultWriterClosedPromiseInitializeAsResolved(this);\r\n            }\r\n            else {\r\n                const storedError = stream._storedError;\r\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n            }\r\n        }\r\n        /**\r\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\r\n         * the writer’s lock is released before the stream finishes closing.\r\n         */\r\n        get closed() {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\r\n            }\r\n            return this._closedPromise;\r\n        }\r\n        /**\r\n         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\r\n         * A producer can use this information to determine the right amount of data to write.\r\n         *\r\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\r\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\r\n         * the writer’s lock is released.\r\n         */\r\n        get desiredSize() {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                throw defaultWriterBrandCheckException('desiredSize');\r\n            }\r\n            if (this._ownerWritableStream === undefined) {\r\n                throw defaultWriterLockException('desiredSize');\r\n            }\r\n            return WritableStreamDefaultWriterGetDesiredSize(this);\r\n        }\r\n        /**\r\n         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\r\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\r\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\r\n         *\r\n         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\r\n         * rejected.\r\n         */\r\n        get ready() {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\r\n            }\r\n            return this._readyPromise;\r\n        }\r\n        /**\r\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\r\n         */\r\n        abort(reason = undefined) {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\r\n            }\r\n            if (this._ownerWritableStream === undefined) {\r\n                return promiseRejectedWith(defaultWriterLockException('abort'));\r\n            }\r\n            return WritableStreamDefaultWriterAbort(this, reason);\r\n        }\r\n        /**\r\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\r\n         */\r\n        close() {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                return promiseRejectedWith(defaultWriterBrandCheckException('close'));\r\n            }\r\n            const stream = this._ownerWritableStream;\r\n            if (stream === undefined) {\r\n                return promiseRejectedWith(defaultWriterLockException('close'));\r\n            }\r\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\r\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\r\n            }\r\n            return WritableStreamDefaultWriterClose(this);\r\n        }\r\n        /**\r\n         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\r\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\r\n         * now on; otherwise, the writer will appear closed.\r\n         *\r\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\r\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\r\n         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\r\n         * other producers from writing in an interleaved manner.\r\n         */\r\n        releaseLock() {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                throw defaultWriterBrandCheckException('releaseLock');\r\n            }\r\n            const stream = this._ownerWritableStream;\r\n            if (stream === undefined) {\r\n                return;\r\n            }\r\n            WritableStreamDefaultWriterRelease(this);\r\n        }\r\n        write(chunk = undefined) {\r\n            if (!IsWritableStreamDefaultWriter(this)) {\r\n                return promiseRejectedWith(defaultWriterBrandCheckException('write'));\r\n            }\r\n            if (this._ownerWritableStream === undefined) {\r\n                return promiseRejectedWith(defaultWriterLockException('write to'));\r\n            }\r\n            return WritableStreamDefaultWriterWrite(this, chunk);\r\n        }\r\n    }\r\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\r\n        abort: { enumerable: true },\r\n        close: { enumerable: true },\r\n        releaseLock: { enumerable: true },\r\n        write: { enumerable: true },\r\n        closed: { enumerable: true },\r\n        desiredSize: { enumerable: true },\r\n        ready: { enumerable: true }\r\n    });\r\n    setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\r\n    setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\r\n    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\r\n    setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\r\n            value: 'WritableStreamDefaultWriter',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the WritableStreamDefaultWriter.\r\n    function IsWritableStreamDefaultWriter(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n            return false;\r\n        }\r\n        return x instanceof WritableStreamDefaultWriter;\r\n    }\r\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\r\n    function WritableStreamDefaultWriterAbort(writer, reason) {\r\n        const stream = writer._ownerWritableStream;\r\n        return WritableStreamAbort(stream, reason);\r\n    }\r\n    function WritableStreamDefaultWriterClose(writer) {\r\n        const stream = writer._ownerWritableStream;\r\n        return WritableStreamClose(stream);\r\n    }\r\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n        const stream = writer._ownerWritableStream;\r\n        const state = stream._state;\r\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        if (state === 'errored') {\r\n            return promiseRejectedWith(stream._storedError);\r\n        }\r\n        return WritableStreamDefaultWriterClose(writer);\r\n    }\r\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n        if (writer._closedPromiseState === 'pending') {\r\n            defaultWriterClosedPromiseReject(writer, error);\r\n        }\r\n        else {\r\n            defaultWriterClosedPromiseResetToRejected(writer, error);\r\n        }\r\n    }\r\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n        if (writer._readyPromiseState === 'pending') {\r\n            defaultWriterReadyPromiseReject(writer, error);\r\n        }\r\n        else {\r\n            defaultWriterReadyPromiseResetToRejected(writer, error);\r\n        }\r\n    }\r\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n        const stream = writer._ownerWritableStream;\r\n        const state = stream._state;\r\n        if (state === 'errored' || state === 'erroring') {\r\n            return null;\r\n        }\r\n        if (state === 'closed') {\r\n            return 0;\r\n        }\r\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n    }\r\n    function WritableStreamDefaultWriterRelease(writer) {\r\n        const stream = writer._ownerWritableStream;\r\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\r\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\r\n        // rejected until afterwards. This means that simply testing state will not work.\r\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n        stream._writer = undefined;\r\n        writer._ownerWritableStream = undefined;\r\n    }\r\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\r\n        const stream = writer._ownerWritableStream;\r\n        const controller = stream._writableStreamController;\r\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n        if (stream !== writer._ownerWritableStream) {\r\n            return promiseRejectedWith(defaultWriterLockException('write to'));\r\n        }\r\n        const state = stream._state;\r\n        if (state === 'errored') {\r\n            return promiseRejectedWith(stream._storedError);\r\n        }\r\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\r\n            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\r\n        }\r\n        if (state === 'erroring') {\r\n            return promiseRejectedWith(stream._storedError);\r\n        }\r\n        const promise = WritableStreamAddWriteRequest(stream);\r\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n        return promise;\r\n    }\r\n    const closeSentinel = {};\r\n    /**\r\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\r\n     *\r\n     * @public\r\n     */\r\n    class WritableStreamDefaultController {\r\n        constructor() {\r\n            throw new TypeError('Illegal constructor');\r\n        }\r\n        /**\r\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\r\n         *\r\n         * @deprecated\r\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\r\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\r\n         */\r\n        get abortReason() {\r\n            if (!IsWritableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$2('abortReason');\r\n            }\r\n            return this._abortReason;\r\n        }\r\n        /**\r\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\r\n         */\r\n        get signal() {\r\n            if (!IsWritableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$2('signal');\r\n            }\r\n            if (this._abortController === undefined) {\r\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\r\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\r\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\r\n                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\r\n            }\r\n            return this._abortController.signal;\r\n        }\r\n        /**\r\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\r\n         *\r\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\r\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\r\n         * normal lifecycle of interactions with the underlying sink.\r\n         */\r\n        error(e = undefined) {\r\n            if (!IsWritableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$2('error');\r\n            }\r\n            const state = this._controlledWritableStream._state;\r\n            if (state !== 'writable') {\r\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\r\n                // just treat it as a no-op.\r\n                return;\r\n            }\r\n            WritableStreamDefaultControllerError(this, e);\r\n        }\r\n        /** @internal */\r\n        [AbortSteps](reason) {\r\n            const result = this._abortAlgorithm(reason);\r\n            WritableStreamDefaultControllerClearAlgorithms(this);\r\n            return result;\r\n        }\r\n        /** @internal */\r\n        [ErrorSteps]() {\r\n            ResetQueue(this);\r\n        }\r\n    }\r\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\r\n        abortReason: { enumerable: true },\r\n        signal: { enumerable: true },\r\n        error: { enumerable: true }\r\n    });\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\r\n            value: 'WritableStreamDefaultController',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations implementing interface required by the WritableStream.\r\n    function IsWritableStreamDefaultController(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\r\n            return false;\r\n        }\r\n        return x instanceof WritableStreamDefaultController;\r\n    }\r\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\r\n        controller._controlledWritableStream = stream;\r\n        stream._writableStreamController = controller;\r\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n        controller._queue = undefined;\r\n        controller._queueTotalSize = undefined;\r\n        ResetQueue(controller);\r\n        controller._abortReason = undefined;\r\n        controller._abortController = createAbortController();\r\n        controller._started = false;\r\n        controller._strategySizeAlgorithm = sizeAlgorithm;\r\n        controller._strategyHWM = highWaterMark;\r\n        controller._writeAlgorithm = writeAlgorithm;\r\n        controller._closeAlgorithm = closeAlgorithm;\r\n        controller._abortAlgorithm = abortAlgorithm;\r\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n        const startResult = startAlgorithm();\r\n        const startPromise = promiseResolvedWith(startResult);\r\n        uponPromise(startPromise, () => {\r\n            controller._started = true;\r\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n            return null;\r\n        }, r => {\r\n            controller._started = true;\r\n            WritableStreamDealWithRejection(stream, r);\r\n            return null;\r\n        });\r\n    }\r\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\r\n        const controller = Object.create(WritableStreamDefaultController.prototype);\r\n        let startAlgorithm;\r\n        let writeAlgorithm;\r\n        let closeAlgorithm;\r\n        let abortAlgorithm;\r\n        if (underlyingSink.start !== undefined) {\r\n            startAlgorithm = () => underlyingSink.start(controller);\r\n        }\r\n        else {\r\n            startAlgorithm = () => undefined;\r\n        }\r\n        if (underlyingSink.write !== undefined) {\r\n            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\r\n        }\r\n        else {\r\n            writeAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        if (underlyingSink.close !== undefined) {\r\n            closeAlgorithm = () => underlyingSink.close();\r\n        }\r\n        else {\r\n            closeAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        if (underlyingSink.abort !== undefined) {\r\n            abortAlgorithm = reason => underlyingSink.abort(reason);\r\n        }\r\n        else {\r\n            abortAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n    }\r\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\r\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\r\n        controller._writeAlgorithm = undefined;\r\n        controller._closeAlgorithm = undefined;\r\n        controller._abortAlgorithm = undefined;\r\n        controller._strategySizeAlgorithm = undefined;\r\n    }\r\n    function WritableStreamDefaultControllerClose(controller) {\r\n        EnqueueValueWithSize(controller, closeSentinel, 0);\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    }\r\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n        try {\r\n            return controller._strategySizeAlgorithm(chunk);\r\n        }\r\n        catch (chunkSizeE) {\r\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n            return 1;\r\n        }\r\n    }\r\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n        return controller._strategyHWM - controller._queueTotalSize;\r\n    }\r\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n        try {\r\n            EnqueueValueWithSize(controller, chunk, chunkSize);\r\n        }\r\n        catch (enqueueE) {\r\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n            return;\r\n        }\r\n        const stream = controller._controlledWritableStream;\r\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\r\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n            WritableStreamUpdateBackpressure(stream, backpressure);\r\n        }\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    }\r\n    // Abstract operations for the WritableStreamDefaultController.\r\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n        const stream = controller._controlledWritableStream;\r\n        if (!controller._started) {\r\n            return;\r\n        }\r\n        if (stream._inFlightWriteRequest !== undefined) {\r\n            return;\r\n        }\r\n        const state = stream._state;\r\n        if (state === 'erroring') {\r\n            WritableStreamFinishErroring(stream);\r\n            return;\r\n        }\r\n        if (controller._queue.length === 0) {\r\n            return;\r\n        }\r\n        const value = PeekQueueValue(controller);\r\n        if (value === closeSentinel) {\r\n            WritableStreamDefaultControllerProcessClose(controller);\r\n        }\r\n        else {\r\n            WritableStreamDefaultControllerProcessWrite(controller, value);\r\n        }\r\n    }\r\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n        if (controller._controlledWritableStream._state === 'writable') {\r\n            WritableStreamDefaultControllerError(controller, error);\r\n        }\r\n    }\r\n    function WritableStreamDefaultControllerProcessClose(controller) {\r\n        const stream = controller._controlledWritableStream;\r\n        WritableStreamMarkCloseRequestInFlight(stream);\r\n        DequeueValue(controller);\r\n        const sinkClosePromise = controller._closeAlgorithm();\r\n        WritableStreamDefaultControllerClearAlgorithms(controller);\r\n        uponPromise(sinkClosePromise, () => {\r\n            WritableStreamFinishInFlightClose(stream);\r\n            return null;\r\n        }, reason => {\r\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n            return null;\r\n        });\r\n    }\r\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n        const stream = controller._controlledWritableStream;\r\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\r\n        uponPromise(sinkWritePromise, () => {\r\n            WritableStreamFinishInFlightWrite(stream);\r\n            const state = stream._state;\r\n            DequeueValue(controller);\r\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\r\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n                WritableStreamUpdateBackpressure(stream, backpressure);\r\n            }\r\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n            return null;\r\n        }, reason => {\r\n            if (stream._state === 'writable') {\r\n                WritableStreamDefaultControllerClearAlgorithms(controller);\r\n            }\r\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n            return null;\r\n        });\r\n    }\r\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\r\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n        return desiredSize <= 0;\r\n    }\r\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\r\n    function WritableStreamDefaultControllerError(controller, error) {\r\n        const stream = controller._controlledWritableStream;\r\n        WritableStreamDefaultControllerClearAlgorithms(controller);\r\n        WritableStreamStartErroring(stream, error);\r\n    }\r\n    // Helper functions for the WritableStream.\r\n    function streamBrandCheckException$2(name) {\r\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\r\n    }\r\n    // Helper functions for the WritableStreamDefaultController.\r\n    function defaultControllerBrandCheckException$2(name) {\r\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\r\n    }\r\n    // Helper functions for the WritableStreamDefaultWriter.\r\n    function defaultWriterBrandCheckException(name) {\r\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\r\n    }\r\n    function defaultWriterLockException(name) {\r\n        return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n    }\r\n    function defaultWriterClosedPromiseInitialize(writer) {\r\n        writer._closedPromise = newPromise((resolve, reject) => {\r\n            writer._closedPromise_resolve = resolve;\r\n            writer._closedPromise_reject = reject;\r\n            writer._closedPromiseState = 'pending';\r\n        });\r\n    }\r\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n        defaultWriterClosedPromiseInitialize(writer);\r\n        defaultWriterClosedPromiseReject(writer, reason);\r\n    }\r\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n        defaultWriterClosedPromiseInitialize(writer);\r\n        defaultWriterClosedPromiseResolve(writer);\r\n    }\r\n    function defaultWriterClosedPromiseReject(writer, reason) {\r\n        if (writer._closedPromise_reject === undefined) {\r\n            return;\r\n        }\r\n        setPromiseIsHandledToTrue(writer._closedPromise);\r\n        writer._closedPromise_reject(reason);\r\n        writer._closedPromise_resolve = undefined;\r\n        writer._closedPromise_reject = undefined;\r\n        writer._closedPromiseState = 'rejected';\r\n    }\r\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\r\n    }\r\n    function defaultWriterClosedPromiseResolve(writer) {\r\n        if (writer._closedPromise_resolve === undefined) {\r\n            return;\r\n        }\r\n        writer._closedPromise_resolve(undefined);\r\n        writer._closedPromise_resolve = undefined;\r\n        writer._closedPromise_reject = undefined;\r\n        writer._closedPromiseState = 'resolved';\r\n    }\r\n    function defaultWriterReadyPromiseInitialize(writer) {\r\n        writer._readyPromise = newPromise((resolve, reject) => {\r\n            writer._readyPromise_resolve = resolve;\r\n            writer._readyPromise_reject = reject;\r\n        });\r\n        writer._readyPromiseState = 'pending';\r\n    }\r\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n        defaultWriterReadyPromiseInitialize(writer);\r\n        defaultWriterReadyPromiseReject(writer, reason);\r\n    }\r\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n        defaultWriterReadyPromiseInitialize(writer);\r\n        defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n    function defaultWriterReadyPromiseReject(writer, reason) {\r\n        if (writer._readyPromise_reject === undefined) {\r\n            return;\r\n        }\r\n        setPromiseIsHandledToTrue(writer._readyPromise);\r\n        writer._readyPromise_reject(reason);\r\n        writer._readyPromise_resolve = undefined;\r\n        writer._readyPromise_reject = undefined;\r\n        writer._readyPromiseState = 'rejected';\r\n    }\r\n    function defaultWriterReadyPromiseReset(writer) {\r\n        defaultWriterReadyPromiseInitialize(writer);\r\n    }\r\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\r\n    }\r\n    function defaultWriterReadyPromiseResolve(writer) {\r\n        if (writer._readyPromise_resolve === undefined) {\r\n            return;\r\n        }\r\n        writer._readyPromise_resolve(undefined);\r\n        writer._readyPromise_resolve = undefined;\r\n        writer._readyPromise_reject = undefined;\r\n        writer._readyPromiseState = 'fulfilled';\r\n    }\r\n\r\n    /// <reference lib=\"dom\" />\r\n    function getGlobals() {\r\n        if (typeof globalThis !== 'undefined') {\r\n            return globalThis;\r\n        }\r\n        else if (typeof self !== 'undefined') {\r\n            return self;\r\n        }\r\n        else if (typeof global !== 'undefined') {\r\n            return global;\r\n        }\r\n        return undefined;\r\n    }\r\n    const globals = getGlobals();\r\n\r\n    /// <reference types=\"node\" />\r\n    function isDOMExceptionConstructor(ctor) {\r\n        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\r\n            return false;\r\n        }\r\n        if (ctor.name !== 'DOMException') {\r\n            return false;\r\n        }\r\n        try {\r\n            new ctor();\r\n            return true;\r\n        }\r\n        catch (_a) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Support:\r\n     * - Web browsers\r\n     * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\r\n     */\r\n    function getFromGlobal() {\r\n        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;\r\n        return isDOMExceptionConstructor(ctor) ? ctor : undefined;\r\n    }\r\n    /**\r\n     * Support:\r\n     * - All platforms\r\n     */\r\n    function createPolyfill() {\r\n        // eslint-disable-next-line @typescript-eslint/no-shadow\r\n        const ctor = function DOMException(message, name) {\r\n            this.message = message || '';\r\n            this.name = name || 'Error';\r\n            if (Error.captureStackTrace) {\r\n                Error.captureStackTrace(this, this.constructor);\r\n            }\r\n        };\r\n        setFunctionName(ctor, 'DOMException');\r\n        ctor.prototype = Object.create(Error.prototype);\r\n        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\r\n        return ctor;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-redeclare\r\n    const DOMException = getFromGlobal() || createPolyfill();\r\n\r\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\r\n        const reader = AcquireReadableStreamDefaultReader(source);\r\n        const writer = AcquireWritableStreamDefaultWriter(dest);\r\n        source._disturbed = true;\r\n        let shuttingDown = false;\r\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\r\n        let currentWrite = promiseResolvedWith(undefined);\r\n        return newPromise((resolve, reject) => {\r\n            let abortAlgorithm;\r\n            if (signal !== undefined) {\r\n                abortAlgorithm = () => {\r\n                    const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');\r\n                    const actions = [];\r\n                    if (!preventAbort) {\r\n                        actions.push(() => {\r\n                            if (dest._state === 'writable') {\r\n                                return WritableStreamAbort(dest, error);\r\n                            }\r\n                            return promiseResolvedWith(undefined);\r\n                        });\r\n                    }\r\n                    if (!preventCancel) {\r\n                        actions.push(() => {\r\n                            if (source._state === 'readable') {\r\n                                return ReadableStreamCancel(source, error);\r\n                            }\r\n                            return promiseResolvedWith(undefined);\r\n                        });\r\n                    }\r\n                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\r\n                };\r\n                if (signal.aborted) {\r\n                    abortAlgorithm();\r\n                    return;\r\n                }\r\n                signal.addEventListener('abort', abortAlgorithm);\r\n            }\r\n            // Using reader and writer, read all chunks from this and write them to dest\r\n            // - Backpressure must be enforced\r\n            // - Shutdown must stop all activity\r\n            function pipeLoop() {\r\n                return newPromise((resolveLoop, rejectLoop) => {\r\n                    function next(done) {\r\n                        if (done) {\r\n                            resolveLoop();\r\n                        }\r\n                        else {\r\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\r\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\r\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\r\n                        }\r\n                    }\r\n                    next(false);\r\n                });\r\n            }\r\n            function pipeStep() {\r\n                if (shuttingDown) {\r\n                    return promiseResolvedWith(true);\r\n                }\r\n                return PerformPromiseThen(writer._readyPromise, () => {\r\n                    return newPromise((resolveRead, rejectRead) => {\r\n                        ReadableStreamDefaultReaderRead(reader, {\r\n                            _chunkSteps: chunk => {\r\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\r\n                                resolveRead(false);\r\n                            },\r\n                            _closeSteps: () => resolveRead(true),\r\n                            _errorSteps: rejectRead\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n            // Errors must be propagated forward\r\n            isOrBecomesErrored(source, reader._closedPromise, storedError => {\r\n                if (!preventAbort) {\r\n                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\r\n                }\r\n                else {\r\n                    shutdown(true, storedError);\r\n                }\r\n                return null;\r\n            });\r\n            // Errors must be propagated backward\r\n            isOrBecomesErrored(dest, writer._closedPromise, storedError => {\r\n                if (!preventCancel) {\r\n                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\r\n                }\r\n                else {\r\n                    shutdown(true, storedError);\r\n                }\r\n                return null;\r\n            });\r\n            // Closing must be propagated forward\r\n            isOrBecomesClosed(source, reader._closedPromise, () => {\r\n                if (!preventClose) {\r\n                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\r\n                }\r\n                else {\r\n                    shutdown();\r\n                }\r\n                return null;\r\n            });\r\n            // Closing must be propagated backward\r\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\r\n                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n                if (!preventCancel) {\r\n                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\r\n                }\r\n                else {\r\n                    shutdown(true, destClosed);\r\n                }\r\n            }\r\n            setPromiseIsHandledToTrue(pipeLoop());\r\n            function waitForWritesToFinish() {\r\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\r\n                // for that too.\r\n                const oldCurrentWrite = currentWrite;\r\n                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\r\n            }\r\n            function isOrBecomesErrored(stream, promise, action) {\r\n                if (stream._state === 'errored') {\r\n                    action(stream._storedError);\r\n                }\r\n                else {\r\n                    uponRejection(promise, action);\r\n                }\r\n            }\r\n            function isOrBecomesClosed(stream, promise, action) {\r\n                if (stream._state === 'closed') {\r\n                    action();\r\n                }\r\n                else {\r\n                    uponFulfillment(promise, action);\r\n                }\r\n            }\r\n            function shutdownWithAction(action, originalIsError, originalError) {\r\n                if (shuttingDown) {\r\n                    return;\r\n                }\r\n                shuttingDown = true;\r\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\r\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\r\n                }\r\n                else {\r\n                    doTheRest();\r\n                }\r\n                function doTheRest() {\r\n                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\r\n                    return null;\r\n                }\r\n            }\r\n            function shutdown(isError, error) {\r\n                if (shuttingDown) {\r\n                    return;\r\n                }\r\n                shuttingDown = true;\r\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\r\n                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\r\n                }\r\n                else {\r\n                    finalize(isError, error);\r\n                }\r\n            }\r\n            function finalize(isError, error) {\r\n                WritableStreamDefaultWriterRelease(writer);\r\n                ReadableStreamReaderGenericRelease(reader);\r\n                if (signal !== undefined) {\r\n                    signal.removeEventListener('abort', abortAlgorithm);\r\n                }\r\n                if (isError) {\r\n                    reject(error);\r\n                }\r\n                else {\r\n                    resolve(undefined);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableStreamDefaultController {\r\n        constructor() {\r\n            throw new TypeError('Illegal constructor');\r\n        }\r\n        /**\r\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\r\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\r\n         */\r\n        get desiredSize() {\r\n            if (!IsReadableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$1('desiredSize');\r\n            }\r\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n        }\r\n        /**\r\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\r\n         * the stream, but once those are read, the stream will become closed.\r\n         */\r\n        close() {\r\n            if (!IsReadableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$1('close');\r\n            }\r\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\r\n                throw new TypeError('The stream is not in a state that permits close');\r\n            }\r\n            ReadableStreamDefaultControllerClose(this);\r\n        }\r\n        enqueue(chunk = undefined) {\r\n            if (!IsReadableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$1('enqueue');\r\n            }\r\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\r\n                throw new TypeError('The stream is not in a state that permits enqueue');\r\n            }\r\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n        }\r\n        /**\r\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\r\n         */\r\n        error(e = undefined) {\r\n            if (!IsReadableStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException$1('error');\r\n            }\r\n            ReadableStreamDefaultControllerError(this, e);\r\n        }\r\n        /** @internal */\r\n        [CancelSteps](reason) {\r\n            ResetQueue(this);\r\n            const result = this._cancelAlgorithm(reason);\r\n            ReadableStreamDefaultControllerClearAlgorithms(this);\r\n            return result;\r\n        }\r\n        /** @internal */\r\n        [PullSteps](readRequest) {\r\n            const stream = this._controlledReadableStream;\r\n            if (this._queue.length > 0) {\r\n                const chunk = DequeueValue(this);\r\n                if (this._closeRequested && this._queue.length === 0) {\r\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\r\n                    ReadableStreamClose(stream);\r\n                }\r\n                else {\r\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n                }\r\n                readRequest._chunkSteps(chunk);\r\n            }\r\n            else {\r\n                ReadableStreamAddReadRequest(stream, readRequest);\r\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n            }\r\n        }\r\n        /** @internal */\r\n        [ReleaseSteps]() {\r\n            // Do nothing.\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\r\n        close: { enumerable: true },\r\n        enqueue: { enumerable: true },\r\n        error: { enumerable: true },\r\n        desiredSize: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableStreamDefaultController.prototype.close, 'close');\r\n    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');\r\n    setFunctionName(ReadableStreamDefaultController.prototype.error, 'error');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableStreamDefaultController',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Abstract operations for the ReadableStreamDefaultController.\r\n    function IsReadableStreamDefaultController(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableStreamDefaultController;\r\n    }\r\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n        if (!shouldPull) {\r\n            return;\r\n        }\r\n        if (controller._pulling) {\r\n            controller._pullAgain = true;\r\n            return;\r\n        }\r\n        controller._pulling = true;\r\n        const pullPromise = controller._pullAlgorithm();\r\n        uponPromise(pullPromise, () => {\r\n            controller._pulling = false;\r\n            if (controller._pullAgain) {\r\n                controller._pullAgain = false;\r\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n            }\r\n            return null;\r\n        }, e => {\r\n            ReadableStreamDefaultControllerError(controller, e);\r\n            return null;\r\n        });\r\n    }\r\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n        const stream = controller._controlledReadableStream;\r\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\r\n            return false;\r\n        }\r\n        if (!controller._started) {\r\n            return false;\r\n        }\r\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n            return true;\r\n        }\r\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n        if (desiredSize > 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\r\n        controller._pullAlgorithm = undefined;\r\n        controller._cancelAlgorithm = undefined;\r\n        controller._strategySizeAlgorithm = undefined;\r\n    }\r\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\r\n    function ReadableStreamDefaultControllerClose(controller) {\r\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\r\n            return;\r\n        }\r\n        const stream = controller._controlledReadableStream;\r\n        controller._closeRequested = true;\r\n        if (controller._queue.length === 0) {\r\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\r\n            ReadableStreamClose(stream);\r\n        }\r\n    }\r\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\r\n            return;\r\n        }\r\n        const stream = controller._controlledReadableStream;\r\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n        }\r\n        else {\r\n            let chunkSize;\r\n            try {\r\n                chunkSize = controller._strategySizeAlgorithm(chunk);\r\n            }\r\n            catch (chunkSizeE) {\r\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\r\n                throw chunkSizeE;\r\n            }\r\n            try {\r\n                EnqueueValueWithSize(controller, chunk, chunkSize);\r\n            }\r\n            catch (enqueueE) {\r\n                ReadableStreamDefaultControllerError(controller, enqueueE);\r\n                throw enqueueE;\r\n            }\r\n        }\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    }\r\n    function ReadableStreamDefaultControllerError(controller, e) {\r\n        const stream = controller._controlledReadableStream;\r\n        if (stream._state !== 'readable') {\r\n            return;\r\n        }\r\n        ResetQueue(controller);\r\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\r\n        ReadableStreamError(stream, e);\r\n    }\r\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n        const state = controller._controlledReadableStream._state;\r\n        if (state === 'errored') {\r\n            return null;\r\n        }\r\n        if (state === 'closed') {\r\n            return 0;\r\n        }\r\n        return controller._strategyHWM - controller._queueTotalSize;\r\n    }\r\n    // This is used in the implementation of TransformStream.\r\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\r\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\r\n        const state = controller._controlledReadableStream._state;\r\n        if (!controller._closeRequested && state === 'readable') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\r\n        controller._controlledReadableStream = stream;\r\n        controller._queue = undefined;\r\n        controller._queueTotalSize = undefined;\r\n        ResetQueue(controller);\r\n        controller._started = false;\r\n        controller._closeRequested = false;\r\n        controller._pullAgain = false;\r\n        controller._pulling = false;\r\n        controller._strategySizeAlgorithm = sizeAlgorithm;\r\n        controller._strategyHWM = highWaterMark;\r\n        controller._pullAlgorithm = pullAlgorithm;\r\n        controller._cancelAlgorithm = cancelAlgorithm;\r\n        stream._readableStreamController = controller;\r\n        const startResult = startAlgorithm();\r\n        uponPromise(promiseResolvedWith(startResult), () => {\r\n            controller._started = true;\r\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n            return null;\r\n        }, r => {\r\n            ReadableStreamDefaultControllerError(controller, r);\r\n            return null;\r\n        });\r\n    }\r\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\r\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n        let startAlgorithm;\r\n        let pullAlgorithm;\r\n        let cancelAlgorithm;\r\n        if (underlyingSource.start !== undefined) {\r\n            startAlgorithm = () => underlyingSource.start(controller);\r\n        }\r\n        else {\r\n            startAlgorithm = () => undefined;\r\n        }\r\n        if (underlyingSource.pull !== undefined) {\r\n            pullAlgorithm = () => underlyingSource.pull(controller);\r\n        }\r\n        else {\r\n            pullAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        if (underlyingSource.cancel !== undefined) {\r\n            cancelAlgorithm = reason => underlyingSource.cancel(reason);\r\n        }\r\n        else {\r\n            cancelAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\r\n    }\r\n    // Helper functions for the ReadableStreamDefaultController.\r\n    function defaultControllerBrandCheckException$1(name) {\r\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\r\n    }\r\n\r\n    function ReadableStreamTee(stream, cloneForBranch2) {\r\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\r\n            return ReadableByteStreamTee(stream);\r\n        }\r\n        return ReadableStreamDefaultTee(stream);\r\n    }\r\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\r\n        const reader = AcquireReadableStreamDefaultReader(stream);\r\n        let reading = false;\r\n        let readAgain = false;\r\n        let canceled1 = false;\r\n        let canceled2 = false;\r\n        let reason1;\r\n        let reason2;\r\n        let branch1;\r\n        let branch2;\r\n        let resolveCancelPromise;\r\n        const cancelPromise = newPromise(resolve => {\r\n            resolveCancelPromise = resolve;\r\n        });\r\n        function pullAlgorithm() {\r\n            if (reading) {\r\n                readAgain = true;\r\n                return promiseResolvedWith(undefined);\r\n            }\r\n            reading = true;\r\n            const readRequest = {\r\n                _chunkSteps: chunk => {\r\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\r\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\r\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\r\n                    _queueMicrotask(() => {\r\n                        readAgain = false;\r\n                        const chunk1 = chunk;\r\n                        const chunk2 = chunk;\r\n                        // There is no way to access the cloning code right now in the reference implementation.\r\n                        // If we add one then we'll need an implementation for serializable objects.\r\n                        // if (!canceled2 && cloneForBranch2) {\r\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\r\n                        // }\r\n                        if (!canceled1) {\r\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\r\n                        }\r\n                        if (!canceled2) {\r\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\r\n                        }\r\n                        reading = false;\r\n                        if (readAgain) {\r\n                            pullAlgorithm();\r\n                        }\r\n                    });\r\n                },\r\n                _closeSteps: () => {\r\n                    reading = false;\r\n                    if (!canceled1) {\r\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\r\n                    }\r\n                    if (!canceled2) {\r\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\r\n                    }\r\n                    if (!canceled1 || !canceled2) {\r\n                        resolveCancelPromise(undefined);\r\n                    }\r\n                },\r\n                _errorSteps: () => {\r\n                    reading = false;\r\n                }\r\n            };\r\n            ReadableStreamDefaultReaderRead(reader, readRequest);\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        function cancel1Algorithm(reason) {\r\n            canceled1 = true;\r\n            reason1 = reason;\r\n            if (canceled2) {\r\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\r\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n                resolveCancelPromise(cancelResult);\r\n            }\r\n            return cancelPromise;\r\n        }\r\n        function cancel2Algorithm(reason) {\r\n            canceled2 = true;\r\n            reason2 = reason;\r\n            if (canceled1) {\r\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\r\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n                resolveCancelPromise(cancelResult);\r\n            }\r\n            return cancelPromise;\r\n        }\r\n        function startAlgorithm() {\r\n            // do nothing\r\n        }\r\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\r\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\r\n        uponRejection(reader._closedPromise, (r) => {\r\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\r\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\r\n            if (!canceled1 || !canceled2) {\r\n                resolveCancelPromise(undefined);\r\n            }\r\n            return null;\r\n        });\r\n        return [branch1, branch2];\r\n    }\r\n    function ReadableByteStreamTee(stream) {\r\n        let reader = AcquireReadableStreamDefaultReader(stream);\r\n        let reading = false;\r\n        let readAgainForBranch1 = false;\r\n        let readAgainForBranch2 = false;\r\n        let canceled1 = false;\r\n        let canceled2 = false;\r\n        let reason1;\r\n        let reason2;\r\n        let branch1;\r\n        let branch2;\r\n        let resolveCancelPromise;\r\n        const cancelPromise = newPromise(resolve => {\r\n            resolveCancelPromise = resolve;\r\n        });\r\n        function forwardReaderError(thisReader) {\r\n            uponRejection(thisReader._closedPromise, r => {\r\n                if (thisReader !== reader) {\r\n                    return null;\r\n                }\r\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\r\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\r\n                if (!canceled1 || !canceled2) {\r\n                    resolveCancelPromise(undefined);\r\n                }\r\n                return null;\r\n            });\r\n        }\r\n        function pullWithDefaultReader() {\r\n            if (IsReadableStreamBYOBReader(reader)) {\r\n                ReadableStreamReaderGenericRelease(reader);\r\n                reader = AcquireReadableStreamDefaultReader(stream);\r\n                forwardReaderError(reader);\r\n            }\r\n            const readRequest = {\r\n                _chunkSteps: chunk => {\r\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\r\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\r\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\r\n                    _queueMicrotask(() => {\r\n                        readAgainForBranch1 = false;\r\n                        readAgainForBranch2 = false;\r\n                        const chunk1 = chunk;\r\n                        let chunk2 = chunk;\r\n                        if (!canceled1 && !canceled2) {\r\n                            try {\r\n                                chunk2 = CloneAsUint8Array(chunk);\r\n                            }\r\n                            catch (cloneE) {\r\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\r\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\r\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\r\n                                return;\r\n                            }\r\n                        }\r\n                        if (!canceled1) {\r\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\r\n                        }\r\n                        if (!canceled2) {\r\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\r\n                        }\r\n                        reading = false;\r\n                        if (readAgainForBranch1) {\r\n                            pull1Algorithm();\r\n                        }\r\n                        else if (readAgainForBranch2) {\r\n                            pull2Algorithm();\r\n                        }\r\n                    });\r\n                },\r\n                _closeSteps: () => {\r\n                    reading = false;\r\n                    if (!canceled1) {\r\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\r\n                    }\r\n                    if (!canceled2) {\r\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\r\n                    }\r\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\r\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\r\n                    }\r\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\r\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\r\n                    }\r\n                    if (!canceled1 || !canceled2) {\r\n                        resolveCancelPromise(undefined);\r\n                    }\r\n                },\r\n                _errorSteps: () => {\r\n                    reading = false;\r\n                }\r\n            };\r\n            ReadableStreamDefaultReaderRead(reader, readRequest);\r\n        }\r\n        function pullWithBYOBReader(view, forBranch2) {\r\n            if (IsReadableStreamDefaultReader(reader)) {\r\n                ReadableStreamReaderGenericRelease(reader);\r\n                reader = AcquireReadableStreamBYOBReader(stream);\r\n                forwardReaderError(reader);\r\n            }\r\n            const byobBranch = forBranch2 ? branch2 : branch1;\r\n            const otherBranch = forBranch2 ? branch1 : branch2;\r\n            const readIntoRequest = {\r\n                _chunkSteps: chunk => {\r\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\r\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\r\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\r\n                    _queueMicrotask(() => {\r\n                        readAgainForBranch1 = false;\r\n                        readAgainForBranch2 = false;\r\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\r\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\r\n                        if (!otherCanceled) {\r\n                            let clonedChunk;\r\n                            try {\r\n                                clonedChunk = CloneAsUint8Array(chunk);\r\n                            }\r\n                            catch (cloneE) {\r\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\r\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\r\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\r\n                                return;\r\n                            }\r\n                            if (!byobCanceled) {\r\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\r\n                            }\r\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\r\n                        }\r\n                        else if (!byobCanceled) {\r\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\r\n                        }\r\n                        reading = false;\r\n                        if (readAgainForBranch1) {\r\n                            pull1Algorithm();\r\n                        }\r\n                        else if (readAgainForBranch2) {\r\n                            pull2Algorithm();\r\n                        }\r\n                    });\r\n                },\r\n                _closeSteps: chunk => {\r\n                    reading = false;\r\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\r\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\r\n                    if (!byobCanceled) {\r\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\r\n                    }\r\n                    if (!otherCanceled) {\r\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\r\n                    }\r\n                    if (chunk !== undefined) {\r\n                        if (!byobCanceled) {\r\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\r\n                        }\r\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\r\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\r\n                        }\r\n                    }\r\n                    if (!byobCanceled || !otherCanceled) {\r\n                        resolveCancelPromise(undefined);\r\n                    }\r\n                },\r\n                _errorSteps: () => {\r\n                    reading = false;\r\n                }\r\n            };\r\n            ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\r\n        }\r\n        function pull1Algorithm() {\r\n            if (reading) {\r\n                readAgainForBranch1 = true;\r\n                return promiseResolvedWith(undefined);\r\n            }\r\n            reading = true;\r\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\r\n            if (byobRequest === null) {\r\n                pullWithDefaultReader();\r\n            }\r\n            else {\r\n                pullWithBYOBReader(byobRequest._view, false);\r\n            }\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        function pull2Algorithm() {\r\n            if (reading) {\r\n                readAgainForBranch2 = true;\r\n                return promiseResolvedWith(undefined);\r\n            }\r\n            reading = true;\r\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\r\n            if (byobRequest === null) {\r\n                pullWithDefaultReader();\r\n            }\r\n            else {\r\n                pullWithBYOBReader(byobRequest._view, true);\r\n            }\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        function cancel1Algorithm(reason) {\r\n            canceled1 = true;\r\n            reason1 = reason;\r\n            if (canceled2) {\r\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\r\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n                resolveCancelPromise(cancelResult);\r\n            }\r\n            return cancelPromise;\r\n        }\r\n        function cancel2Algorithm(reason) {\r\n            canceled2 = true;\r\n            reason2 = reason;\r\n            if (canceled1) {\r\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\r\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n                resolveCancelPromise(cancelResult);\r\n            }\r\n            return cancelPromise;\r\n        }\r\n        function startAlgorithm() {\r\n            return;\r\n        }\r\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\r\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\r\n        forwardReaderError(reader);\r\n        return [branch1, branch2];\r\n    }\r\n\r\n    function isReadableStreamLike(stream) {\r\n        return typeIsObject(stream) && typeof stream.getReader !== 'undefined';\r\n    }\r\n\r\n    function ReadableStreamFrom(source) {\r\n        if (isReadableStreamLike(source)) {\r\n            return ReadableStreamFromDefaultReader(source.getReader());\r\n        }\r\n        return ReadableStreamFromIterable(source);\r\n    }\r\n    function ReadableStreamFromIterable(asyncIterable) {\r\n        let stream;\r\n        const iteratorRecord = GetIterator(asyncIterable, 'async');\r\n        const startAlgorithm = noop;\r\n        function pullAlgorithm() {\r\n            let nextResult;\r\n            try {\r\n                nextResult = IteratorNext(iteratorRecord);\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            const nextPromise = promiseResolvedWith(nextResult);\r\n            return transformPromiseWith(nextPromise, iterResult => {\r\n                if (!typeIsObject(iterResult)) {\r\n                    throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');\r\n                }\r\n                const done = IteratorComplete(iterResult);\r\n                if (done) {\r\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\r\n                }\r\n                else {\r\n                    const value = IteratorValue(iterResult);\r\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\r\n                }\r\n            });\r\n        }\r\n        function cancelAlgorithm(reason) {\r\n            const iterator = iteratorRecord.iterator;\r\n            let returnMethod;\r\n            try {\r\n                returnMethod = GetMethod(iterator, 'return');\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            if (returnMethod === undefined) {\r\n                return promiseResolvedWith(undefined);\r\n            }\r\n            let returnResult;\r\n            try {\r\n                returnResult = reflectCall(returnMethod, iterator, [reason]);\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            const returnPromise = promiseResolvedWith(returnResult);\r\n            return transformPromiseWith(returnPromise, iterResult => {\r\n                if (!typeIsObject(iterResult)) {\r\n                    throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');\r\n                }\r\n                return undefined;\r\n            });\r\n        }\r\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\r\n        return stream;\r\n    }\r\n    function ReadableStreamFromDefaultReader(reader) {\r\n        let stream;\r\n        const startAlgorithm = noop;\r\n        function pullAlgorithm() {\r\n            let readPromise;\r\n            try {\r\n                readPromise = reader.read();\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            return transformPromiseWith(readPromise, readResult => {\r\n                if (!typeIsObject(readResult)) {\r\n                    throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\r\n                }\r\n                if (readResult.done) {\r\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\r\n                }\r\n                else {\r\n                    const value = readResult.value;\r\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\r\n                }\r\n            });\r\n        }\r\n        function cancelAlgorithm(reason) {\r\n            try {\r\n                return promiseResolvedWith(reader.cancel(reason));\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n        }\r\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\r\n        return stream;\r\n    }\r\n\r\n    function convertUnderlyingDefaultOrByteSource(source, context) {\r\n        assertDictionary(source, context);\r\n        const original = source;\r\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\r\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\r\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\r\n        const start = original === null || original === void 0 ? void 0 : original.start;\r\n        const type = original === null || original === void 0 ? void 0 : original.type;\r\n        return {\r\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\r\n                undefined :\r\n                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\r\n            cancel: cancel === undefined ?\r\n                undefined :\r\n                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\r\n            pull: pull === undefined ?\r\n                undefined :\r\n                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\r\n            start: start === undefined ?\r\n                undefined :\r\n                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\r\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\r\n        };\r\n    }\r\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (reason) => promiseCall(fn, original, [reason]);\r\n    }\r\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (controller) => promiseCall(fn, original, [controller]);\r\n    }\r\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (controller) => reflectCall(fn, original, [controller]);\r\n    }\r\n    function convertReadableStreamType(type, context) {\r\n        type = `${type}`;\r\n        if (type !== 'bytes') {\r\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\r\n        }\r\n        return type;\r\n    }\r\n\r\n    function convertIteratorOptions(options, context) {\r\n        assertDictionary(options, context);\r\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\r\n        return { preventCancel: Boolean(preventCancel) };\r\n    }\r\n\r\n    function convertPipeOptions(options, context) {\r\n        assertDictionary(options, context);\r\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\r\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\r\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\r\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\r\n        if (signal !== undefined) {\r\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\r\n        }\r\n        return {\r\n            preventAbort: Boolean(preventAbort),\r\n            preventCancel: Boolean(preventCancel),\r\n            preventClose: Boolean(preventClose),\r\n            signal\r\n        };\r\n    }\r\n    function assertAbortSignal(signal, context) {\r\n        if (!isAbortSignal(signal)) {\r\n            throw new TypeError(`${context} is not an AbortSignal.`);\r\n        }\r\n    }\r\n\r\n    function convertReadableWritablePair(pair, context) {\r\n        assertDictionary(pair, context);\r\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\r\n        assertRequiredField(readable, 'readable', 'ReadableWritablePair');\r\n        assertReadableStream(readable, `${context} has member 'readable' that`);\r\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\r\n        assertRequiredField(writable, 'writable', 'ReadableWritablePair');\r\n        assertWritableStream(writable, `${context} has member 'writable' that`);\r\n        return { readable, writable };\r\n    }\r\n\r\n    /**\r\n     * A readable stream represents a source of data, from which you can read.\r\n     *\r\n     * @public\r\n     */\r\n    class ReadableStream {\r\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\r\n            if (rawUnderlyingSource === undefined) {\r\n                rawUnderlyingSource = null;\r\n            }\r\n            else {\r\n                assertObject(rawUnderlyingSource, 'First parameter');\r\n            }\r\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\r\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\r\n            InitializeReadableStream(this);\r\n            if (underlyingSource.type === 'bytes') {\r\n                if (strategy.size !== undefined) {\r\n                    throw new RangeError('The strategy for a byte stream cannot have a size function');\r\n                }\r\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\r\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\r\n            }\r\n            else {\r\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\r\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\r\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\r\n            }\r\n        }\r\n        /**\r\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\r\n         */\r\n        get locked() {\r\n            if (!IsReadableStream(this)) {\r\n                throw streamBrandCheckException$1('locked');\r\n            }\r\n            return IsReadableStreamLocked(this);\r\n        }\r\n        /**\r\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\r\n         *\r\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\r\n         * method, which might or might not use it.\r\n         */\r\n        cancel(reason = undefined) {\r\n            if (!IsReadableStream(this)) {\r\n                return promiseRejectedWith(streamBrandCheckException$1('cancel'));\r\n            }\r\n            if (IsReadableStreamLocked(this)) {\r\n                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\r\n            }\r\n            return ReadableStreamCancel(this, reason);\r\n        }\r\n        getReader(rawOptions = undefined) {\r\n            if (!IsReadableStream(this)) {\r\n                throw streamBrandCheckException$1('getReader');\r\n            }\r\n            const options = convertReaderOptions(rawOptions, 'First parameter');\r\n            if (options.mode === undefined) {\r\n                return AcquireReadableStreamDefaultReader(this);\r\n            }\r\n            return AcquireReadableStreamBYOBReader(this);\r\n        }\r\n        pipeThrough(rawTransform, rawOptions = {}) {\r\n            if (!IsReadableStream(this)) {\r\n                throw streamBrandCheckException$1('pipeThrough');\r\n            }\r\n            assertRequiredArgument(rawTransform, 1, 'pipeThrough');\r\n            const transform = convertReadableWritablePair(rawTransform, 'First parameter');\r\n            const options = convertPipeOptions(rawOptions, 'Second parameter');\r\n            if (IsReadableStreamLocked(this)) {\r\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\r\n            }\r\n            if (IsWritableStreamLocked(transform.writable)) {\r\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\r\n            }\r\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\r\n            setPromiseIsHandledToTrue(promise);\r\n            return transform.readable;\r\n        }\r\n        pipeTo(destination, rawOptions = {}) {\r\n            if (!IsReadableStream(this)) {\r\n                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\r\n            }\r\n            if (destination === undefined) {\r\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\r\n            }\r\n            if (!IsWritableStream(destination)) {\r\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\r\n            }\r\n            let options;\r\n            try {\r\n                options = convertPipeOptions(rawOptions, 'Second parameter');\r\n            }\r\n            catch (e) {\r\n                return promiseRejectedWith(e);\r\n            }\r\n            if (IsReadableStreamLocked(this)) {\r\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n            }\r\n            if (IsWritableStreamLocked(destination)) {\r\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n            }\r\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\r\n        }\r\n        /**\r\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\r\n         * new {@link ReadableStream} instances.\r\n         *\r\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\r\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\r\n         * propagated to the stream's underlying source.\r\n         *\r\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\r\n         * this could allow interference between the two branches.\r\n         */\r\n        tee() {\r\n            if (!IsReadableStream(this)) {\r\n                throw streamBrandCheckException$1('tee');\r\n            }\r\n            const branches = ReadableStreamTee(this);\r\n            return CreateArrayFromList(branches);\r\n        }\r\n        values(rawOptions = undefined) {\r\n            if (!IsReadableStream(this)) {\r\n                throw streamBrandCheckException$1('values');\r\n            }\r\n            const options = convertIteratorOptions(rawOptions, 'First parameter');\r\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\r\n        }\r\n        [SymbolAsyncIterator](options) {\r\n            // Stub implementation, overridden below\r\n            return this.values(options);\r\n        }\r\n        /**\r\n         * Creates a new ReadableStream wrapping the provided iterable or async iterable.\r\n         *\r\n         * This can be used to adapt various kinds of objects into a readable stream,\r\n         * such as an array, an async generator, or a Node.js readable stream.\r\n         */\r\n        static from(asyncIterable) {\r\n            return ReadableStreamFrom(asyncIterable);\r\n        }\r\n    }\r\n    Object.defineProperties(ReadableStream, {\r\n        from: { enumerable: true }\r\n    });\r\n    Object.defineProperties(ReadableStream.prototype, {\r\n        cancel: { enumerable: true },\r\n        getReader: { enumerable: true },\r\n        pipeThrough: { enumerable: true },\r\n        pipeTo: { enumerable: true },\r\n        tee: { enumerable: true },\r\n        values: { enumerable: true },\r\n        locked: { enumerable: true }\r\n    });\r\n    setFunctionName(ReadableStream.from, 'from');\r\n    setFunctionName(ReadableStream.prototype.cancel, 'cancel');\r\n    setFunctionName(ReadableStream.prototype.getReader, 'getReader');\r\n    setFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');\r\n    setFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');\r\n    setFunctionName(ReadableStream.prototype.tee, 'tee');\r\n    setFunctionName(ReadableStream.prototype.values, 'values');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\r\n            value: 'ReadableStream',\r\n            configurable: true\r\n        });\r\n    }\r\n    Object.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {\r\n        value: ReadableStream.prototype.values,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n    // Abstract operations for the ReadableStream.\r\n    // Throws if and only if startAlgorithm throws.\r\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\r\n        const stream = Object.create(ReadableStream.prototype);\r\n        InitializeReadableStream(stream);\r\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\r\n        return stream;\r\n    }\r\n    // Throws if and only if startAlgorithm throws.\r\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\r\n        const stream = Object.create(ReadableStream.prototype);\r\n        InitializeReadableStream(stream);\r\n        const controller = Object.create(ReadableByteStreamController.prototype);\r\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\r\n        return stream;\r\n    }\r\n    function InitializeReadableStream(stream) {\r\n        stream._state = 'readable';\r\n        stream._reader = undefined;\r\n        stream._storedError = undefined;\r\n        stream._disturbed = false;\r\n    }\r\n    function IsReadableStream(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n            return false;\r\n        }\r\n        return x instanceof ReadableStream;\r\n    }\r\n    function IsReadableStreamLocked(stream) {\r\n        if (stream._reader === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // ReadableStream API exposed for controllers.\r\n    function ReadableStreamCancel(stream, reason) {\r\n        stream._disturbed = true;\r\n        if (stream._state === 'closed') {\r\n            return promiseResolvedWith(undefined);\r\n        }\r\n        if (stream._state === 'errored') {\r\n            return promiseRejectedWith(stream._storedError);\r\n        }\r\n        ReadableStreamClose(stream);\r\n        const reader = stream._reader;\r\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\r\n            const readIntoRequests = reader._readIntoRequests;\r\n            reader._readIntoRequests = new SimpleQueue();\r\n            readIntoRequests.forEach(readIntoRequest => {\r\n                readIntoRequest._closeSteps(undefined);\r\n            });\r\n        }\r\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\r\n        return transformPromiseWith(sourceCancelPromise, noop);\r\n    }\r\n    function ReadableStreamClose(stream) {\r\n        stream._state = 'closed';\r\n        const reader = stream._reader;\r\n        if (reader === undefined) {\r\n            return;\r\n        }\r\n        defaultReaderClosedPromiseResolve(reader);\r\n        if (IsReadableStreamDefaultReader(reader)) {\r\n            const readRequests = reader._readRequests;\r\n            reader._readRequests = new SimpleQueue();\r\n            readRequests.forEach(readRequest => {\r\n                readRequest._closeSteps();\r\n            });\r\n        }\r\n    }\r\n    function ReadableStreamError(stream, e) {\r\n        stream._state = 'errored';\r\n        stream._storedError = e;\r\n        const reader = stream._reader;\r\n        if (reader === undefined) {\r\n            return;\r\n        }\r\n        defaultReaderClosedPromiseReject(reader, e);\r\n        if (IsReadableStreamDefaultReader(reader)) {\r\n            ReadableStreamDefaultReaderErrorReadRequests(reader, e);\r\n        }\r\n        else {\r\n            ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\r\n        }\r\n    }\r\n    // Helper functions for the ReadableStream.\r\n    function streamBrandCheckException$1(name) {\r\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\r\n    }\r\n\r\n    function convertQueuingStrategyInit(init, context) {\r\n        assertDictionary(init, context);\r\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\r\n        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\r\n        return {\r\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\r\n        };\r\n    }\r\n\r\n    // The size function must not have a prototype property nor be a constructor\r\n    const byteLengthSizeFunction = (chunk) => {\r\n        return chunk.byteLength;\r\n    };\r\n    setFunctionName(byteLengthSizeFunction, 'size');\r\n    /**\r\n     * A queuing strategy that counts the number of bytes in each chunk.\r\n     *\r\n     * @public\r\n     */\r\n    class ByteLengthQueuingStrategy {\r\n        constructor(options) {\r\n            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\r\n            options = convertQueuingStrategyInit(options, 'First parameter');\r\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\r\n        }\r\n        /**\r\n         * Returns the high water mark provided to the constructor.\r\n         */\r\n        get highWaterMark() {\r\n            if (!IsByteLengthQueuingStrategy(this)) {\r\n                throw byteLengthBrandCheckException('highWaterMark');\r\n            }\r\n            return this._byteLengthQueuingStrategyHighWaterMark;\r\n        }\r\n        /**\r\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\r\n         */\r\n        get size() {\r\n            if (!IsByteLengthQueuingStrategy(this)) {\r\n                throw byteLengthBrandCheckException('size');\r\n            }\r\n            return byteLengthSizeFunction;\r\n        }\r\n    }\r\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\r\n        highWaterMark: { enumerable: true },\r\n        size: { enumerable: true }\r\n    });\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\r\n            value: 'ByteLengthQueuingStrategy',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Helper functions for the ByteLengthQueuingStrategy.\r\n    function byteLengthBrandCheckException(name) {\r\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\r\n    }\r\n    function IsByteLengthQueuingStrategy(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\r\n            return false;\r\n        }\r\n        return x instanceof ByteLengthQueuingStrategy;\r\n    }\r\n\r\n    // The size function must not have a prototype property nor be a constructor\r\n    const countSizeFunction = () => {\r\n        return 1;\r\n    };\r\n    setFunctionName(countSizeFunction, 'size');\r\n    /**\r\n     * A queuing strategy that counts the number of chunks.\r\n     *\r\n     * @public\r\n     */\r\n    class CountQueuingStrategy {\r\n        constructor(options) {\r\n            assertRequiredArgument(options, 1, 'CountQueuingStrategy');\r\n            options = convertQueuingStrategyInit(options, 'First parameter');\r\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\r\n        }\r\n        /**\r\n         * Returns the high water mark provided to the constructor.\r\n         */\r\n        get highWaterMark() {\r\n            if (!IsCountQueuingStrategy(this)) {\r\n                throw countBrandCheckException('highWaterMark');\r\n            }\r\n            return this._countQueuingStrategyHighWaterMark;\r\n        }\r\n        /**\r\n         * Measures the size of `chunk` by always returning 1.\r\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\r\n         */\r\n        get size() {\r\n            if (!IsCountQueuingStrategy(this)) {\r\n                throw countBrandCheckException('size');\r\n            }\r\n            return countSizeFunction;\r\n        }\r\n    }\r\n    Object.defineProperties(CountQueuingStrategy.prototype, {\r\n        highWaterMark: { enumerable: true },\r\n        size: { enumerable: true }\r\n    });\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\r\n            value: 'CountQueuingStrategy',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Helper functions for the CountQueuingStrategy.\r\n    function countBrandCheckException(name) {\r\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\r\n    }\r\n    function IsCountQueuingStrategy(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\r\n            return false;\r\n        }\r\n        return x instanceof CountQueuingStrategy;\r\n    }\r\n\r\n    function convertTransformer(original, context) {\r\n        assertDictionary(original, context);\r\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\r\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\r\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\r\n        const start = original === null || original === void 0 ? void 0 : original.start;\r\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\r\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\r\n        return {\r\n            cancel: cancel === undefined ?\r\n                undefined :\r\n                convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\r\n            flush: flush === undefined ?\r\n                undefined :\r\n                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\r\n            readableType,\r\n            start: start === undefined ?\r\n                undefined :\r\n                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\r\n            transform: transform === undefined ?\r\n                undefined :\r\n                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\r\n            writableType\r\n        };\r\n    }\r\n    function convertTransformerFlushCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (controller) => promiseCall(fn, original, [controller]);\r\n    }\r\n    function convertTransformerStartCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (controller) => reflectCall(fn, original, [controller]);\r\n    }\r\n    function convertTransformerTransformCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\r\n    }\r\n    function convertTransformerCancelCallback(fn, original, context) {\r\n        assertFunction(fn, context);\r\n        return (reason) => promiseCall(fn, original, [reason]);\r\n    }\r\n\r\n    // Class TransformStream\r\n    /**\r\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\r\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\r\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\r\n     * made available for reading from the readable side.\r\n     *\r\n     * @public\r\n     */\r\n    class TransformStream {\r\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\r\n            if (rawTransformer === undefined) {\r\n                rawTransformer = null;\r\n            }\r\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\r\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\r\n            const transformer = convertTransformer(rawTransformer, 'First parameter');\r\n            if (transformer.readableType !== undefined) {\r\n                throw new RangeError('Invalid readableType specified');\r\n            }\r\n            if (transformer.writableType !== undefined) {\r\n                throw new RangeError('Invalid writableType specified');\r\n            }\r\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\r\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\r\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\r\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\r\n            let startPromise_resolve;\r\n            const startPromise = newPromise(resolve => {\r\n                startPromise_resolve = resolve;\r\n            });\r\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\r\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\r\n            if (transformer.start !== undefined) {\r\n                startPromise_resolve(transformer.start(this._transformStreamController));\r\n            }\r\n            else {\r\n                startPromise_resolve(undefined);\r\n            }\r\n        }\r\n        /**\r\n         * The readable side of the transform stream.\r\n         */\r\n        get readable() {\r\n            if (!IsTransformStream(this)) {\r\n                throw streamBrandCheckException('readable');\r\n            }\r\n            return this._readable;\r\n        }\r\n        /**\r\n         * The writable side of the transform stream.\r\n         */\r\n        get writable() {\r\n            if (!IsTransformStream(this)) {\r\n                throw streamBrandCheckException('writable');\r\n            }\r\n            return this._writable;\r\n        }\r\n    }\r\n    Object.defineProperties(TransformStream.prototype, {\r\n        readable: { enumerable: true },\r\n        writable: { enumerable: true }\r\n    });\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\r\n            value: 'TransformStream',\r\n            configurable: true\r\n        });\r\n    }\r\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\r\n        function startAlgorithm() {\r\n            return startPromise;\r\n        }\r\n        function writeAlgorithm(chunk) {\r\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\r\n        }\r\n        function abortAlgorithm(reason) {\r\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\r\n        }\r\n        function closeAlgorithm() {\r\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\r\n        }\r\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\r\n        function pullAlgorithm() {\r\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\r\n        }\r\n        function cancelAlgorithm(reason) {\r\n            return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\r\n        }\r\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\r\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\r\n        stream._backpressure = undefined;\r\n        stream._backpressureChangePromise = undefined;\r\n        stream._backpressureChangePromise_resolve = undefined;\r\n        TransformStreamSetBackpressure(stream, true);\r\n        stream._transformStreamController = undefined;\r\n    }\r\n    function IsTransformStream(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n            return false;\r\n        }\r\n        return x instanceof TransformStream;\r\n    }\r\n    // This is a no-op if both sides are already errored.\r\n    function TransformStreamError(stream, e) {\r\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\r\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n    }\r\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\r\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\r\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\r\n        TransformStreamUnblockWrite(stream);\r\n    }\r\n    function TransformStreamUnblockWrite(stream) {\r\n        if (stream._backpressure) {\r\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\r\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\r\n            // _backpressure is set.\r\n            TransformStreamSetBackpressure(stream, false);\r\n        }\r\n    }\r\n    function TransformStreamSetBackpressure(stream, backpressure) {\r\n        // Passes also when called during construction.\r\n        if (stream._backpressureChangePromise !== undefined) {\r\n            stream._backpressureChangePromise_resolve();\r\n        }\r\n        stream._backpressureChangePromise = newPromise(resolve => {\r\n            stream._backpressureChangePromise_resolve = resolve;\r\n        });\r\n        stream._backpressure = backpressure;\r\n    }\r\n    // Class TransformStreamDefaultController\r\n    /**\r\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\r\n     *\r\n     * @public\r\n     */\r\n    class TransformStreamDefaultController {\r\n        constructor() {\r\n            throw new TypeError('Illegal constructor');\r\n        }\r\n        /**\r\n         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\r\n         */\r\n        get desiredSize() {\r\n            if (!IsTransformStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException('desiredSize');\r\n            }\r\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\r\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n        }\r\n        enqueue(chunk = undefined) {\r\n            if (!IsTransformStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException('enqueue');\r\n            }\r\n            TransformStreamDefaultControllerEnqueue(this, chunk);\r\n        }\r\n        /**\r\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\r\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\r\n         */\r\n        error(reason = undefined) {\r\n            if (!IsTransformStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException('error');\r\n            }\r\n            TransformStreamDefaultControllerError(this, reason);\r\n        }\r\n        /**\r\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\r\n         * transformer only needs to consume a portion of the chunks written to the writable side.\r\n         */\r\n        terminate() {\r\n            if (!IsTransformStreamDefaultController(this)) {\r\n                throw defaultControllerBrandCheckException('terminate');\r\n            }\r\n            TransformStreamDefaultControllerTerminate(this);\r\n        }\r\n    }\r\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\r\n        enqueue: { enumerable: true },\r\n        error: { enumerable: true },\r\n        terminate: { enumerable: true },\r\n        desiredSize: { enumerable: true }\r\n    });\r\n    setFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');\r\n    setFunctionName(TransformStreamDefaultController.prototype.error, 'error');\r\n    setFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');\r\n    if (typeof Symbol.toStringTag === 'symbol') {\r\n        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\r\n            value: 'TransformStreamDefaultController',\r\n            configurable: true\r\n        });\r\n    }\r\n    // Transform Stream Default Controller Abstract Operations\r\n    function IsTransformStreamDefaultController(x) {\r\n        if (!typeIsObject(x)) {\r\n            return false;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n            return false;\r\n        }\r\n        return x instanceof TransformStreamDefaultController;\r\n    }\r\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {\r\n        controller._controlledTransformStream = stream;\r\n        stream._transformStreamController = controller;\r\n        controller._transformAlgorithm = transformAlgorithm;\r\n        controller._flushAlgorithm = flushAlgorithm;\r\n        controller._cancelAlgorithm = cancelAlgorithm;\r\n        controller._finishPromise = undefined;\r\n        controller._finishPromise_resolve = undefined;\r\n        controller._finishPromise_reject = undefined;\r\n    }\r\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\r\n        const controller = Object.create(TransformStreamDefaultController.prototype);\r\n        let transformAlgorithm;\r\n        let flushAlgorithm;\r\n        let cancelAlgorithm;\r\n        if (transformer.transform !== undefined) {\r\n            transformAlgorithm = chunk => transformer.transform(chunk, controller);\r\n        }\r\n        else {\r\n            transformAlgorithm = chunk => {\r\n                try {\r\n                    TransformStreamDefaultControllerEnqueue(controller, chunk);\r\n                    return promiseResolvedWith(undefined);\r\n                }\r\n                catch (transformResultE) {\r\n                    return promiseRejectedWith(transformResultE);\r\n                }\r\n            };\r\n        }\r\n        if (transformer.flush !== undefined) {\r\n            flushAlgorithm = () => transformer.flush(controller);\r\n        }\r\n        else {\r\n            flushAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        if (transformer.cancel !== undefined) {\r\n            cancelAlgorithm = reason => transformer.cancel(reason);\r\n        }\r\n        else {\r\n            cancelAlgorithm = () => promiseResolvedWith(undefined);\r\n        }\r\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\r\n    }\r\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\r\n        controller._transformAlgorithm = undefined;\r\n        controller._flushAlgorithm = undefined;\r\n        controller._cancelAlgorithm = undefined;\r\n    }\r\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\r\n        const stream = controller._controlledTransformStream;\r\n        const readableController = stream._readable._readableStreamController;\r\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\r\n            throw new TypeError('Readable side is not in a state that permits enqueue');\r\n        }\r\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\r\n        // accept TransformStreamDefaultControllerEnqueue() calls.\r\n        try {\r\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\r\n        }\r\n        catch (e) {\r\n            // This happens when readableStrategy.size() throws.\r\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n            throw stream._readable._storedError;\r\n        }\r\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\r\n        if (backpressure !== stream._backpressure) {\r\n            TransformStreamSetBackpressure(stream, true);\r\n        }\r\n    }\r\n    function TransformStreamDefaultControllerError(controller, e) {\r\n        TransformStreamError(controller._controlledTransformStream, e);\r\n    }\r\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\r\n        const transformPromise = controller._transformAlgorithm(chunk);\r\n        return transformPromiseWith(transformPromise, undefined, r => {\r\n            TransformStreamError(controller._controlledTransformStream, r);\r\n            throw r;\r\n        });\r\n    }\r\n    function TransformStreamDefaultControllerTerminate(controller) {\r\n        const stream = controller._controlledTransformStream;\r\n        const readableController = stream._readable._readableStreamController;\r\n        ReadableStreamDefaultControllerClose(readableController);\r\n        const error = new TypeError('TransformStream terminated');\r\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\r\n    }\r\n    // TransformStreamDefaultSink Algorithms\r\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\r\n        const controller = stream._transformStreamController;\r\n        if (stream._backpressure) {\r\n            const backpressureChangePromise = stream._backpressureChangePromise;\r\n            return transformPromiseWith(backpressureChangePromise, () => {\r\n                const writable = stream._writable;\r\n                const state = writable._state;\r\n                if (state === 'erroring') {\r\n                    throw writable._storedError;\r\n                }\r\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\r\n            });\r\n        }\r\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\r\n    }\r\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\r\n        const controller = stream._transformStreamController;\r\n        if (controller._finishPromise !== undefined) {\r\n            return controller._finishPromise;\r\n        }\r\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n        const readable = stream._readable;\r\n        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\r\n        // we don't run the _cancelAlgorithm again.\r\n        controller._finishPromise = newPromise((resolve, reject) => {\r\n            controller._finishPromise_resolve = resolve;\r\n            controller._finishPromise_reject = reject;\r\n        });\r\n        const cancelPromise = controller._cancelAlgorithm(reason);\r\n        TransformStreamDefaultControllerClearAlgorithms(controller);\r\n        uponPromise(cancelPromise, () => {\r\n            if (readable._state === 'errored') {\r\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\r\n            }\r\n            else {\r\n                ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\r\n                defaultControllerFinishPromiseResolve(controller);\r\n            }\r\n            return null;\r\n        }, r => {\r\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\r\n            defaultControllerFinishPromiseReject(controller, r);\r\n            return null;\r\n        });\r\n        return controller._finishPromise;\r\n    }\r\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\r\n        const controller = stream._transformStreamController;\r\n        if (controller._finishPromise !== undefined) {\r\n            return controller._finishPromise;\r\n        }\r\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n        const readable = stream._readable;\r\n        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\r\n        // we don't also run the _cancelAlgorithm.\r\n        controller._finishPromise = newPromise((resolve, reject) => {\r\n            controller._finishPromise_resolve = resolve;\r\n            controller._finishPromise_reject = reject;\r\n        });\r\n        const flushPromise = controller._flushAlgorithm();\r\n        TransformStreamDefaultControllerClearAlgorithms(controller);\r\n        uponPromise(flushPromise, () => {\r\n            if (readable._state === 'errored') {\r\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\r\n            }\r\n            else {\r\n                ReadableStreamDefaultControllerClose(readable._readableStreamController);\r\n                defaultControllerFinishPromiseResolve(controller);\r\n            }\r\n            return null;\r\n        }, r => {\r\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\r\n            defaultControllerFinishPromiseReject(controller, r);\r\n            return null;\r\n        });\r\n        return controller._finishPromise;\r\n    }\r\n    // TransformStreamDefaultSource Algorithms\r\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\r\n        // Invariant. Enforced by the promises returned by start() and pull().\r\n        TransformStreamSetBackpressure(stream, false);\r\n        // Prevent the next pull() call until there is backpressure.\r\n        return stream._backpressureChangePromise;\r\n    }\r\n    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {\r\n        const controller = stream._transformStreamController;\r\n        if (controller._finishPromise !== undefined) {\r\n            return controller._finishPromise;\r\n        }\r\n        // stream._writable cannot change after construction, so caching it across a call to user code is safe.\r\n        const writable = stream._writable;\r\n        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\r\n        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\r\n        // _flushAlgorithm.\r\n        controller._finishPromise = newPromise((resolve, reject) => {\r\n            controller._finishPromise_resolve = resolve;\r\n            controller._finishPromise_reject = reject;\r\n        });\r\n        const cancelPromise = controller._cancelAlgorithm(reason);\r\n        TransformStreamDefaultControllerClearAlgorithms(controller);\r\n        uponPromise(cancelPromise, () => {\r\n            if (writable._state === 'errored') {\r\n                defaultControllerFinishPromiseReject(controller, writable._storedError);\r\n            }\r\n            else {\r\n                WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\r\n                TransformStreamUnblockWrite(stream);\r\n                defaultControllerFinishPromiseResolve(controller);\r\n            }\r\n            return null;\r\n        }, r => {\r\n            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\r\n            TransformStreamUnblockWrite(stream);\r\n            defaultControllerFinishPromiseReject(controller, r);\r\n            return null;\r\n        });\r\n        return controller._finishPromise;\r\n    }\r\n    // Helper functions for the TransformStreamDefaultController.\r\n    function defaultControllerBrandCheckException(name) {\r\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\r\n    }\r\n    function defaultControllerFinishPromiseResolve(controller) {\r\n        if (controller._finishPromise_resolve === undefined) {\r\n            return;\r\n        }\r\n        controller._finishPromise_resolve();\r\n        controller._finishPromise_resolve = undefined;\r\n        controller._finishPromise_reject = undefined;\r\n    }\r\n    function defaultControllerFinishPromiseReject(controller, reason) {\r\n        if (controller._finishPromise_reject === undefined) {\r\n            return;\r\n        }\r\n        setPromiseIsHandledToTrue(controller._finishPromise);\r\n        controller._finishPromise_reject(reason);\r\n        controller._finishPromise_resolve = undefined;\r\n        controller._finishPromise_reject = undefined;\r\n    }\r\n    // Helper functions for the TransformStream.\r\n    function streamBrandCheckException(name) {\r\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\r\n    }\r\n\r\n    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\r\n    exports.CountQueuingStrategy = CountQueuingStrategy;\r\n    exports.ReadableByteStreamController = ReadableByteStreamController;\r\n    exports.ReadableStream = ReadableStream;\r\n    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\r\n    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\r\n    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;\r\n    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\r\n    exports.TransformStream = TransformStream;\r\n    exports.TransformStreamDefaultController = TransformStreamDefaultController;\r\n    exports.WritableStream = WritableStream;\r\n    exports.WritableStreamDefaultController = WritableStreamDefaultController;\r\n    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\r\n\r\n}));\r\n//# sourceMappingURL=ponyfill.es2018.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUNtSDtBQUN2SCxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVSxrQkFBa0IsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPLGtCQUFrQixRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsbUNBQW1DLFlBQVksS0FBSyxXQUFXO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9EQUFvRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGLG9EQUFvRCw4QkFBOEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EseUJBQXlCLGlEQUFpRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsZ0JBQWdCLGtCQUFrQjtBQUNsQyx1QkFBdUIsa0JBQWtCO0FBQ3pDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDJCQUEyQjtBQUN0RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEJBQThCO0FBQ25FLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsOEJBQThCLGtCQUFrQjtBQUNoRCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLG1CQUFtQixrQkFBa0I7QUFDckMsaUJBQWlCLGtCQUFrQjtBQUNuQyx1QkFBdUIsa0JBQWtCO0FBQ3pDLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0EsbUNBQW1DLFNBQVMsR0FBRyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvREFBb0Q7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRix1REFBdUQsMEJBQTBCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBOEM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLGdCQUFnQixrQkFBa0I7QUFDbEMsdUJBQXVCLGtCQUFrQjtBQUN6QyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxNQUFNO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFNBQVM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEY7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLGlCQUFpQixrQkFBa0I7QUFDbkMscUJBQXFCLGtCQUFrQjtBQUN2QyxrQkFBa0I7QUFDbEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrREFBa0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0Q0FBNEM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EscURBQXFELG1EQUFtRDtBQUN4Ryw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkMsaUJBQWlCLGtCQUFrQjtBQUNuQyx1QkFBdUIsa0JBQWtCO0FBQ3pDLGlCQUFpQixrQkFBa0I7QUFDbkMsa0JBQWtCLGtCQUFrQjtBQUNwQyx1QkFBdUIsa0JBQWtCO0FBQ3pDLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QyxrQkFBa0Isa0JBQWtCO0FBQ3BDLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxNQUFNO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlEQUFpRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLGlCQUFpQixrQkFBa0I7QUFDbkMsdUJBQXVCO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsU0FBUztBQUMzRjtBQUNBO0FBQ0EsMkVBQTJFLFNBQVM7QUFDcEY7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQSx5RUFBeUUsU0FBUztBQUNsRixzRkFBc0YsU0FBUztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBLG1DQUFtQyxTQUFTLEdBQUcsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDJDQUEyQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLHFCQUFxQixrQkFBa0I7QUFDdkMsdUJBQXVCLGtCQUFrQjtBQUN6QyxrQkFBa0Isa0JBQWtCO0FBQ3BDLGVBQWUsa0JBQWtCO0FBQ2pDLGtCQUFrQixrQkFBa0I7QUFDcEMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0MsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBLDRFQUE0RSxTQUFTO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHVDQUF1QztBQUNuRywwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEIsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLG9CQUFvQjtBQUNwQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQixLQUFLLHNCQUFzQixtQkFBbUIsc0JBQXNCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsaUJBQWlCLGtCQUFrQjtBQUNuQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanM/ZDFkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogd2ViLXN0cmVhbXMtcG9seWZpbGwgdjMuMy4zXHJcbiAqIENvcHlyaWdodCAyMDI0IE1hdHRpYXMgQnVlbGVucywgRGl3YW5rIFNpbmdoIFRvbWVyIGFuZCBvdGhlciBjb250cmlidXRvcnMuXHJcbiAqIFRoaXMgY29kZSBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcclxuICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcclxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxyXG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuV2ViU3RyZWFtc1BvbHlmaWxsID0ge30pKTtcclxufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiBub29wKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuICAgIGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiA9IG5vb3A7XHJcbiAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcclxuICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xyXG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVqZWN0ID0gUHJvbWlzZS5yZWplY3QuYmluZChvcmlnaW5hbFByb21pc2UpO1xyXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhLW5ldy1wcm9taXNlXHJcbiAgICBmdW5jdGlvbiBuZXdQcm9taXNlKGV4ZWN1dG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBvcmlnaW5hbFByb21pc2UoZXhlY3V0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhLXByb21pc2UtcmVzb2x2ZWQtd2l0aFxyXG4gICAgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKHJlc29sdmUgPT4gcmVzb2x2ZSh2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhLXByb21pc2UtcmVqZWN0ZWQtd2l0aFxyXG4gICAgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFzb24pIHtcclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVqZWN0KHJlYXNvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICAvLyBUaGVyZSBkb2Vzbid0IGFwcGVhciB0byBiZSBhbnkgd2F5IHRvIGNvcnJlY3RseSBlbXVsYXRlIHRoZSBiZWhhdmlvdXIgZnJvbSBKYXZhU2NyaXB0LCBzbyB0aGlzIGlzIGp1c3QgYW5cclxuICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxyXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgfVxyXG4gICAgLy8gQmx1ZWJpcmQgbG9ncyBhIHdhcm5pbmcgd2hlbiBhIHByb21pc2UgaXMgY3JlYXRlZCB3aXRoaW4gYSBmdWxmaWxsbWVudCBoYW5kbGVyLCBidXQgdGhlbiBpc24ndCByZXR1cm5lZFxyXG4gICAgLy8gZnJvbSB0aGF0IGhhbmRsZXIuIFRvIHByZXZlbnQgdGhpcywgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB2b2lkIGZyb20gYWxsIGhhbmRsZXJzLlxyXG4gICAgLy8gaHR0cDovL2JsdWViaXJkanMuY29tL2RvY3Mvd2FybmluZy1leHBsYW5hdGlvbnMuaHRtbCN3YXJuaW5nLWEtcHJvbWlzZS13YXMtY3JlYXRlZC1pbi1hLWhhbmRsZXItYnV0LXdhcy1ub3QtcmV0dXJuZWQtZnJvbS1pdFxyXG4gICAgZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4oUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIG9uRnVsZmlsbGVkKSB7XHJcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlLCBvblJlamVjdGVkKSB7XHJcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSkge1xyXG4gICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XHJcbiAgICB9XHJcbiAgICBsZXQgX3F1ZXVlTWljcm90YXNrID0gY2FsbGJhY2sgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzayA9IGNiID0+IFBlcmZvcm1Qcm9taXNlVGhlbihyZXNvbHZlZFByb21pc2UsIGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9xdWV1ZU1pY3JvdGFzayhjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gcmVmbGVjdENhbGwoRiwgViwgYXJncykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoRiwgViwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbChGLCBWLCBhcmdzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgocmVmbGVjdENhbGwoRiwgViwgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPcmlnaW5hbCBmcm9tIENocm9taXVtXHJcbiAgICAvLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMGFlZTQ0MzRhNGRiYTQyYTQyYWJhZWE5YmZiYzBjZDE5NmE2M2JjMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL3N0cmVhbXMvU2ltcGxlUXVldWUuanNcclxuICAgIGNvbnN0IFFVRVVFX01BWF9BUlJBWV9TSVpFID0gMTYzODQ7XHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXHJcbiAgICAgKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxyXG4gICAgICovXHJcbiAgICBjbGFzcyBTaW1wbGVRdWV1ZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgICAgICAvLyBfZnJvbnQgYW5kIF9iYWNrIGFyZSBhbHdheXMgZGVmaW5lZC5cclxuICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XHJcbiAgICAgICAgICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXHJcbiAgICAgICAgICAgIC8vIEl0IGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgZnJvbnQgZWxlbWVudCBvZiB0aGUgYXJyYXkgaW5zaWRlIHRoZVxyXG4gICAgICAgICAgICAvLyBmcm9udC1tb3N0IG5vZGUuIEl0IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2UgWzAsIFFVRVVFX01BWF9BUlJBWV9TSVpFKS5cclxuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBub2RlLCBzaXplID09PSBlbGVtZW50cy5sZW5ndGggLSBjdXJzb3IuXHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yIGV4Y2VwdGlvbiBzYWZldHksIHRoaXMgbWV0aG9kIGlzIHN0cnVjdHVyZWQgaW4gb3JkZXI6XHJcbiAgICAgICAgLy8gMS4gUmVhZCBzdGF0ZVxyXG4gICAgICAgIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcclxuICAgICAgICAvLyAzLiBQZXJmb3JtIHN0YXRlIG11dGF0aW9uc1xyXG4gICAgICAgIHB1c2goZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRCYWNrID0gdGhpcy5fYmFjaztcclxuICAgICAgICAgICAgbGV0IG5ld0JhY2sgPSBvbGRCYWNrO1xyXG4gICAgICAgICAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcclxuICAgICAgICAgICAgICAgIG5ld0JhY2sgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB1c2goKSBpcyB0aGUgbXV0YXRpb24gbW9zdCBsaWtlbHkgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBpdFxyXG4gICAgICAgICAgICAvLyBnb2VzIGZpcnN0LlxyXG4gICAgICAgICAgICBvbGRCYWNrLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAobmV3QmFjayAhPT0gb2xkQmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XHJcbiAgICAgICAgICAgICAgICBvbGRCYWNrLl9uZXh0ID0gbmV3QmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK3RoaXMuX3NpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxyXG4gICAgICAgIC8vIGV4Y2VwdGlvbiBzYWZldHkuXHJcbiAgICAgICAgc2hpZnQoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxyXG4gICAgICAgICAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xyXG4gICAgICAgICAgICBsZXQgbmV3RnJvbnQgPSBvbGRGcm9udDtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ3Vyc29yID0gdGhpcy5fY3Vyc29yO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tvbGRDdXJzb3JdO1xyXG4gICAgICAgICAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xyXG4gICAgICAgICAgICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dDtcclxuICAgICAgICAgICAgICAgIG5ld0N1cnNvciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm8gbXV0YXRpb25zIGJlZm9yZSB0aGlzIHBvaW50LlxyXG4gICAgICAgICAgICAtLXRoaXMuX3NpemU7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcclxuICAgICAgICAgICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSBuZXdGcm9udDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQZXJtaXQgc2hpZnRlZCBlbGVtZW50IHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxyXG4gICAgICAgICAgICBlbGVtZW50c1tvbGRDdXJzb3JdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHRyaWNreSB0aGluZyBhYm91dCBmb3JFYWNoKCkgaXMgdGhhdCBpdCBjYW4gYmUgY2FsbGVkXHJcbiAgICAgICAgLy8gcmUtZW50cmFudGx5LiBUaGUgcXVldWUgbWF5IGJlIG11dGF0ZWQgaW5zaWRlIHRoZSBjYWxsYmFjay4gSXQgaXMgZWFzeSB0b1xyXG4gICAgICAgIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcclxuICAgICAgICAvLyBvZiB0aGUgcXVldWUgaXMgY2hlY2tlZCBmb3Igb24gZXZlcnkgaXRlcmF0aW9uLiBJZiBzaGlmdCgpIGlzIGNhbGxlZFxyXG4gICAgICAgIC8vIHJlcGVhdGVkbHkgd2l0aGluIHRoZSBjYWxsYmFjayB0aGVuIHRoZSBuZXh0IGl0ZXJhdGlvbiBtYXkgcmV0dXJuIGFuXHJcbiAgICAgICAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcclxuICAgICAgICAvLyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgdW50aWwgd2UgZWl0aGVyIFwiY2F0Y2ggdXBcIiB3aXRoIGVsZW1lbnRzIHRoYXQgc3RpbGxcclxuICAgICAgICAvLyBleGlzdCBvciByZWFjaCB0aGUgYmFjayBvZiB0aGUgcXVldWUuXHJcbiAgICAgICAgZm9yRWFjaChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMuX2N1cnNvcjtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9mcm9udDtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHdoaWxlIChpICE9PSBlbGVtZW50cy5sZW5ndGggfHwgbm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxyXG4gICAgICAgIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cclxuICAgICAgICBwZWVrKCkgeyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSB0aGlzLl9mcm9udDtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbnQuX2VsZW1lbnRzW2N1cnNvcl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEFib3J0U3RlcHMgPSBTeW1ib2woJ1tbQWJvcnRTdGVwc11dJyk7XHJcbiAgICBjb25zdCBFcnJvclN0ZXBzID0gU3ltYm9sKCdbW0Vycm9yU3RlcHNdXScpO1xyXG4gICAgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2woJ1tbQ2FuY2VsU3RlcHNdXScpO1xyXG4gICAgY29uc3QgUHVsbFN0ZXBzID0gU3ltYm9sKCdbW1B1bGxTdGVwc11dJyk7XHJcbiAgICBjb25zdCBSZWxlYXNlU3RlcHMgPSBTeW1ib2woJ1tbUmVsZWFzZVN0ZXBzXV0nKTtcclxuXHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHJlYWRlciwgc3RyZWFtKSB7XHJcbiAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXHJcbiAgICAvLyBjaGVjay5cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcclxuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1JlbGVhc2VTdGVwc10oKTtcclxuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgcmVhZGVycy5cclxuICAgIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyJyk7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcikge1xyXG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XHJcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpIHtcclxuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcclxuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocmVhZGVyLl9jbG9zZWRQcm9taXNlKTtcclxuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKSB7XHJcbiAgICAgICAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlI1BvbHlmaWxsXHJcbiAgICBjb25zdCBOdW1iZXJJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvdHJ1bmMjUG9seWZpbGxcclxuICAgIGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwodikgOiBNYXRoLmZsb29yKHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXHJcbiAgICBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcclxuICAgIGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHgsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHggIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmdW5jdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtb2JqZWN0XHJcbiAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghaXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoeCwgcG9zaXRpb24sIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAke3Bvc2l0aW9ufSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRGaWVsZCh4LCBmaWVsZCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeCkge1xyXG4gICAgICAgIHJldHVybiB4ID09PSAwID8gMCA6IHg7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlZ2VyUGFydCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xyXG4gICAgfVxyXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVuc2lnbmVkLWxvbmctbG9uZ1xyXG4gICAgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgICAgIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB4ID0gY2Vuc29yTmVnYXRpdmVaZXJvKHgpO1xyXG4gICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUoeCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggPSBpbnRlZ2VyUGFydCh4KTtcclxuICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpIHx8IHggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gVXNlIEJpZ0ludCBpZiBzdXBwb3J0ZWQ/XHJcbiAgICAgICAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xyXG4gICAgICAgIC8vIHhCaWdJbnQgPSBCaWdJbnQuYXNVaW50Tig2NCwgeEJpZ0ludCk7XHJcbiAgICAgICAgLy8gcmV0dXJuIE51bWJlcih4QmlnSW50KTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVN0cmVhbSh4LCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cclxuICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcclxuICAgIH1cclxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCkge1xyXG4gICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XHJcbiAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xyXG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGRlZmF1bHQgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xyXG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicpO1xyXG4gICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsXHJcbiAgICAgICAgICogb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvciB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBjbG9zZWQoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNhbmNlbChyZWFzb24gPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUsIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlYWQoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XHJcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxyXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSxcclxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXHJcbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxyXG4gICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XHJcbiAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xyXG4gICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWxlYXNlTG9jaygpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlbGVhc2UodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWFkLCAncmVhZCcpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXHJcbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XHJcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcclxuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWxlYXNlKHJlYWRlcikge1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcclxuICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignUmVhZGVyIHdhcyByZWxlYXNlZCcpO1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlciwgZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJFcnJvclJlYWRSZXF1ZXN0cyhyZWFkZXIsIGUpIHtcclxuICAgICAgICBjb25zdCByZWFkUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cztcclxuICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgICAgIHJlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcclxuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xyXG4gICAgY29uc3QgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24qICgpIHsgfSkucHJvdG90eXBlKTtcclxuXHJcbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XHJcbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6XHJcbiAgICAgICAgICAgICAgICBuZXh0U3RlcHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4odmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0dXJuU3RlcHMgPSAoKSA9PiB0aGlzLl9yZXR1cm5TdGVwcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm5TdGVwcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbmV4dFN0ZXBzKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XHJcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBieSBvbmUgbWljcm90YXNrLCBvdGhlcndpc2Ugd2Ugc3RvcCBwdWxsaW5nIHRvbyBlYXJseSB3aGljaCBicmVha3MgYSB0ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIElzIHRoaXMgYSBidWcgaW4gdGhlIHNwZWNpZmljYXRpb24sIG9yIGluIHRoZSB0ZXN0P1xyXG4gICAgICAgICAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzaygoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JldHVyblN0ZXBzKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwubmV4dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmV0dXJuKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxyXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0sIHByZXZlbnRDYW5jZWwpIHtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XHJcbiAgICAgICAgY29uc3QgaW1wbCA9IG5ldyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsKHJlYWRlciwgcHJldmVudENhbmNlbCk7XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XHJcbiAgICAgICAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2FzeW5jSXRlcmF0b3JJbXBsJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXHJcbiAgICAgICAgICAgIHJldHVybiB4Ll9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cclxuICAgIGZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOI1BvbHlmaWxsXHJcbiAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcclxuICAgICAgICByZXR1cm4geCAhPT0geDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0KGVsZW1lbnRzKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXHJcbiAgICAgICAgLy8gRG8gYSBzbGljZSB0aG91Z2gganVzdCBpbiBjYXNlIHdlIGhhcHBlbiB0byBkZXBlbmQgb24gdGhlIHVuaXF1ZS1uZXNzLlxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gQ29weURhdGFCbG9ja0J5dGVzKGRlc3QsIGRlc3RPZmZzZXQsIHNyYywgc3JjT2Zmc2V0LCBuKSB7XHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBsZXQgVHJhbnNmZXJBcnJheUJ1ZmZlciA9IChPKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPLnRyYW5zZmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyLnRyYW5zZmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgVHJhbnNmZXJBcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBzdHJ1Y3R1cmVkQ2xvbmUoYnVmZmVyLCB7IHRyYW5zZmVyOiBbYnVmZmVyXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcclxuICAgICAgICAgICAgVHJhbnNmZXJBcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBidWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pO1xyXG4gICAgfTtcclxuICAgIGxldCBJc0RldGFjaGVkQnVmZmVyID0gKE8pID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIE8uZGV0YWNoZWQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBJc0RldGFjaGVkQnVmZmVyID0gYnVmZmVyID0+IGJ1ZmZlci5kZXRhY2hlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcclxuICAgICAgICAgICAgSXNEZXRhY2hlZEJ1ZmZlciA9IGJ1ZmZlciA9PiBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIElzRGV0YWNoZWRCdWZmZXIoTyk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICAvLyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTEwXHJcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2VcclxuICAgICAgICBpZiAoYnVmZmVyLnNsaWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xyXG4gICAgICAgIGNvbnN0IHNsaWNlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XHJcbiAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHNsaWNlLCAwLCBidWZmZXIsIGJlZ2luLCBsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBzbGljZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEdldE1ldGhvZChyZWNlaXZlciwgcHJvcCkge1xyXG4gICAgICAgIGNvbnN0IGZ1bmMgPSByZWNlaXZlcltwcm9wXTtcclxuICAgICAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkIHx8IGZ1bmMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7U3RyaW5nKHByb3ApfSBpcyBub3QgYSBmdW5jdGlvbmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuYztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvcihzeW5jSXRlcmF0b3JSZWNvcmQpIHtcclxuICAgICAgICAvLyBJbnN0ZWFkIG9mIHJlLWltcGxlbWVudGluZyBDcmVhdGVBc3luY0Zyb21TeW5jSXRlcmF0b3IgYW5kICVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlLFxyXG4gICAgICAgIC8vIHdlIHVzZSB5aWVsZCogaW5zaWRlIGFuIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiB0byBhY2hpZXZlIHRoZSBzYW1lIHJlc3VsdC5cclxuICAgICAgICAvLyBXcmFwIHRoZSBzeW5jIGl0ZXJhdG9yIGluc2lkZSBhIHN5bmMgaXRlcmFibGUsIHNvIHdlIGNhbiB1c2UgaXQgd2l0aCB5aWVsZCouXHJcbiAgICAgICAgY29uc3Qgc3luY0l0ZXJhYmxlID0ge1xyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gc3luY0l0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDcmVhdGUgYW4gYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFuZCBpbW1lZGlhdGVseSBpbnZva2UgaXQuXHJcbiAgICAgICAgY29uc3QgYXN5bmNJdGVyYXRvciA9IChhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHN5bmNJdGVyYWJsZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIC8vIFJldHVybiBhcyBhbiBhc3luYyBpdGVyYXRvciByZWNvcmQuXHJcbiAgICAgICAgY29uc3QgbmV4dE1ldGhvZCA9IGFzeW5jSXRlcmF0b3IubmV4dDtcclxuICAgICAgICByZXR1cm4geyBpdGVyYXRvcjogYXN5bmNJdGVyYXRvciwgbmV4dE1ldGhvZCwgZG9uZTogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIC8vIEFsaWducyB3aXRoIGNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcclxuICAgIGNvbnN0IFN5bWJvbEFzeW5jSXRlcmF0b3IgPSAoX2MgPSAoX2EgPSBTeW1ib2wuYXN5bmNJdGVyYXRvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gU3ltYm9sLmZvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoU3ltYm9sLCAnU3ltYm9sLmFzeW5jSXRlcmF0b3InKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ0BAYXN5bmNJdGVyYXRvcic7XHJcbiAgICBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmosIGhpbnQgPSAnc3luYycsIG1ldGhvZCkge1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoaGludCA9PT0gJ2FzeW5jJykge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgU3ltYm9sQXN5bmNJdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW5jTWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgU3ltYm9sLml0ZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW5jSXRlcmF0b3JSZWNvcmQgPSBHZXRJdGVyYXRvcihvYmosICdzeW5jJywgc3luY01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvcihzeW5jSXRlcmF0b3JSZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgU3ltYm9sLml0ZXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSByZWZsZWN0Q2FsbChtZXRob2QsIG9iaiwgW10pO1xyXG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KGl0ZXJhdG9yKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgaXRlcmF0b3IgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0TWV0aG9kID0gaXRlcmF0b3IubmV4dDtcclxuICAgICAgICByZXR1cm4geyBpdGVyYXRvciwgbmV4dE1ldGhvZCwgZG9uZTogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yTmV4dChpdGVyYXRvclJlY29yZCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmxlY3RDYWxsKGl0ZXJhdG9yUmVjb3JkLm5leHRNZXRob2QsIGl0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yLCBbXSk7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QocmVzdWx0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ29tcGxldGUoaXRlclJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKGl0ZXJSZXN1bHQuZG9uZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJc05vbk5lZ2F0aXZlTnVtYmVyKHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE51bWJlcklzTmFOKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBDbG9uZUFzVWludDhBcnJheShPKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIERlcXVldWVWYWx1ZShjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgLT0gcGFpci5zaXplO1xyXG4gICAgICAgIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xyXG4gICAgICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhaXIudmFsdWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250YWluZXIsIHZhbHVlLCBzaXplKSB7XHJcbiAgICAgICAgaWYgKCFJc05vbk5lZ2F0aXZlTnVtYmVyKHNpemUpIHx8IHNpemUgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRhaW5lci5fcXVldWUucHVzaCh7IHZhbHVlLCBzaXplIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgKz0gc2l6ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnBlZWsoKTtcclxuICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlc2V0UXVldWUoY29udGFpbmVyKSB7XHJcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXdDb25zdHJ1Y3RvcihjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGN0b3IgPT09IERhdGFWaWV3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRhVmlldyh2aWV3KSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRGF0YVZpZXdDb25zdHJ1Y3Rvcih2aWV3LmNvbnN0cnVjdG9yKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5QnVmZmVyVmlld0VsZW1lbnRTaXplKGN0b3IpIHtcclxuICAgICAgICBpZiAoaXNEYXRhVmlld0NvbnN0cnVjdG9yKGN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcHVsbC1pbnRvIHJlcXVlc3QgaW4gYSB7QGxpbmsgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2aWV3IGZvciB3cml0aW5nIGluIHRvLCBvciBgbnVsbGAgaWYgdGhlIEJZT0IgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJlc3BvbmRlZCB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgdmlldygpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNwb25kKGJ5dGVzV3JpdHRlbikge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChieXRlc1dyaXR0ZW4sIDEsICdyZXNwb25kJyk7XHJcbiAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodGhpcy5fdmlldy5idWZmZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgQllPQiByZXF1ZXN0J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xyXG4gICAgICAgIHJlc3BvbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLnJlc3BvbmQsICdyZXNwb25kJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3LCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XHJcbiAgICBpZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBieXRlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEJZT0IgcHVsbCByZXF1ZXN0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXNuJ3Qgb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBieW9iUmVxdWVzdCgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcclxuICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxyXG4gICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnF1ZXVlKGNodW5rKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGNodW5rJ3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJlYW0gaXMgY2xvc2VkIG9yIGRyYWluaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvcnMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgW0NhbmNlbFN0ZXBzXShyZWFzb24pIHtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcclxuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFJlYWRSZXF1ZXN0RnJvbVF1ZXVlKHRoaXMsIHJlYWRSZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XHJcbiAgICAgICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoYnVmZmVyRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGJ1ZmZlckUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1GaWxsOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogVWludDhBcnJheSxcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIFtSZWxlYXNlU3RlcHNdKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFB1bGxJbnRvID0gdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFB1bGxJbnRvLnJlYWRlclR5cGUgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2goZmlyc3RQdWxsSW50byk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgYnlvYlJlcXVlc3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxyXG4gICAgfSk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UsICdjbG9zZScpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUsICdlbnF1ZXVlJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsICdlcnJvcicpO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcclxuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cclxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcclxuICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xyXG4gICAgICAgIC8vIFRPRE86IFRlc3QgY29udHJvbGxlciBhcmd1bWVudFxyXG4gICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xyXG4gICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LCBlID0+IHtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XHJcbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xyXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcclxuICAgICAgICBpZiAocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlLnB1c2goeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSk7XHJcbiAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2xvbmVkQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGxldCBjbG9uZWRDaHVuaztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjbG9uZWRDaHVuayA9IEFycmF5QnVmZmVyU2xpY2UoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChjbG9uZUUpIHtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNsb25lRSk7XHJcbiAgICAgICAgICAgIHRocm93IGNsb25lRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgY2xvbmVkQ2h1bmssIDAsIGJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVEZXRhY2hlZFB1bGxJbnRvVG9RdWV1ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkID4gMCkge1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IuYnVmZmVyLCBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCwgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xyXG4gICAgICAgIGNvbnN0IG1heEJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgbWF4Qnl0ZXNUb0NvcHk7XHJcbiAgICAgICAgbGV0IHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcclxuICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCByZW1haW5kZXJCeXRlcyA9IG1heEJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xyXG4gICAgICAgIGNvbnN0IG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gcmVtYWluZGVyQnl0ZXM7XHJcbiAgICAgICAgLy8gQSBkZXNjcmlwdG9yIGZvciBhIHJlYWQoKSByZXF1ZXN0IHRoYXQgaXMgbm90IHlldCBmaWxsZWQgdXAgdG8gaXRzIG1pbmltdW0gbGVuZ3RoIHdpbGwgc3RheSBhdCB0aGUgaGVhZFxyXG4gICAgICAgIC8vIG9mIHRoZSBxdWV1ZSwgc28gdGhlIHVuZGVybHlpbmcgc291cmNlIGNhbiBrZWVwIGZpbGxpbmcgaXQuXHJcbiAgICAgICAgaWYgKG1heEFsaWduZWRCeXRlcyA+PSBwdWxsSW50b0Rlc2NyaXB0b3IubWluaW11bUZpbGwpIHtcclxuICAgICAgICAgICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcclxuICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xyXG4gICAgICAgIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgZGVzdFN0YXJ0ID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XHJcbiAgICAgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBkZXN0U3RhcnQsIGhlYWRPZlF1ZXVlLmJ1ZmZlciwgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCwgYnl0ZXNUb0NvcHkpO1xyXG4gICAgICAgICAgICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xyXG4gICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBieXRlc1RvQ29weTtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVhZHk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgc2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKSB7XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwICYmIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcikge1xyXG4gICAgICAgIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWUoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3JlYWRlcjtcclxuICAgICAgICB3aGlsZSAocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWUoY29udHJvbGxlciwgcmVhZFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhjb250cm9sbGVyLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XHJcbiAgICAgICAgY29uc3QgY3RvciA9IHZpZXcuY29uc3RydWN0b3I7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZShjdG9yKTtcclxuICAgICAgICBjb25zdCB7IGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IHZpZXc7XHJcbiAgICAgICAgY29uc3QgbWluaW11bUZpbGwgPSBtaW4gKiBlbGVtZW50U2l6ZTtcclxuICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xyXG4gICAgICAgICAgICBidWZmZXIsXHJcbiAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBieXRlT2Zmc2V0LFxyXG4gICAgICAgICAgICBieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcclxuICAgICAgICAgICAgbWluaW11bUZpbGwsXHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLFxyXG4gICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXHJcbiAgICAgICAgICAgIHJlYWRlclR5cGU6ICdieW9iJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgLy8gTm8gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoKSBjYWxsIHNpbmNlOlxyXG4gICAgICAgICAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXHJcbiAgICAgICAgICAgIC8vIC0gVGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIG5vdGlmaWVkIG9mIHRoYXQgdGhlcmUncyBhdCBsZWFzdCAxIHBlbmRpbmcgcmVhZCh2aWV3KVxyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcclxuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGVtcHR5Vmlldyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhmaWxsZWRWaWV3KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XHJcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XHJcbiAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcikge1xyXG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcclxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XHJcbiAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVEZXRhY2hlZFB1bGxJbnRvVG9RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IubWluaW11bUZpbGwpIHtcclxuICAgICAgICAgICAgLy8gQSBkZXNjcmlwdG9yIGZvciBhIHJlYWQoKSByZXF1ZXN0IHRoYXQgaXMgbm90IHlldCBmaWxsZWQgdXAgdG8gaXRzIG1pbmltdW0gbGVuZ3RoIHdpbGwgc3RheSBhdCB0aGUgaGVhZFxyXG4gICAgICAgICAgICAvLyBvZiB0aGUgcXVldWUsIHNvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBjYW4ga2VlcCBmaWxsaW5nIGl0LlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcclxuICAgICAgICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xyXG4gICAgICAgIGlmIChyZW1haW5kZXJTaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZW5kIC0gcmVtYWluZGVyU2l6ZSwgcmVtYWluZGVyU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcclxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcclxuICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcclxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCk7XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCAlIGZpcnN0UGVuZGluZ1B1bGxJbnRvLmVsZW1lbnRTaXplICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xyXG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcclxuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBjaHVuaztcclxuICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rXFwncyBidWZmZXIgaXMgZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBlbnF1ZXVlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZEJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoYnVmZmVyKTtcclxuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBCWU9CIHJlcXVlc3RcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGZpbGxlZCB3aXRoIGFuIGVucXVldWVkIGNodW5rJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8ucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlKGNvbnRyb2xsZXIsIGZpcnN0UGVuZGluZ1B1bGxJbnRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpIHtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NSZWFkUmVxdWVzdHNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVycmVkVmlldyA9IG5ldyBVaW50OEFycmF5KHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogSWRlYWxseSBpbiB0aGlzIGJyYW5jaCBkZXRhY2hpbmcgc2hvdWxkIGhhcHBlbiBvbmx5IGlmIHRoZSBidWZmZXIgaXMgbm90IGNvbnN1bWVkIGZ1bGx5LlxyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xyXG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcclxuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XHJcbiAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxSZWFkUmVxdWVzdEZyb21RdWV1ZShjb250cm9sbGVyLCByZWFkUmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gY29udHJvbGxlci5fcXVldWUuc2hpZnQoKTtcclxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBlbnRyeS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKHZpZXcpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciwgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQsIGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcclxuICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KGJ5b2JSZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBieW9iUmVxdWVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbikge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XHJcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyLCB2aWV3KSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2aWV3XFwncyBsZW5ndGggbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGJ1ZmZlciBvZiB2aWV3IGhhcyBkaWZmZXJlbnQgY2FwYWNpdHkgdGhhbiBieW9iUmVxdWVzdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xyXG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlld0J5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKSB7XHJcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSA9IHN0cmVhbTtcclxuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcclxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxyXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcclxuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XHJcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XHJcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcclxuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XHJcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcclxuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sIHIgPT4ge1xyXG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nQnl0ZVNvdXJjZSwgaGlnaFdhdGVyTWFyaykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcclxuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG07XHJcbiAgICAgICAgbGV0IHB1bGxBbGdvcml0aG07XHJcbiAgICAgICAgbGV0IGNhbmNlbEFsZ29yaXRobTtcclxuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwoY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbChyZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XHJcbiAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdXRvQWxsb2NhdGVDaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcclxuICAgICAgICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgcmVxdWVzdC5fdmlldyA9IHZpZXc7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5cclxuICAgIGZ1bmN0aW9uIGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxyXG4gICAgZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcmApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkZXJPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb2RlOiBtb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ21vZGUnIHRoYXRgKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGNvbnRleHQpIHtcclxuICAgICAgICBtb2RlID0gYCR7bW9kZX1gO1xyXG4gICAgICAgIGlmIChtb2RlICE9PSAnYnlvYicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRCeW9iUmVhZE9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UobWluLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtaW4nIHRoYXRgKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxyXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xyXG4gICAgfVxyXG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpIHtcclxuICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xyXG4gICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xyXG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIEJZT0IgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xyXG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xyXG4gICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxyXG4gICAgICAgICAqIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWQodmlldywgcmF3T3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgdmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXdcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0QnlvYlJlYWRPcHRpb25zKHJhd09wdGlvbnMsICdvcHRpb25zJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IG9wdGlvbnMubWluO1xyXG4gICAgICAgICAgICBpZiAobWluID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNEYXRhVmlldyh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA+IHZpZXcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMubWluIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHZpZXdcXCdzIGxlbmd0aCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtaW4gPiB2aWV3LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3XFwncyBieXRlTGVuZ3RoJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XHJcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcclxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcclxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXHJcbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxyXG4gICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XHJcbiAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xyXG4gICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWxlYXNlTG9jaygpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlbGVhc2UodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5yZWFkLCAncmVhZCcpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXHJcbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRJbnRvUmVxdWVzdHMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIG1pbiwgcmVhZEludG9SZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xyXG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgdmlldywgbWluLCByZWFkSW50b1JlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlbGVhc2UocmVhZGVyKSB7XHJcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xyXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdSZWFkZXIgd2FzIHJlbGVhc2VkJyk7XHJcbiAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyRXJyb3JSZWFkSW50b1JlcXVlc3RzKHJlYWRlciwgZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMocmVhZGVyLCBlKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0cyA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cztcclxuICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcclxuICAgICAgICByZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcclxuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cclxuICAgIGZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgZGVmYXVsdEhXTSkge1xyXG4gICAgICAgIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XHJcbiAgICAgICAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhXTTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gc3RyYXRlZ3k7XHJcbiAgICAgICAgaWYgKCFzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcclxuICAgICAgICBjb25zdCBzaXplID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSxcclxuICAgICAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKGZuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiBjaHVuayA9PiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rKG9yaWdpbmFsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3QgYWJvcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuYWJvcnQ7XHJcbiAgICAgICAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xyXG4gICAgICAgIGNvbnN0IHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFib3J0OiBhYm9ydCA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcclxuICAgICAgICAgICAgY2xvc2U6IGNsb3NlID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soY2xvc2UsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXHJcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcclxuICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gKHJlYXNvbikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXNzZXJ0V3JpdGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmFib3J0ZWQgPT09ICdib29sZWFuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIEFib3J0U2lnbmFsLnByb3RvdHlwZS5hYm9ydGVkIHRocm93cyBpZiBpdHMgYnJhbmQgY2hlY2sgZmFpbHNcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0IGEgbmV3IEFib3J0Q29udHJvbGxlciwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBwbGF0Zm9ybS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xyXG4gICAgICAgIGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB3cml0YWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIGRlc3RpbmF0aW9uIGZvciBkYXRhLCBpbnRvIHdoaWNoIHlvdSBjYW4gd3JpdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NpbmsgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xyXG4gICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmF3VW5kZXJseWluZ1NpbmsgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU2luayA9IGNvbnZlcnRVbmRlcmx5aW5nU2luayhyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1bmRlcmx5aW5nU2luay50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XHJcbiAgICAgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHdyaXRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB3cml0ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGxvY2tlZCgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2xvY2tlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXHJcbiAgICAgICAgICogaW1tZWRpYXRlbHkgbW92ZWQgdG8gYW4gZXJyb3JlZCBzdGF0ZSwgd2l0aCBhbnkgcXVldWVkLXVwIHdyaXRlcyBkaXNjYXJkZWQuIFRoaXMgd2lsbCBhbHNvIGV4ZWN1dGUgYW55IGFib3J0XHJcbiAgICAgICAgICogbWVjaGFuaXNtIG9mIHRoZSB1bmRlcmx5aW5nIHNpbmsuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgaWYgdGhlIHN0cmVhbSBzaHV0cyBkb3duIHN1Y2Nlc3NmdWxseSwgb3IgcmVqZWN0IGlmIHRoZSB1bmRlcmx5aW5nIHNpbmsgc2lnbmFsZWRcclxuICAgICAgICAgKiB0aGF0IHRoZXJlIHdhcyBhbiBlcnJvciBkb2luZyBzby4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWxcclxuICAgICAgICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdhYm9ydCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGFib3J0IGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xyXG4gICAgICAgICAqIGNsb3NlIGJlaGF2aW9yLiBEdXJpbmcgdGhpcyB0aW1lIGFueSBmdXJ0aGVyIGF0dGVtcHRzIHRvIHdyaXRlIHdpbGwgZmFpbCAod2l0aG91dCBlcnJvcmluZyB0aGUgc3RyZWFtKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXHJcbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5IGNsb3Nlcywgb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhpcyBwcm9jZXNzLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGhcclxuICAgICAgICAgKiBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Nsb3NlJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cclxuICAgICAgICAgKiBpcyBsb2NrZWQsIG5vIG90aGVyIHdyaXRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxyXG4gICAgICAgICAqIHdpdGhvdXQgaW50ZXJydXB0aW9uIG9yIGludGVybGVhdmluZy4gQnkgZ2V0dGluZyBhIHdyaXRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIHdyaXRlIGF0XHJcbiAgICAgICAgICogdGhlIHNhbWUgdGltZSwgd2hpY2ggd291bGQgY2F1c2UgdGhlIHJlc3VsdGluZyB3cml0dGVuIGRhdGEgdG8gYmUgdW5wcmVkaWN0YWJsZSBhbmQgcHJvYmFibHkgdXNlbGVzcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRXcml0ZXIoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdnZXRXcml0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcclxuICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxyXG4gICAgfSk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmFib3J0LCAnYWJvcnQnKTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuY2xvc2UsICdjbG9zZScpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRXcml0ZXIsICdnZXRXcml0ZXInKTtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXHJcbiAgICBmdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XHJcbiAgICB9XHJcbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlKTtcclxuICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XHJcbiAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XHJcbiAgICAgICAgLy8gVGhlIGVycm9yIHRoYXQgd2lsbCBiZSByZXBvcnRlZCBieSBuZXcgbWV0aG9kIGNhbGxzIG9uY2UgdGhlIHN0YXRlIGJlY29tZXMgZXJyb3JlZC4gT25seSBzZXQgd2hlbiBbW3N0YXRlXV0gaXNcclxuICAgICAgICAvLyAnZXJyb3JpbmcnIG9yICdlcnJvcmVkJy4gTWF5IGJlIHNldCB0byBhbiB1bmRlZmluZWQgdmFsdWUuXHJcbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIHVuZGVmaW5lZCBmaXJzdCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbGxlciBjaGVja3MgdGhpc1xyXG4gICAgICAgIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXHJcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gVGhpcyBxdWV1ZSBpcyBwbGFjZWQgaGVyZSBpbnN0ZWFkIG9mIHRoZSB3cml0ZXIgY2xhc3MgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cml0ZXIgdG8gdGhlIG5leHQgZGF0YVxyXG4gICAgICAgIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxyXG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgICAgIC8vIFdyaXRlIHJlcXVlc3RzIGFyZSByZW1vdmVkIGZyb20gX3dyaXRlUmVxdWVzdHMgd2hlbiB3cml0ZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzXHJcbiAgICAgICAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxyXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuY2xvc2UoKS4gU3RvcmVkIGhlcmUgYmVjYXVzZSBpdCBtYXkgYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXJcclxuICAgICAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cclxuICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBDbG9zZSByZXF1ZXN0IGlzIHJlbW92ZWQgZnJvbSBfY2xvc2VSZXF1ZXN0IHdoZW4gY2xvc2UoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50cyBpdFxyXG4gICAgICAgIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXHJcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5hYm9ydCgpLiBUaGlzIG1heSBhbHNvIGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyIGhhcyBkZXRhY2hlZC5cclxuICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gVGhlIGJhY2twcmVzc3VyZSBzaWduYWwgc2V0IGJ5IHRoZSBjb250cm9sbGVyLlxyXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtKHgpIHtcclxuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcclxuICAgICAgICBpZiAoc3RyZWFtLl93cml0ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcclxuICAgICAgICAoX2EgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQocmVhc29uKTtcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IG5hcnJvd3MgdGhlIHR5cGUgb2YgYHN0cmVhbS5fc3RhdGVgIGRvd24gdG8gJ3dyaXRhYmxlJyB8ICdlcnJvcmluZycsXHJcbiAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cclxuICAgICAgICAvLyBXaWRlbiB0aGUgdHlwZSBhZ2FpbiBieSBjYXN0aW5nIHRvIFdyaXRhYmxlU3RyZWFtU3RhdGUuXHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xyXG4gICAgICAgICAgICB3YXNBbHJlYWR5RXJyb3JpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cclxuICAgICAgICAgICAgcmVhc29uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIF9wcm9taXNlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdCxcclxuICAgICAgICAgICAgICAgIF9yZWFzb246IHJlYXNvbixcclxuICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XHJcbiAgICAgICAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSBjbG9zZVJlcXVlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XHJcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvLyBXcml0YWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxyXG4gICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5wdXNoKHdyaXRlUmVxdWVzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pIHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XHJcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmluZyc7XHJcbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcclxuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcclxuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSAmJiBjb250cm9sbGVyLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSkge1xyXG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XHJcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcclxuICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XHJcbiAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcclxuICAgICAgICAgICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xyXG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJvcnRSZXF1ZXN0ID0gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O1xyXG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcclxuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcclxuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pIHtcclxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XHJcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcclxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKSB7XHJcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xyXG4gICAgICAgICAgICAvLyBUaGUgZXJyb3Igd2FzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nLCBzbyBpdCBpcyBpZ25vcmVkLlxyXG4gICAgICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcclxuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcclxuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcclxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gTmV2ZXIgZXhlY3V0ZSBzaW5rIGFib3J0KCkgYWZ0ZXIgc2luayBjbG9zZSgpLlxyXG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkge1xyXG4gICAgICAgIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcclxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XHJcbiAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xyXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcclxuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xyXG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XHJcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcclxuICAgICAgICAgICAgaWYgKGJhY2twcmVzc3VyZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGRlZmF1bHQgd3JpdGVyIHZlbmRlZCBieSBhIHtAbGluayBXcml0YWJsZVN0cmVhbX0uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xyXG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicpO1xyXG4gICAgICAgICAgICBhc3NlcnRXcml0YWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcclxuICAgICAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcclxuICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cclxuICAgICAgICAgKiBBIHByb2R1Y2VyIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGFtb3VudCBvZiBkYXRhIHRvIHdyaXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gKGR1ZSB0byBlaXRoZXIgYmVpbmcgZXJyb3JlZCwgb3IgaGF2aW5nIGFuIGFib3J0XHJcbiAgICAgICAgICogcXVldWVkIHVwKS4gSXQgd2lsbCByZXR1cm4gemVybyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gQW5kIHRoZSBnZXR0ZXIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW52b2tlZCB3aGVuXHJcbiAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZSB0cmFuc2l0aW9uc1xyXG4gICAgICAgICAqIGZyb20gbm9uLXBvc2l0aXZlIHRvIHBvc2l0aXZlLCBzaWduYWxpbmcgdGhhdCBpdCBpcyBubyBsb25nZXIgYXBwbHlpbmcgYmFja3ByZXNzdXJlLiBPbmNlIHRoZSBkZXNpcmVkIHNpemUgZGlwc1xyXG4gICAgICAgICAqIGJhY2sgdG8gemVybyBvciBiZWxvdywgdGhlIGdldHRlciB3aWxsIHJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgc3RheXMgcGVuZGluZyB1bnRpbCB0aGUgbmV4dCB0cmFuc2l0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSWYgdGhlIHN0cmVhbSBiZWNvbWVzIGVycm9yZWQgb3IgYWJvcnRlZCwgb3IgdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZWNvbWVcclxuICAgICAgICAgKiByZWplY3RlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgcmVhZHkoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uYWJvcnQgfCBzdHJlYW0uYWJvcnQocmVhc29uKX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHRoaXMsIHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5jbG9zZSB8IHN0cmVhbS5jbG9zZSgpfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxyXG4gICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXkgZnJvbVxyXG4gICAgICAgICAqIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgbG9jayBjYW4gc3RpbGwgYmUgcmVsZWFzZWQgZXZlbiBpZiBzb21lIG9uZ29pbmcgd3JpdGVzIGhhdmUgbm90IHlldCBmaW5pc2hlZCAoaS5lLiBldmVuIGlmIHRoZVxyXG4gICAgICAgICAqIHByb21pc2VzIHJldHVybmVkIGZyb20gcHJldmlvdXMgY2FsbHMgdG8ge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci53cml0ZSB8IHdyaXRlKCl9IGhhdmUgbm90IHlldCBzZXR0bGVkKS5cclxuICAgICAgICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXHJcbiAgICAgICAgICogb3RoZXIgcHJvZHVjZXJzIGZyb20gd3JpdGluZyBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVsZWFzZUxvY2soKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdyaXRlKGNodW5rID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0ZScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCB7XHJcbiAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxyXG4gICAgfSk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5hYm9ydCwgJ2Fib3J0Jyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5jbG9zZSwgJ2Nsb3NlJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5yZWxlYXNlTG9jaywgJ3JlbGVhc2VMb2NrJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS53cml0ZSwgJ3dyaXRlJyk7XHJcbiAgICBpZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxyXG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoeCkge1xyXG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcclxuICAgIH1cclxuICAgIC8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcclxuICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcclxuICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcclxuICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHdyaXRlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcclxuICAgICAgICAvLyBUaGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gXCJlcnJvcmVkXCIgYmVmb3JlIHRoZSBzaW5rIGFib3J0KCkgbWV0aG9kIHJ1bnMsIGJ1dCB0aGUgd3JpdGVyLmNsb3NlZCBwcm9taXNlIGlzIG5vdFxyXG4gICAgICAgIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xyXG4gICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xyXG4gICAgICAgIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgY2xvc2luZyBvciBjbG9zZWQgYW5kIGNhbm5vdCBiZSB3cml0dGVuIHRvJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pO1xyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNsb3NlU2VudGluZWwgPSB7fTtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlYXNvbiB3aGljaCB3YXMgcGFzc2VkIHRvIGBXcml0YWJsZVN0cmVhbS5hYm9ydChyZWFzb24pYCB3aGVuIHRoZSBzdHJlYW0gd2FzIGFib3J0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAqICBUaGlzIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgc3BlY2lmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9wdWxsLzExNzcuXHJcbiAgICAgICAgICogIFVzZSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5zaWduYWx9J3MgYHJlYXNvbmAgaW5zdGVhZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgYWJvcnRSZWFzb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnRSZWFzb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnRSZWFzb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGBBYm9ydFNpZ25hbGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhYm9ydCB0aGUgcGVuZGluZyB3cml0ZSBvciBjbG9zZSBvcGVyYXRpb24gd2hlbiB0aGUgc3RyZWFtIGlzIGFib3J0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHNpZ25hbCgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdzaWduYWwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJ1bmRsZSBhbmQgc2hpcCBhbiBgQWJvcnRDb250cm9sbGVyYCBwb2x5ZmlsbCB0b2dldGhlciB3aXRoIG91ciBwb2x5ZmlsbCxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGluc3RlYWQgd2Ugb25seSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYHNpZ25hbGAgaWYgd2UgZmluZCBhIGdsb2JhbCBgQWJvcnRDb250cm9sbGVyYCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCB3cml0YWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgcmFyZWx5IHVzZWQsIHNpbmNlIHVzdWFsbHkgaXQgc3VmZmljZXMgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmcm9tIG9uZSBvZiB0aGUgdW5kZXJseWluZ1xyXG4gICAgICAgICAqIHNpbmsncyBtZXRob2RzLiBIb3dldmVyLCBpdCBjYW4gYmUgdXNlZnVsIGZvciBzdWRkZW5seSBzaHV0dGluZyBkb3duIGEgc3RyZWFtIGluIHJlc3BvbnNlIHRvIGFuIGV2ZW50IG91dHNpZGUgdGhlXHJcbiAgICAgICAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdlcnJvcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RyZWFtIGlzIGNsb3NlZCwgZXJyb3JlZCBvciB3aWxsIGJlIHNvb24uIFRoZSBzaW5rIGNhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBpZiBpdCBnZXRzIGFuIGVycm9yIGhlcmUsIHNvXHJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgW0Fib3J0U3RlcHNdKHJlYXNvbikge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9hYm9ydEFsZ29yaXRobShyZWFzb24pO1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgW0Vycm9yU3RlcHNdKCkge1xyXG4gICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XHJcbiAgICAgICAgYWJvcnRSZWFzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbiAgICB9KTtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBpbXBsZW1lbnRpbmcgaW50ZXJmYWNlIHJlcXVpcmVkIGJ5IHRoZSBXcml0YWJsZVN0cmVhbS5cclxuICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcclxuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxyXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XHJcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRSZWFzb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XHJcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XHJcbiAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcclxuICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xyXG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcclxuICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcclxuICAgICAgICB1cG9uUHJvbWlzZShzdGFydFByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSwgciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHN0cmVhbSwgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XHJcbiAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtO1xyXG4gICAgICAgIGxldCB3cml0ZUFsZ29yaXRobTtcclxuICAgICAgICBsZXQgY2xvc2VBbGdvcml0aG07XHJcbiAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtO1xyXG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1Npbmsuc3RhcnQoY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLndyaXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd3JpdGVBbGdvcml0aG0gPSBjaHVuayA9PiB1bmRlcmx5aW5nU2luay53cml0ZShjaHVuaywgY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3cml0ZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTaW5rLmFib3J0KHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XHJcbiAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuaykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0oY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBjaHVua1NpemVFKTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlbnF1ZXVlRSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xyXG4gICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcclxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBjbG9zZVNlbnRpbmVsKSB7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlcnJvcikge1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSk7XHJcbiAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XHJcbiAgICAgICAgdXBvblByb21pc2Uoc2lua0Nsb3NlUHJvbWlzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSwgcmVhc29uID0+IHtcclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIGNodW5rKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xyXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcclxuICAgICAgICBjb25zdCBzaW5rV3JpdGVQcm9taXNlID0gY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0oY2h1bmspO1xyXG4gICAgICAgIHVwb25Qcm9taXNlKHNpbmtXcml0ZVByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcclxuICAgICAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LCByZWFzb24gPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xyXG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xyXG4gICAgfVxyXG4gICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXHJcbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XHJcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcclxuICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXHJcbiAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKTtcclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XHJcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XHJcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcclxuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcclxuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9jbG9zZWRQcm9taXNlKTtcclxuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcikge1xyXG4gICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3Jlc29sdmVkJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xyXG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XHJcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XHJcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcclxuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9yZWFkeVByb21pc2UpO1xyXG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xyXG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcikge1xyXG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XHJcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcikge1xyXG4gICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdmdWxmaWxsZWQnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XHJcbiAgICBmdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XHJcblxyXG4gICAgLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cclxuICAgIGZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3Rvcikge1xyXG4gICAgICAgIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3Rvci5uYW1lICE9PSAnRE9NRXhjZXB0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG5ldyBjdG9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydDpcclxuICAgICAqIC0gV2ViIGJyb3dzZXJzXHJcbiAgICAgKiAtIE5vZGUgMTggYW5kIGhpZ2hlciAoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC9lNGIxZmI1ZTY0MjJjMWZmMTUxMjM0YmI5ZGU3OTJkNDVkZDg4ZDg3KVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRGcm9tR2xvYmFsKCkge1xyXG4gICAgICAgIGNvbnN0IGN0b3IgPSBnbG9iYWxzID09PSBudWxsIHx8IGdsb2JhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbHMuRE9NRXhjZXB0aW9uO1xyXG4gICAgICAgIHJldHVybiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3IpID8gY3RvciA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydDpcclxuICAgICAqIC0gQWxsIHBsYXRmb3Jtc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQb2x5ZmlsbCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xyXG4gICAgICAgIGNvbnN0IGN0b3IgPSBmdW5jdGlvbiBET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XHJcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldEZ1bmN0aW9uTmFtZShjdG9yLCAnRE9NRXhjZXB0aW9uJyk7XHJcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xyXG4gICAgICAgIHJldHVybiBjdG9yO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcclxuICAgIGNvbnN0IERPTUV4Y2VwdGlvbiA9IGdldEZyb21HbG9iYWwoKSB8fCBjcmVhdGVQb2x5ZmlsbCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc291cmNlKTtcclxuICAgICAgICBjb25zdCB3cml0ZXIgPSBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKGRlc3QpO1xyXG4gICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgc2h1dHRpbmdEb3duID0gZmFsc2U7XHJcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHNwZWMncyByZXF1aXJlbWVudCB0aGF0IHdlIHdhaXQgZm9yIG9uZ29pbmcgd3JpdGVzIGR1cmluZyBzaHV0ZG93bi5cclxuICAgICAgICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtO1xyXG4gICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkID8gc2lnbmFsLnJlYXNvbiA6IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBhY3Rpb24oKSkpLCB0cnVlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXNpbmcgcmVhZGVyIGFuZCB3cml0ZXIsIHJlYWQgYWxsIGNodW5rcyBmcm9tIHRoaXMgYW5kIHdyaXRlIHRoZW0gdG8gZGVzdFxyXG4gICAgICAgICAgICAvLyAtIEJhY2twcmVzc3VyZSBtdXN0IGJlIGVuZm9yY2VkXHJcbiAgICAgICAgICAgIC8vIC0gU2h1dGRvd24gbXVzdCBzdG9wIGFsbCBhY3Rpdml0eVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUxvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBgUGVyZm9ybVByb21pc2VUaGVuYCBpbnN0ZWFkIG9mIGB1cG9uUHJvbWlzZWAgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwaXBlU3RlcCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4od3JpdGVyLl9yZWFkeVByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB1bmRlZmluZWQsIG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVqZWN0UmVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxyXG4gICAgICAgICAgICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcclxuICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcclxuICAgICAgICAgICAgaXNPckJlY29tZXNDbG9zZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJldmVudENsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxyXG4gICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0Q2xvc2VkID0gbmV3IFR5cGVFcnJvcigndGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBkZXN0Q2xvc2VkKSwgdHJ1ZSwgZGVzdENsb3NlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoYXQgdG9vLlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQ3VycmVudFdyaXRlID0gY3VycmVudFdyaXRlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihjdXJyZW50V3JpdGUsICgpID0+IG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvVGhlUmVzdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9UaGVSZXN0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwb25Qcm9taXNlKGFjdGlvbigpLCAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLCBuZXdFcnJvciA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNodXRkb3duKGlzRXJyb3IsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksICgpID0+IGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcclxuICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxyXG4gICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9zZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdjbG9zZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2VucXVldWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlcnJvcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBEZXF1ZXVlVmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgW1JlbGVhc2VTdGVwc10oKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcclxuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxyXG4gICAgfSk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UsICdjbG9zZScpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUsICdlbnF1ZXVlJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsICdlcnJvcicpO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcclxuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cclxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XHJcbiAgICAgICAgaWYgKCFzaG91bGRQdWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcclxuICAgICAgICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSwgZSA9PiB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcclxuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcclxuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcclxuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcclxuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjaHVua1NpemUgPSBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0oY2h1bmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjaHVua1NpemVFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZW5xdWV1ZUUpIHtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xyXG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcclxuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShjb250cm9sbGVyKSB7XHJcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XHJcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcclxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcclxuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcclxuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcclxuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XHJcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcclxuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sIHIgPT4ge1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xyXG4gICAgICAgIGxldCBzdGFydEFsZ29yaXRobTtcclxuICAgICAgICBsZXQgcHVsbEFsZ29yaXRobTtcclxuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtO1xyXG4gICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsKHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xyXG4gICAgfVxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXHJcbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMikge1xyXG4gICAgICAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xyXG4gICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcclxuICAgICAgICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHJlYXNvbjE7XHJcbiAgICAgICAgbGV0IHJlYXNvbjI7XHJcbiAgICAgICAgbGV0IGJyYW5jaDE7XHJcbiAgICAgICAgbGV0IGJyYW5jaDI7XHJcbiAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xyXG4gICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcclxuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxyXG4gICAgICAgICAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsyID0gY2h1bms7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYWRkIG9uZSB0aGVuIHdlJ2xsIG5lZWQgYW4gaW1wbGVtZW50YXRpb24gZm9yIHNlcmlhbGl6YWJsZSBvYmplY3RzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIWNhbmNlbGVkMiAmJiBjbG9uZUZvckJyYW5jaDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlYXNvbjEgPSByZWFzb247XHJcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbGVkMiA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XHJcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xyXG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XHJcbiAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcclxuICAgICAgICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHIpID0+IHtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xyXG4gICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKSB7XHJcbiAgICAgICAgbGV0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcclxuICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcclxuICAgICAgICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCByZWFzb24xO1xyXG4gICAgICAgIGxldCByZWFzb24yO1xyXG4gICAgICAgIGxldCBicmFuY2gxO1xyXG4gICAgICAgIGxldCBicmFuY2gyO1xyXG4gICAgICAgIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTtcclxuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyKSB7XHJcbiAgICAgICAgICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpIHtcclxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmsyID0gY2h1bms7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsyID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHB1bGxXaXRoQllPQlJlYWRlcih2aWV3LCBmb3JCcmFuY2gyKSB7XHJcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBieW9iQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDIgOiBicmFuY2gxO1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gxIDogYnJhbmNoMjtcclxuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoY2xvbmVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lZENodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCAmJiBvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgMSwgcmVhZEludG9SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHVsbDFBbGdvcml0aG0oKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwdWxsMkFsZ29yaXRobSgpIHtcclxuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcclxuICAgICAgICAgICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcclxuICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcclxuICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xyXG4gICAgICAgIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGwyQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcclxuICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcclxuICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlSXNPYmplY3Qoc3RyZWFtKSAmJiB0eXBlb2Ygc3RyZWFtLmdldFJlYWRlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tKHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtTGlrZShzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUZyb21EZWZhdWx0UmVhZGVyKHNvdXJjZS5nZXRSZWFkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUZyb21JdGVyYWJsZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSkge1xyXG4gICAgICAgIGxldCBzdHJlYW07XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3JSZWNvcmQgPSBHZXRJdGVyYXRvcihhc3luY0l0ZXJhYmxlLCAnYXN5bmMnKTtcclxuICAgICAgICBjb25zdCBzdGFydEFsZ29yaXRobSA9IG5vb3A7XHJcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcclxuICAgICAgICAgICAgbGV0IG5leHRSZXN1bHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0UmVzdWx0ID0gSXRlcmF0b3JOZXh0KGl0ZXJhdG9yUmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV4dFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKG5leHRSZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgobmV4dFByb21pc2UsIGl0ZXJSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoaXRlclJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBJdGVyYXRvckNvbXBsZXRlKGl0ZXJSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmF0b3JSZWNvcmQuaXRlcmF0b3I7XHJcbiAgICAgICAgICAgIGxldCByZXR1cm5NZXRob2Q7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5NZXRob2QgPSBHZXRNZXRob2QoaXRlcmF0b3IsICdyZXR1cm4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCByZXR1cm5SZXN1bHQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZWZsZWN0Q2FsbChyZXR1cm5NZXRob2QsIGl0ZXJhdG9yLCBbcmVhc29uXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHJldHVyblJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXR1cm5Qcm9taXNlLCBpdGVyUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KGl0ZXJSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGl0ZXJhdG9yLnJldHVybigpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJlYW0gPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tRGVmYXVsdFJlYWRlcihyZWFkZXIpIHtcclxuICAgICAgICBsZXQgc3RyZWFtO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0QWxnb3JpdGhtID0gbm9vcDtcclxuICAgICAgICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xyXG4gICAgICAgICAgICBsZXQgcmVhZFByb21pc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZWFkUHJvbWlzZSA9IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZWFkUHJvbWlzZSwgcmVhZFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdChyZWFkUmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSByZWFkZXIucmVhZCgpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZWFkUmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkUmVzdWx0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWFkZXIuY2FuY2VsKHJlYXNvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJlYW0gPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwKTtcclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShzb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KHNvdXJjZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2U7XHJcbiAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcclxuICAgICAgICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2FuY2VsO1xyXG4gICAgICAgIGNvbnN0IHB1bGwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucHVsbDtcclxuICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcclxuICAgICAgICBjb25zdCB0eXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnR5cGU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YCksXHJcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXHJcbiAgICAgICAgICAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHlwZScgdGhhdGApXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGNvbnRleHQpIHtcclxuICAgICAgICB0eXBlID0gYCR7dHlwZX1gO1xyXG4gICAgICAgIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7dHlwZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcclxuICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XHJcbiAgICAgICAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcclxuICAgICAgICBjb25zdCBwcmV2ZW50QWJvcnQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudEFib3J0O1xyXG4gICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcclxuICAgICAgICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWw7XHJcbiAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxyXG4gICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpLFxyXG4gICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IEJvb2xlYW4ocHJldmVudENsb3NlKSxcclxuICAgICAgICAgICAgc2lnbmFsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocGFpciwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkocGFpciwgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3QgcmVhZGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIucmVhZGFibGU7XHJcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZChyZWFkYWJsZSwgJ3JlYWRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XHJcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIud3JpdGFibGU7XHJcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZCh3cml0YWJsZSwgJ3dyaXRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XHJcbiAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XHJcbiAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlYWRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgc291cmNlIG9mIGRhdGEsIGZyb20gd2hpY2ggeW91IGNhbiByZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2UgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xyXG4gICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSAnYnl0ZXMnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XHJcbiAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xyXG4gICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHwgcmVhZGVyfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgbG9ja2VkKCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnbG9ja2VkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbmNlbHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIGEgbG9zcyBvZiBpbnRlcmVzdCBpbiB0aGUgc3RyZWFtIGJ5IGEgY29uc3VtZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgc3VwcGxpZWQgYHJlYXNvbmAgYXJndW1lbnQgd2lsbCBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UncyB7QGxpbmsgVW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgfCBjYW5jZWwoKX1cclxuICAgICAgICAgKiBtZXRob2QsIHdoaWNoIG1pZ2h0IG9yIG1pZ2h0IG5vdCB1c2UgaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2FuY2VsJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFJlYWRlcihyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdnZXRSZWFkZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwaXBlVGhyb3VnaChyYXdUcmFuc2Zvcm0sIHJhd09wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHJhd1RyYW5zZm9ybSwgMSwgJ3BpcGVUaHJvdWdoJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodHJhbnNmb3JtLndyaXRhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsKTtcclxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5yZWFkYWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGlwZVRvKGRlc3RpbmF0aW9uLCByYXdPcHRpb25zID0ge30pIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUbycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYFBhcmFtZXRlciAxIGlzIHJlcXVpcmVkIGluICdwaXBlVG8nLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1gKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlZXMgdGhpcyByZWFkYWJsZSBzdHJlYW0sIHJldHVybmluZyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHR3byByZXN1bHRpbmcgYnJhbmNoZXMgYXNcclxuICAgICAgICAgKiBuZXcge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUZWVpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0LCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cclxuICAgICAgICAgKiBUbyBjYW5jZWwgdGhlIHN0cmVhbSwgY2FuY2VsIGJvdGggb2YgdGhlIHJlc3VsdGluZyBicmFuY2hlczsgYSBjb21wb3NpdGUgY2FuY2VsbGF0aW9uIHJlYXNvbiB3aWxsIHRoZW4gYmVcclxuICAgICAgICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2h1bmtzIHNlZW4gaW4gZWFjaCBicmFuY2ggd2lsbCBiZSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZSBjaHVua3MgYXJlIG5vdCBpbW11dGFibGUsXHJcbiAgICAgICAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRlZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3RlZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3ZhbHVlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcywgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgW1N5bWJvbEFzeW5jSXRlcmF0b3JdKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gU3R1YiBpbXBsZW1lbnRhdGlvbiwgb3ZlcnJpZGRlbiBiZWxvd1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgUmVhZGFibGVTdHJlYW0gd3JhcHBpbmcgdGhlIHByb3ZpZGVkIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGFwdCB2YXJpb3VzIGtpbmRzIG9mIG9iamVjdHMgaW50byBhIHJlYWRhYmxlIHN0cmVhbSxcclxuICAgICAgICAgKiBzdWNoIGFzIGFuIGFycmF5LCBhbiBhc3luYyBnZW5lcmF0b3IsIG9yIGEgTm9kZS5qcyByZWFkYWJsZSBzdHJlYW0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGZyb20oYXN5bmNJdGVyYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1Gcm9tKGFzeW5jSXRlcmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLCB7XHJcbiAgICAgICAgZnJvbTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XHJcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHBpcGVUaHJvdWdoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICBwaXBlVG86IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgdmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcclxuICAgICAgICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbiAgICB9KTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5mcm9tLCAnZnJvbScpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5jYW5jZWwsICdjYW5jZWwnKTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0UmVhZGVyLCAnZ2V0UmVhZGVyJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoLCAncGlwZVRocm91Z2gnKTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvLCAncGlwZVRvJyk7XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnRlZSwgJ3RlZScpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsICd2YWx1ZXMnKTtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xBc3luY0l0ZXJhdG9yLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cclxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrID0gMSwgc2l6ZUFsZ29yaXRobSA9ICgpID0+IDEpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XHJcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xyXG4gICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICB9XHJcbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxyXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XHJcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xyXG4gICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDAsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcclxuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcclxuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtKHgpIHtcclxuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcclxuICAgICAgICBpZiAoc3RyZWFtLl9yZWFkZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcclxuICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcclxuICAgICAgICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3RzID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzO1xyXG4gICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcclxuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHModW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xyXG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcclxuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcclxuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cztcclxuICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcclxuICAgICAgICAgICAgcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcclxuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xyXG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSBlO1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xyXG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XHJcbiAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyRXJyb3JSZWFkUmVxdWVzdHMocmVhZGVyLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0cyhyZWFkZXIsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cclxuICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcclxuICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdCBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uID0gKGNodW5rKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24sICdzaXplJyk7XHJcbiAgICAvKipcclxuICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggY2h1bmsuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIGl0cyBgYnl0ZUxlbmd0aGAgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XHJcbiAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcclxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5JyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5cclxuICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHgpIHtcclxuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdCBjb3VudFNpemVGdW5jdGlvbiA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICBzZXRGdW5jdGlvbk5hbWUoY291bnRTaXplRnVuY3Rpb24sICdzaXplJyk7XHJcbiAgICAvKipcclxuICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGNodW5rcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcclxuICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IGFsd2F5cyByZXR1cm5pbmcgMS5cclxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdG90YWwgcXVldWUgc2l6ZSBpcyBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzIGluIHRoZSBxdWV1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XHJcbiAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnQ291bnRRdWV1aW5nU3RyYXRlZ3knLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBDb3VudFF1ZXVpbmdTdHJhdGVneS5cclxuICAgIGZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBDb3VudFF1ZXVpbmdTdHJhdGVneWApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBDb3VudFF1ZXVpbmdTdHJhdGVneTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXIob3JpZ2luYWwsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcclxuICAgICAgICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2FuY2VsO1xyXG4gICAgICAgIGNvbnN0IGZsdXNoID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmZsdXNoO1xyXG4gICAgICAgIGNvbnN0IHJlYWRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5yZWFkYWJsZVR5cGU7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnRyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCB3cml0YWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGFibGVUeXBlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrKGNhbmNlbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLFxyXG4gICAgICAgICAgICBmbHVzaDogZmx1c2ggPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXHJcbiAgICAgICAgICAgIHJlYWRhYmxlVHlwZSxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayh0cmFuc2Zvcm0sIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0cmFuc2Zvcm0nIHRoYXRgKSxcclxuICAgICAgICAgICAgd3JpdGFibGVUeXBlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcclxuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gKHJlYXNvbikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtXHJcbiAgICAvKipcclxuICAgICAqIEEgdHJhbnNmb3JtIHN0cmVhbSBjb25zaXN0cyBvZiBhIHBhaXIgb2Ygc3RyZWFtczogYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19LFxyXG4gICAgICoga25vd24gYXMgaXRzIHdyaXRhYmxlIHNpZGUsIGFuZCBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0sIGtub3duIGFzIGl0cyByZWFkYWJsZSBzaWRlLlxyXG4gICAgICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcclxuICAgICAqIG1hZGUgYXZhaWxhYmxlIGZvciByZWFkaW5nIGZyb20gdGhlIHJlYWRhYmxlIHNpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1RyYW5zZm9ybWVyID0ge30sIHJhd1dyaXRhYmxlU3RyYXRlZ3kgPSB7fSwgcmF3UmVhZGFibGVTdHJhdGVneSA9IHt9KSB7XHJcbiAgICAgICAgICAgIGlmIChyYXdUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByYXdUcmFuc2Zvcm1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3V3JpdGFibGVTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcclxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3UmVhZGFibGVTdHJhdGVneSwgJ1RoaXJkIHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIucmVhZGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJlYWRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIud3JpdGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhyZWFkYWJsZVN0cmF0ZWd5LCAwKTtcclxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0ocmVhZGFibGVTdHJhdGVneSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xyXG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobSh3cml0YWJsZVN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XHJcbiAgICAgICAgICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIodGhpcywgdHJhbnNmb3JtZXIpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgcmVhZGFibGUoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWRhYmxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQgd3JpdGFibGUoKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcclxuICAgICAgICByZWFkYWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbiAgICB9KTtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcclxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuaykge1xyXG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY2xvc2VBbGdvcml0aG0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlQ2FuY2VsQWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcclxuICAgICAgICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxyXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcclxuICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbSh4KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIGJvdGggc2lkZXMgYXJlIGFscmVhZHkgZXJyb3JlZC5cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xyXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XHJcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKTtcclxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChzdHJlYW0uX3dyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xyXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZShzdHJlYW0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSkge1xyXG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xyXG4gICAgICAgICAgICAvLyBQcmV0ZW5kIHRoYXQgcHVsbCgpIHdhcyBjYWxsZWQgdG8gcGVybWl0IGFueSBwZW5kaW5nIHdyaXRlKCkgY2FsbHMgdG8gY29tcGxldGUuIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZSgpXHJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBjYWxsZWQgZnJvbSBlbnF1ZXVlKCkgb3IgcHVsbCgpIG9uY2UgdGhlIFJlYWRhYmxlU3RyZWFtIGlzIGVycm9yZWQsIHNvIHRoaXMgd2lsbCB3aWxsIGJlIHRoZSBmaW5hbCB0aW1lXHJcbiAgICAgICAgICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxyXG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XHJcbiAgICAgICAgLy8gUGFzc2VzIGFsc28gd2hlbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cclxuICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgdGhlIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gYW5kIHtAbGluayBXcml0YWJsZVN0cmVhbX0gb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRyYW5zZm9ybVN0cmVhbX0uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHJlYWRhYmxlIHNpZGXigJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVucXVldWUoY2h1bmsgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvcnMgYm90aCB0aGUgcmVhZGFibGUgc2lkZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmVcclxuICAgICAgICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVycm9yKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyB0aGUgcmVhZGFibGUgc2lkZSBhbmQgZXJyb3JzIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXHJcbiAgICAgICAgICogdHJhbnNmb3JtZXIgb25seSBuZWVkcyB0byBjb25zdW1lIGEgcG9ydGlvbiBvZiB0aGUgY2h1bmtzIHdyaXR0ZW4gdG8gdGhlIHdyaXRhYmxlIHNpZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXHJcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XHJcbiAgICB9KTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSwgJ2VucXVldWUnKTtcclxuICAgIHNldEZ1bmN0aW9uTmFtZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsICdlcnJvcicpO1xyXG4gICAgc2V0RnVuY3Rpb25OYW1lKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS50ZXJtaW5hdGUsICd0ZXJtaW5hdGUnKTtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xyXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXHJcbiAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcclxuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcclxuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdHJhbnNmb3JtQWxnb3JpdGhtO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XHJcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcihzdHJlYW0sIHRyYW5zZm9ybWVyKSB7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtO1xyXG4gICAgICAgIGxldCBmbHVzaEFsZ29yaXRobTtcclxuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtO1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSBjaHVuayA9PiB0cmFuc2Zvcm1lci50cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAodHJhbnNmb3JtUmVzdWx0RSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHRyYW5zZm9ybVJlc3VsdEUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhbnNmb3JtZXIuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lci5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdHJhbnNmb3JtZXIuY2FuY2VsKHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xyXG4gICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcclxuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcclxuICAgICAgICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cclxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xyXG4gICAgICAgICAgICB0aHJvdyBzdHJlYW0uX3JlYWRhYmxlLl9zdG9yZWRFcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGlmIChiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xyXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHRyYW5zZm9ybVByb21pc2UsIHVuZGVmaW5lZCwgciA9PiB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIHIpO1xyXG4gICAgICAgICAgICB0aHJvdyByO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XHJcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcignVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWQnKTtcclxuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmsgQWxnb3JpdGhtc1xyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKSB7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcclxuICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcclxuICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlID0gc3RyZWFtLl93cml0YWJsZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gd3JpdGFibGUuX3N0YXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgd3JpdGFibGUuX3N0b3JlZEVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cclxuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XHJcbiAgICAgICAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfY2FuY2VsQWxnb3JpdGhtIGNhbGxzIHJlYWRhYmxlLmNhbmNlbCgpIGludGVybmFsbHksXHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgcnVuIHRoZSBfY2FuY2VsQWxnb3JpdGhtIGFnYWluLlxyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xyXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgcmVhZGFibGUuX3N0b3JlZEVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LCByID0+IHtcclxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHJlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xyXG4gICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pIHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cclxuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XHJcbiAgICAgICAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfZmx1c2hBbGdvcml0aG0gY2FsbHMgcmVhZGFibGUuY2FuY2VsKCkgaW50ZXJuYWxseSxcclxuICAgICAgICAvLyB3ZSBkb24ndCBhbHNvIHJ1biB0aGUgX2NhbmNlbEFsZ29yaXRobS5cclxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XHJcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XHJcbiAgICAgICAgdXBvblByb21pc2UoZmx1c2hQcm9taXNlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYWRhYmxlLl9zdG9yZWRFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sIHIgPT4ge1xyXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XHJcbiAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlIEFsZ29yaXRobXNcclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xyXG4gICAgICAgIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cclxuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VDYW5jZWxBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0cmVhbS5fd3JpdGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cclxuICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XHJcbiAgICAgICAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfZmx1c2hBbGdvcml0aG0gY2FsbHMgd3JpdGFibGUuYWJvcnQoKSBvclxyXG4gICAgICAgIC8vIHdyaXRhYmxlLmNhbmNlbCgpIGludGVybmFsbHksIHdlIGRvbid0IHJ1biB0aGUgX2NhbmNlbEFsZ29yaXRobSBhZ2Fpbiwgb3IgYWxzbyBydW4gdGhlXHJcbiAgICAgICAgLy8gX2ZsdXNoQWxnb3JpdGhtLlxyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xyXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHdyaXRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgd3JpdGFibGUuX3N0b3JlZEVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHdyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSwgciA9PiB7XHJcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHdyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtKTtcclxuICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyKSB7XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlKCk7XHJcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYXNvbikge1xyXG4gICAgICAgIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShjb250cm9sbGVyLl9maW5pc2hQcm9taXNlKTtcclxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdChyZWFzb24pO1xyXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXHJcbiAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnRzLkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kgPSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xyXG4gICAgZXhwb3J0cy5Db3VudFF1ZXVpbmdTdHJhdGVneSA9IENvdW50UXVldWluZ1N0cmF0ZWd5O1xyXG4gICAgZXhwb3J0cy5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcclxuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbTtcclxuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xyXG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcclxuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XHJcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcclxuICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xyXG4gICAgZXhwb3J0cy5UcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xyXG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbSA9IFdyaXRhYmxlU3RyZWFtO1xyXG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcclxuICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xyXG5cclxufSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb255ZmlsbC5lczIwMTguanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/streams.cjs":
/*!*********************************************!*\
  !*** ./node_modules/fetch-blob/streams.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* c8 ignore start */\r\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\r\nconst POOL_SIZE = 65536\r\n\r\nif (!globalThis.ReadableStream) {\r\n  // `node:stream/web` got introduced in v16.5.0 as experimental\r\n  // and it's preferred over the polyfilled version. So we also\r\n  // suppress the warning that gets emitted by NodeJS for using it.\r\n  try {\r\n    const process = __webpack_require__(/*! node:process */ \"node:process\")\r\n    const { emitWarning } = process\r\n    try {\r\n      process.emitWarning = () => {}\r\n      Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\"))\r\n      process.emitWarning = emitWarning\r\n    } catch (error) {\r\n      process.emitWarning = emitWarning\r\n      throw error\r\n    }\r\n  } catch (error) {\r\n    // fallback to polyfill implementation\r\n    Object.assign(globalThis, __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.es2018.js */ \"(rsc)/./node_modules/fetch-blob/node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\"))\r\n  }\r\n}\r\n\r\ntry {\r\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\r\n  // Only `import()` can use prefix in 12.20 and later\r\n  const { Blob } = __webpack_require__(/*! buffer */ \"buffer\")\r\n  if (Blob && !Blob.prototype.stream) {\r\n    Blob.prototype.stream = function name (params) {\r\n      let position = 0\r\n      const blob = this\r\n\r\n      return new ReadableStream({\r\n        type: 'bytes',\r\n        async pull (ctrl) {\r\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\r\n          const buffer = await chunk.arrayBuffer()\r\n          position += buffer.byteLength\r\n          ctrl.enqueue(new Uint8Array(buffer))\r\n\r\n          if (position === blob.size) {\r\n            ctrl.close()\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n} catch (error) {}\r\n/* c8 ignore end */\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9zdHJlYW1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxrQ0FBYztBQUMxQyxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLHdDQUFpQjtBQUN6RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQywrSUFBOEM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9zdHJlYW1zLmNqcz9mMTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGM4IGlnbm9yZSBzdGFydCAqL1xyXG4vLyA2NCBLaUIgKHNhbWUgc2l6ZSBjaHJvbWUgc2xpY2UgdGhlaXJzIGJsb2IgaW50byBVaW50OGFycmF5J3MpXHJcbmNvbnN0IFBPT0xfU0laRSA9IDY1NTM2XHJcblxyXG5pZiAoIWdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHtcclxuICAvLyBgbm9kZTpzdHJlYW0vd2ViYCBnb3QgaW50cm9kdWNlZCBpbiB2MTYuNS4wIGFzIGV4cGVyaW1lbnRhbFxyXG4gIC8vIGFuZCBpdCdzIHByZWZlcnJlZCBvdmVyIHRoZSBwb2x5ZmlsbGVkIHZlcnNpb24uIFNvIHdlIGFsc29cclxuICAvLyBzdXBwcmVzcyB0aGUgd2FybmluZyB0aGF0IGdldHMgZW1pdHRlZCBieSBOb2RlSlMgZm9yIHVzaW5nIGl0LlxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwcm9jZXNzID0gcmVxdWlyZSgnbm9kZTpwcm9jZXNzJylcclxuICAgIGNvbnN0IHsgZW1pdFdhcm5pbmcgfSA9IHByb2Nlc3NcclxuICAgIHRyeSB7XHJcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSAoKSA9PiB7fVxyXG4gICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHJlcXVpcmUoJ25vZGU6c3RyZWFtL3dlYicpKVxyXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmdcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSBlbWl0V2FybmluZ1xyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvblxyXG4gICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCByZXF1aXJlKCd3ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLmVzMjAxOC5qcycpKVxyXG4gIH1cclxufVxyXG5cclxudHJ5IHtcclxuICAvLyBEb24ndCB1c2Ugbm9kZTogcHJlZml4IGZvciB0aGlzLCByZXF1aXJlK25vZGU6IGlzIG5vdCBzdXBwb3J0ZWQgdW50aWwgbm9kZSB2MTQuMTRcclxuICAvLyBPbmx5IGBpbXBvcnQoKWAgY2FuIHVzZSBwcmVmaXggaW4gMTIuMjAgYW5kIGxhdGVyXHJcbiAgY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxyXG4gIGlmIChCbG9iICYmICFCbG9iLnByb3RvdHlwZS5zdHJlYW0pIHtcclxuICAgIEJsb2IucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uIG5hbWUgKHBhcmFtcykge1xyXG4gICAgICBsZXQgcG9zaXRpb24gPSAwXHJcbiAgICAgIGNvbnN0IGJsb2IgPSB0aGlzXHJcblxyXG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcclxuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxyXG4gICAgICAgIGFzeW5jIHB1bGwgKGN0cmwpIHtcclxuICAgICAgICAgIGNvbnN0IGNodW5rID0gYmxvYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYmxvYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRSkpXHJcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpXHJcbiAgICAgICAgICBwb3NpdGlvbiArPSBidWZmZXIuYnl0ZUxlbmd0aFxyXG4gICAgICAgICAgY3RybC5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXHJcblxyXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBibG9iLnNpemUpIHtcclxuICAgICAgICAgICAgY3RybC5jbG9zZSgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxufSBjYXRjaCAoZXJyb3IpIHt9XHJcbi8qIGM4IGlnbm9yZSBlbmQgKi9cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/streams.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/file.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/file.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   File: () => (/* binding */ File),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/fetch-blob/index.js\");\n\r\n\r\nconst _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  #lastModified = 0\r\n  #name = ''\r\n\r\n  /**\r\n   * @param {*[]} fileBits\r\n   * @param {string} fileName\r\n   * @param {{lastModified?: number, type?: string}} options\r\n   */// @ts-ignore\r\n  constructor (fileBits, fileName, options = {}) {\r\n    if (arguments.length < 2) {\r\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\r\n    }\r\n    super(fileBits, options)\r\n\r\n    if (options === null) options = {}\r\n\r\n    // Simulate WebIDL type casting for NaN value in lastModified option.\r\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\r\n    if (!Number.isNaN(lastModified)) {\r\n      this.#lastModified = lastModified\r\n    }\r\n\r\n    this.#name = String(fileName)\r\n  }\r\n\r\n  get name () {\r\n    return this.#name\r\n  }\r\n\r\n  get lastModified () {\r\n    return this.#lastModified\r\n  }\r\n\r\n  get [Symbol.toStringTag] () {\r\n    return 'File'\r\n  }\r\n\r\n  static [Symbol.hasInstance] (object) {\r\n    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] &&\r\n      /^(File)$/.test(object[Symbol.toStringTag])\r\n  }\r\n}\r\n\r\n/** @type {typeof globalThis.File} */// @ts-ignore\r\nconst File = _File\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9maWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUM3QjtBQUNBLGlDQUFpQyxpREFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSx3RkFBd0Ysa0JBQWtCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpREFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQzVCO0FBQ1AsaUVBQWUsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2ZpbGUuanM/OWU0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xyXG5cclxuY29uc3QgX0ZpbGUgPSBjbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XHJcbiAgI2xhc3RNb2RpZmllZCA9IDBcclxuICAjbmFtZSA9ICcnXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7KltdfSBmaWxlQml0c1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZVxyXG4gICAqIEBwYXJhbSB7e2xhc3RNb2RpZmllZD86IG51bWJlciwgdHlwZT86IHN0cmluZ319IG9wdGlvbnNcclxuICAgKi8vLyBAdHMtaWdub3JlXHJcbiAgY29uc3RydWN0b3IgKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRmlsZSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYClcclxuICAgIH1cclxuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKVxyXG5cclxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge31cclxuXHJcbiAgICAvLyBTaW11bGF0ZSBXZWJJREwgdHlwZSBjYXN0aW5nIGZvciBOYU4gdmFsdWUgaW4gbGFzdE1vZGlmaWVkIG9wdGlvbi5cclxuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB1bmRlZmluZWQgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKVxyXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xyXG4gICAgICB0aGlzLiNsYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWRcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiNuYW1lID0gU3RyaW5nKGZpbGVOYW1lKVxyXG4gIH1cclxuXHJcbiAgZ2V0IG5hbWUgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI25hbWVcclxuICB9XHJcblxyXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuI2xhc3RNb2RpZmllZFxyXG4gIH1cclxuXHJcbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcclxuICAgIHJldHVybiAnRmlsZSdcclxuICB9XHJcblxyXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gISFvYmplY3QgJiYgb2JqZWN0IGluc3RhbmNlb2YgQmxvYiAmJlxyXG4gICAgICAvXihGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXHJcbiAgfVxyXG59XHJcblxyXG4vKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLkZpbGV9ICovLy8gQHRzLWlnbm9yZVxyXG5leHBvcnQgY29uc3QgRmlsZSA9IF9GaWxlXHJcbmV4cG9ydCBkZWZhdWx0IEZpbGVcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/from.js":
/*!*****************************************!*\
  !*** ./node_modules/fetch-blob/from.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   blobFrom: () => (/* binding */ blobFrom),\n/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fileFrom: () => (/* binding */ fileFrom),\n/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-domexception */ \"(rsc)/./node_modules/node-domexception/index.js\");\n/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/fetch-blob/file.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/fetch-blob/index.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst { stat } = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises\r\n\r\n/**\r\n * @param {string} path filepath on the disk\r\n * @param {string} [type] mimetype to use\r\n */\r\nconst blobFromSync = (path, type) => fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)\r\n\r\n/**\r\n * @param {string} path filepath on the disk\r\n * @param {string} [type] mimetype to use\r\n * @returns {Promise<Blob>}\r\n */\r\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\r\n\r\n/**\r\n * @param {string} path filepath on the disk\r\n * @param {string} [type] mimetype to use\r\n * @returns {Promise<File>}\r\n */\r\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\r\n\r\n/**\r\n * @param {string} path filepath on the disk\r\n * @param {string} [type] mimetype to use\r\n */\r\nconst fileFromSync = (path, type) => fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)\r\n\r\n// @ts-ignore\r\nconst fromBlob = (stat, path, type = '') => new _index_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]([new BlobDataItem({\r\n  path,\r\n  size: stat.size,\r\n  lastModified: stat.mtimeMs,\r\n  start: 0\r\n})], { type })\r\n\r\n// @ts-ignore\r\nconst fromFile = (stat, path, type = '') => new _file_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]([new BlobDataItem({\r\n  path,\r\n  size: stat.size,\r\n  lastModified: stat.mtimeMs,\r\n  start: 0\r\n})], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), { type, lastModified: stat.mtimeMs })\r\n\r\n/**\r\n * This is a blob backed up by a file on the disk\r\n * with minium requirement. Its wrapped around a Blob as a blobPart\r\n * so you have no direct access to this.\r\n *\r\n * @private\r\n */\r\nclass BlobDataItem {\r\n  #path\r\n  #start\r\n\r\n  constructor (options) {\r\n    this.#path = options.path\r\n    this.#start = options.start\r\n    this.size = options.size\r\n    this.lastModified = options.lastModified\r\n  }\r\n\r\n  /**\r\n   * Slicing arguments is first validated and formatted\r\n   * to not be out of range by Blob.prototype.slice\r\n   */\r\n  slice (start, end) {\r\n    return new BlobDataItem({\r\n      path: this.#path,\r\n      lastModified: this.lastModified,\r\n      size: end - start,\r\n      start: this.#start + start\r\n    })\r\n  }\r\n\r\n  async * stream () {\r\n    const { mtimeMs } = await stat(this.#path)\r\n    if (mtimeMs > this.lastModified) {\r\n      throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\r\n    }\r\n    yield * (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {\r\n      start: this.#start,\r\n      end: this.#start + this.size - 1\r\n    })\r\n  }\r\n\r\n  get [Symbol.toStringTag] () {\r\n    return 'Blob'\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9mcm9tLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNoQztBQUNRO0FBQzVDO0FBQzRCO0FBQ0M7QUFDN0I7QUFDQSxRQUFRLE9BQU8sRUFBRSw2Q0FBRTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLDhDQUE4QyxpREFBUTtBQUN0RDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSw4Q0FBOEMsaURBQVE7QUFDdEQ7QUFDQTtBQUNBLGdEQUFnRCxpREFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsTUFBTSxNQUFNO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxnREFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxtREFBUSxVQUFVLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLGdCQUFnQiw4Q0FBWTtBQUM1QjtBQUNBLFlBQVkseURBQWdCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxZQUFZO0FBQzBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL2ZldGNoLWJsb2IvZnJvbS5qcz80MTg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0YXRTeW5jLCBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ25vZGU6ZnMnXHJcbmltcG9ydCB7IGJhc2VuYW1lIH0gZnJvbSAnbm9kZTpwYXRoJ1xyXG5pbXBvcnQgRE9NRXhjZXB0aW9uIGZyb20gJ25vZGUtZG9tZXhjZXB0aW9uJ1xyXG5cclxuaW1wb3J0IEZpbGUgZnJvbSAnLi9maWxlLmpzJ1xyXG5pbXBvcnQgQmxvYiBmcm9tICcuL2luZGV4LmpzJ1xyXG5cclxuY29uc3QgeyBzdGF0IH0gPSBmc1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXHJcbiAqL1xyXG5jb25zdCBibG9iRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUJsb2Ioc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcclxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcclxuICogQHJldHVybnMge1Byb21pc2U8QmxvYj59XHJcbiAqL1xyXG5jb25zdCBibG9iRnJvbSA9IChwYXRoLCB0eXBlKSA9PiBzdGF0KHBhdGgpLnRoZW4oc3RhdCA9PiBmcm9tQmxvYihzdGF0LCBwYXRoLCB0eXBlKSlcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlPn1cclxuICovXHJcbmNvbnN0IGZpbGVGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21GaWxlKHN0YXQsIHBhdGgsIHR5cGUpKVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXHJcbiAqL1xyXG5jb25zdCBmaWxlRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUZpbGUoc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpXHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IGZyb21CbG9iID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IEJsb2IoW25ldyBCbG9iRGF0YUl0ZW0oe1xyXG4gIHBhdGgsXHJcbiAgc2l6ZTogc3RhdC5zaXplLFxyXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxyXG4gIHN0YXJ0OiAwXHJcbn0pXSwgeyB0eXBlIH0pXHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IEZpbGUoW25ldyBCbG9iRGF0YUl0ZW0oe1xyXG4gIHBhdGgsXHJcbiAgc2l6ZTogc3RhdC5zaXplLFxyXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxyXG4gIHN0YXJ0OiAwXHJcbn0pXSwgYmFzZW5hbWUocGF0aCksIHsgdHlwZSwgbGFzdE1vZGlmaWVkOiBzdGF0Lm10aW1lTXMgfSlcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgYmxvYiBiYWNrZWQgdXAgYnkgYSBmaWxlIG9uIHRoZSBkaXNrXHJcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcclxuICogc28geW91IGhhdmUgbm8gZGlyZWN0IGFjY2VzcyB0byB0aGlzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY2xhc3MgQmxvYkRhdGFJdGVtIHtcclxuICAjcGF0aFxyXG4gICNzdGFydFxyXG5cclxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xyXG4gICAgdGhpcy4jcGF0aCA9IG9wdGlvbnMucGF0aFxyXG4gICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0XHJcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemVcclxuICAgIHRoaXMubGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNsaWNpbmcgYXJndW1lbnRzIGlzIGZpcnN0IHZhbGlkYXRlZCBhbmQgZm9ybWF0dGVkXHJcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxyXG4gICAqL1xyXG4gIHNsaWNlIChzdGFydCwgZW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XHJcbiAgICAgIHBhdGg6IHRoaXMuI3BhdGgsXHJcbiAgICAgIGxhc3RNb2RpZmllZDogdGhpcy5sYXN0TW9kaWZpZWQsXHJcbiAgICAgIHNpemU6IGVuZCAtIHN0YXJ0LFxyXG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQgKyBzdGFydFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGFzeW5jICogc3RyZWFtICgpIHtcclxuICAgIGNvbnN0IHsgbXRpbWVNcyB9ID0gYXdhaXQgc3RhdCh0aGlzLiNwYXRoKVxyXG4gICAgaWYgKG10aW1lTXMgPiB0aGlzLmxhc3RNb2RpZmllZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgcmVxdWVzdGVkIGZpbGUgY291bGQgbm90IGJlIHJlYWQsIHR5cGljYWxseSBkdWUgdG8gcGVybWlzc2lvbiBwcm9ibGVtcyB0aGF0IGhhdmUgb2NjdXJyZWQgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gYSBmaWxlIHdhcyBhY3F1aXJlZC4nLCAnTm90UmVhZGFibGVFcnJvcicpXHJcbiAgICB9XHJcbiAgICB5aWVsZCAqIGNyZWF0ZVJlYWRTdHJlYW0odGhpcy4jcGF0aCwge1xyXG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQsXHJcbiAgICAgIGVuZDogdGhpcy4jc3RhcnQgKyB0aGlzLnNpemUgLSAxXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcclxuICAgIHJldHVybiAnQmxvYidcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGJsb2JGcm9tU3luY1xyXG5leHBvcnQgeyBGaWxlLCBCbG9iLCBibG9iRnJvbSwgYmxvYkZyb21TeW5jLCBmaWxlRnJvbSwgZmlsZUZyb21TeW5jIH1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/from.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fetch-blob/index.js":
/*!******************************************!*\
  !*** ./node_modules/fetch-blob/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./streams.cjs */ \"(rsc)/./node_modules/fetch-blob/streams.cjs\");\n/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\r\n\r\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\r\n// Node has recently added whatwg stream into core\r\n\r\n\r\n\r\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\r\nconst POOL_SIZE = 65536\r\n\r\n/** @param {(Blob | Uint8Array)[]} parts */\r\nasync function * toIterator (parts, clone = true) {\r\n  for (const part of parts) {\r\n    if ('stream' in part) {\r\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\r\n    } else if (ArrayBuffer.isView(part)) {\r\n      if (clone) {\r\n        let position = part.byteOffset\r\n        const end = part.byteOffset + part.byteLength\r\n        while (position !== end) {\r\n          const size = Math.min(end - position, POOL_SIZE)\r\n          const chunk = part.buffer.slice(position, position + size)\r\n          position += chunk.byteLength\r\n          yield new Uint8Array(chunk)\r\n        }\r\n      } else {\r\n        yield part\r\n      }\r\n    /* c8 ignore next 10 */\r\n    } else {\r\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\r\n      let position = 0, b = (/** @type {Blob} */ (part))\r\n      while (position !== b.size) {\r\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\r\n        const buffer = await chunk.arrayBuffer()\r\n        position += buffer.byteLength\r\n        yield new Uint8Array(buffer)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst _Blob = class Blob {\r\n  /** @type {Array.<(Blob|Uint8Array)>} */\r\n  #parts = []\r\n  #type = ''\r\n  #size = 0\r\n  #endings = 'transparent'\r\n\r\n  /**\r\n   * The Blob() constructor returns a new Blob object. The content\r\n   * of the blob consists of the concatenation of the values given\r\n   * in the parameter array.\r\n   *\r\n   * @param {*} blobParts\r\n   * @param {{ type?: string, endings?: string }} [options]\r\n   */\r\n  constructor (blobParts = [], options = {}) {\r\n    if (typeof blobParts !== 'object' || blobParts === null) {\r\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\r\n    }\r\n\r\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\r\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\r\n    }\r\n\r\n    if (typeof options !== 'object' && typeof options !== 'function') {\r\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\r\n    }\r\n\r\n    if (options === null) options = {}\r\n\r\n    const encoder = new TextEncoder()\r\n    for (const element of blobParts) {\r\n      let part\r\n      if (ArrayBuffer.isView(element)) {\r\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\r\n      } else if (element instanceof ArrayBuffer) {\r\n        part = new Uint8Array(element.slice(0))\r\n      } else if (element instanceof Blob) {\r\n        part = element\r\n      } else {\r\n        part = encoder.encode(`${element}`)\r\n      }\r\n\r\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\r\n      this.#parts.push(part)\r\n    }\r\n\r\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\r\n    const type = options.type === undefined ? '' : String(options.type)\r\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\r\n  }\r\n\r\n  /**\r\n   * The Blob interface's size property returns the\r\n   * size of the Blob in bytes.\r\n   */\r\n  get size () {\r\n    return this.#size\r\n  }\r\n\r\n  /**\r\n   * The type property of a Blob object returns the MIME type of the file.\r\n   */\r\n  get type () {\r\n    return this.#type\r\n  }\r\n\r\n  /**\r\n   * The text() method in the Blob interface returns a Promise\r\n   * that resolves with a string containing the contents of\r\n   * the blob, interpreted as UTF-8.\r\n   *\r\n   * @return {Promise<string>}\r\n   */\r\n  async text () {\r\n    // More optimized than using this.arrayBuffer()\r\n    // that requires twice as much ram\r\n    const decoder = new TextDecoder()\r\n    let str = ''\r\n    for await (const part of toIterator(this.#parts, false)) {\r\n      str += decoder.decode(part, { stream: true })\r\n    }\r\n    // Remaining\r\n    str += decoder.decode()\r\n    return str\r\n  }\r\n\r\n  /**\r\n   * The arrayBuffer() method in the Blob interface returns a\r\n   * Promise that resolves with the contents of the blob as\r\n   * binary data contained in an ArrayBuffer.\r\n   *\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n  async arrayBuffer () {\r\n    // Easier way... Just a unnecessary overhead\r\n    // const view = new Uint8Array(this.size);\r\n    // await this.stream().getReader({mode: 'byob'}).read(view);\r\n    // return view.buffer;\r\n\r\n    const data = new Uint8Array(this.size)\r\n    let offset = 0\r\n    for await (const chunk of toIterator(this.#parts, false)) {\r\n      data.set(chunk, offset)\r\n      offset += chunk.length\r\n    }\r\n\r\n    return data.buffer\r\n  }\r\n\r\n  stream () {\r\n    const it = toIterator(this.#parts, true)\r\n\r\n    return new globalThis.ReadableStream({\r\n      // @ts-ignore\r\n      type: 'bytes',\r\n      async pull (ctrl) {\r\n        const chunk = await it.next()\r\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\r\n      },\r\n\r\n      async cancel () {\r\n        await it.return()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * The Blob interface's slice() method creates and returns a\r\n   * new Blob object which contains data from a subset of the\r\n   * blob on which it's called.\r\n   *\r\n   * @param {number} [start]\r\n   * @param {number} [end]\r\n   * @param {string} [type]\r\n   */\r\n  slice (start = 0, end = this.size, type = '') {\r\n    const { size } = this\r\n\r\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\r\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\r\n\r\n    const span = Math.max(relativeEnd - relativeStart, 0)\r\n    const parts = this.#parts\r\n    const blobParts = []\r\n    let added = 0\r\n\r\n    for (const part of parts) {\r\n      // don't add the overflow to new blobParts\r\n      if (added >= span) {\r\n        break\r\n      }\r\n\r\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\r\n      if (relativeStart && size <= relativeStart) {\r\n        // Skip the beginning and change the relative\r\n        // start & end position as we skip the unwanted parts\r\n        relativeStart -= size\r\n        relativeEnd -= size\r\n      } else {\r\n        let chunk\r\n        if (ArrayBuffer.isView(part)) {\r\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\r\n          added += chunk.byteLength\r\n        } else {\r\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\r\n          added += chunk.size\r\n        }\r\n        relativeEnd -= size\r\n        blobParts.push(chunk)\r\n        relativeStart = 0 // All next sequential parts should start at 0\r\n      }\r\n    }\r\n\r\n    const blob = new Blob([], { type: String(type).toLowerCase() })\r\n    blob.#size = span\r\n    blob.#parts = blobParts\r\n\r\n    return blob\r\n  }\r\n\r\n  get [Symbol.toStringTag] () {\r\n    return 'Blob'\r\n  }\r\n\r\n  static [Symbol.hasInstance] (object) {\r\n    return (\r\n      object &&\r\n      typeof object === 'object' &&\r\n      typeof object.constructor === 'function' &&\r\n      (\r\n        typeof object.stream === 'function' ||\r\n        typeof object.arrayBuffer === 'function'\r\n      ) &&\r\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\r\n    )\r\n  }\r\n}\r\n\r\nObject.defineProperties(_Blob.prototype, {\r\n  size: { enumerable: true },\r\n  type: { enumerable: true },\r\n  slice: { enumerable: true }\r\n})\r\n\r\n/** @type {typeof globalThis.Blob} */\r\nconst Blob = _Blob\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmV0Y2gtYmxvYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlLG1DQUFtQztBQUNsRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWdFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBLFdBQVcsd0JBQXdCO0FBQzVCO0FBQ1AsaUVBQWUsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9mZXRjaC1ibG9iL2luZGV4LmpzPzAxNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGZldGNoLWJsb2IuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXHJcblxyXG4vLyBUT0RPIChqaW1teXdhcnRpbmcpOiBpbiB0aGUgZmVhdHVyZSB1c2UgY29uZGl0aW9uYWwgbG9hZGluZyB3aXRoIHRvcCBsZXZlbCBhd2FpdCAocmVxdWlyZXMgMTQueClcclxuLy8gTm9kZSBoYXMgcmVjZW50bHkgYWRkZWQgd2hhdHdnIHN0cmVhbSBpbnRvIGNvcmVcclxuXHJcbmltcG9ydCAnLi9zdHJlYW1zLmNqcydcclxuXHJcbi8vIDY0IEtpQiAoc2FtZSBzaXplIGNocm9tZSBzbGljZSB0aGVpcnMgYmxvYiBpbnRvIFVpbnQ4YXJyYXkncylcclxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzZcclxuXHJcbi8qKiBAcGFyYW0geyhCbG9iIHwgVWludDhBcnJheSlbXX0gcGFydHMgKi9cclxuYXN5bmMgZnVuY3Rpb24gKiB0b0l0ZXJhdG9yIChwYXJ0cywgY2xvbmUgPSB0cnVlKSB7XHJcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XHJcbiAgICBpZiAoJ3N0cmVhbScgaW4gcGFydCkge1xyXG4gICAgICB5aWVsZCAqICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gKi8gKHBhcnQuc3RyZWFtKCkpKVxyXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcclxuICAgICAgaWYgKGNsb25lKSB7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydC5ieXRlT2Zmc2V0XHJcbiAgICAgICAgY29uc3QgZW5kID0gcGFydC5ieXRlT2Zmc2V0ICsgcGFydC5ieXRlTGVuZ3RoXHJcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBlbmQpIHtcclxuICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihlbmQgLSBwb3NpdGlvbiwgUE9PTF9TSVpFKVxyXG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBwYXJ0LmJ1ZmZlci5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKVxyXG4gICAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsuYnl0ZUxlbmd0aFxyXG4gICAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoY2h1bmspXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHlpZWxkIHBhcnRcclxuICAgICAgfVxyXG4gICAgLyogYzggaWdub3JlIG5leHQgMTAgKi9cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZvciBibG9icyB0aGF0IGhhdmUgYXJyYXlCdWZmZXIgYnV0IG5vIHN0cmVhbSBtZXRob2QgKG5vZGVzIGJ1ZmZlci5CbG9iKVxyXG4gICAgICBsZXQgcG9zaXRpb24gPSAwLCBiID0gKC8qKiBAdHlwZSB7QmxvYn0gKi8gKHBhcnQpKVxyXG4gICAgICB3aGlsZSAocG9zaXRpb24gIT09IGIuc2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gYi5zbGljZShwb3NpdGlvbiwgTWF0aC5taW4oYi5zaXplLCBwb3NpdGlvbiArIFBPT0xfU0laRSkpXHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKVxyXG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoXHJcbiAgICAgICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBfQmxvYiA9IGNsYXNzIEJsb2Ige1xyXG4gIC8qKiBAdHlwZSB7QXJyYXkuPChCbG9ifFVpbnQ4QXJyYXkpPn0gKi9cclxuICAjcGFydHMgPSBbXVxyXG4gICN0eXBlID0gJydcclxuICAjc2l6ZSA9IDBcclxuICAjZW5kaW5ncyA9ICd0cmFuc3BhcmVudCdcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIEJsb2IoKSBjb25zdHJ1Y3RvciByZXR1cm5zIGEgbmV3IEJsb2Igb2JqZWN0LiBUaGUgY29udGVudFxyXG4gICAqIG9mIHRoZSBibG9iIGNvbnNpc3RzIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB2YWx1ZXMgZ2l2ZW5cclxuICAgKiBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBibG9iUGFydHNcclxuICAgKiBAcGFyYW0ge3sgdHlwZT86IHN0cmluZywgZW5kaW5ncz86IHN0cmluZyB9fSBbb3B0aW9uc11cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciAoYmxvYlBhcnRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHMgIT09ICdvYmplY3QnIHx8IGJsb2JQYXJ0cyA9PT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IFRoZSBwcm92aWRlZCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgc2VxdWVuY2UuJylcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGJsb2JQYXJ0c1tTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogVGhlIG9iamVjdCBtdXN0IGhhdmUgYSBjYWxsYWJsZSBAQGl0ZXJhdG9yIHByb3BlcnR5LicpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFxcJ0Jsb2JcXCc6IHBhcmFtZXRlciAyIGNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuJylcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCkgb3B0aW9ucyA9IHt9XHJcblxyXG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYmxvYlBhcnRzKSB7XHJcbiAgICAgIGxldCBwYXJ0XHJcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZWxlbWVudCkpIHtcclxuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5idWZmZXIuc2xpY2UoZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVPZmZzZXQgKyBlbGVtZW50LmJ5dGVMZW5ndGgpKVxyXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShlbGVtZW50LnNsaWNlKDApKVxyXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XHJcbiAgICAgICAgcGFydCA9IGVsZW1lbnRcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJ0ID0gZW5jb2Rlci5lbmNvZGUoYCR7ZWxlbWVudH1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiNzaXplICs9IEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZVxyXG4gICAgICB0aGlzLiNwYXJ0cy5wdXNoKHBhcnQpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gXHJcbiAgICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhvcHRpb25zLnR5cGUpXHJcbiAgICB0aGlzLiN0eXBlID0gL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QodHlwZSkgPyB0eXBlIDogJydcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcclxuICAgKiBzaXplIG9mIHRoZSBCbG9iIGluIGJ5dGVzLlxyXG4gICAqL1xyXG4gIGdldCBzaXplICgpIHtcclxuICAgIHJldHVybiB0aGlzLiNzaXplXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdHlwZSBwcm9wZXJ0eSBvZiBhIEJsb2Igb2JqZWN0IHJldHVybnMgdGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZS5cclxuICAgKi9cclxuICBnZXQgdHlwZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy4jdHlwZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXHJcbiAgICogdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mXHJcbiAgICogdGhlIGJsb2IsIGludGVycHJldGVkIGFzIFVURi04LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxyXG4gICAqL1xyXG4gIGFzeW5jIHRleHQgKCkge1xyXG4gICAgLy8gTW9yZSBvcHRpbWl6ZWQgdGhhbiB1c2luZyB0aGlzLmFycmF5QnVmZmVyKClcclxuICAgIC8vIHRoYXQgcmVxdWlyZXMgdHdpY2UgYXMgbXVjaCByYW1cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxyXG4gICAgbGV0IHN0ciA9ICcnXHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgZmFsc2UpKSB7XHJcbiAgICAgIHN0ciArPSBkZWNvZGVyLmRlY29kZShwYXJ0LCB7IHN0cmVhbTogdHJ1ZSB9KVxyXG4gICAgfVxyXG4gICAgLy8gUmVtYWluaW5nXHJcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKVxyXG4gICAgcmV0dXJuIHN0clxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIGluIHRoZSBCbG9iIGludGVyZmFjZSByZXR1cm5zIGFcclxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXNcclxuICAgKiBiaW5hcnkgZGF0YSBjb250YWluZWQgaW4gYW4gQXJyYXlCdWZmZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cclxuICAgKi9cclxuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XHJcbiAgICAvLyBFYXNpZXIgd2F5Li4uIEp1c3QgYSB1bm5lY2Vzc2FyeSBvdmVyaGVhZFxyXG4gICAgLy8gY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSk7XHJcbiAgICAvLyBhd2FpdCB0aGlzLnN0cmVhbSgpLmdldFJlYWRlcih7bW9kZTogJ2J5b2InfSkucmVhZCh2aWV3KTtcclxuICAgIC8vIHJldHVybiB2aWV3LmJ1ZmZlcjtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKVxyXG4gICAgbGV0IG9mZnNldCA9IDBcclxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdG9JdGVyYXRvcih0aGlzLiNwYXJ0cywgZmFsc2UpKSB7XHJcbiAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpXHJcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YS5idWZmZXJcclxuICB9XHJcblxyXG4gIHN0cmVhbSAoKSB7XHJcbiAgICBjb25zdCBpdCA9IHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIHRydWUpXHJcblxyXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICB0eXBlOiAnYnl0ZXMnLFxyXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCBpdC5uZXh0KClcclxuICAgICAgICBjaHVuay5kb25lID8gY3RybC5jbG9zZSgpIDogY3RybC5lbnF1ZXVlKGNodW5rLnZhbHVlKVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgYXN5bmMgY2FuY2VsICgpIHtcclxuICAgICAgICBhd2FpdCBpdC5yZXR1cm4oKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXHJcbiAgICogbmV3IEJsb2Igb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGRhdGEgZnJvbSBhIHN1YnNldCBvZiB0aGVcclxuICAgKiBibG9iIG9uIHdoaWNoIGl0J3MgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXHJcbiAgICovXHJcbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5zaXplLCB0eXBlID0gJycpIHtcclxuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpc1xyXG5cclxuICAgIGxldCByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBzaXplKVxyXG4gICAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KHNpemUgKyBlbmQsIDApIDogTWF0aC5taW4oZW5kLCBzaXplKVxyXG5cclxuICAgIGNvbnN0IHNwYW4gPSBNYXRoLm1heChyZWxhdGl2ZUVuZCAtIHJlbGF0aXZlU3RhcnQsIDApXHJcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuI3BhcnRzXHJcbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxyXG4gICAgbGV0IGFkZGVkID0gMFxyXG5cclxuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xyXG4gICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcclxuICAgICAgaWYgKGFkZGVkID49IHNwYW4pIHtcclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzaXplID0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplXHJcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0ICYmIHNpemUgPD0gcmVsYXRpdmVTdGFydCkge1xyXG4gICAgICAgIC8vIFNraXAgdGhlIGJlZ2lubmluZyBhbmQgY2hhbmdlIHRoZSByZWxhdGl2ZVxyXG4gICAgICAgIC8vIHN0YXJ0ICYgZW5kIHBvc2l0aW9uIGFzIHdlIHNraXAgdGhlIHVud2FudGVkIHBhcnRzXHJcbiAgICAgICAgcmVsYXRpdmVTdGFydCAtPSBzaXplXHJcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBjaHVua1xyXG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcclxuICAgICAgICAgIGNodW5rID0gcGFydC5zdWJhcnJheShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihzaXplLCByZWxhdGl2ZUVuZCkpXHJcbiAgICAgICAgICBhZGRlZCArPSBjaHVuay5ieXRlTGVuZ3RoXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNodW5rID0gcGFydC5zbGljZShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihzaXplLCByZWxhdGl2ZUVuZCkpXHJcbiAgICAgICAgICBhZGRlZCArPSBjaHVuay5zaXplXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbGF0aXZlRW5kIC09IHNpemVcclxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaylcclxuICAgICAgICByZWxhdGl2ZVN0YXJ0ID0gMCAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW10sIHsgdHlwZTogU3RyaW5nKHR5cGUpLnRvTG93ZXJDYXNlKCkgfSlcclxuICAgIGJsb2IuI3NpemUgPSBzcGFuXHJcbiAgICBibG9iLiNwYXJ0cyA9IGJsb2JQYXJ0c1xyXG5cclxuICAgIHJldHVybiBibG9iXHJcbiAgfVxyXG5cclxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xyXG4gICAgcmV0dXJuICdCbG9iJ1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIG9iamVjdCAmJlxyXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgIChcclxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbidcclxuICAgICAgKSAmJlxyXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9CbG9iLnByb3RvdHlwZSwge1xyXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gIHR5cGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxyXG4gIHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxyXG59KVxyXG5cclxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5CbG9ifSAqL1xyXG5leHBvcnQgY29uc3QgQmxvYiA9IF9CbG9iXHJcbmV4cG9ydCBkZWZhdWx0IEJsb2JcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fetch-blob/index.js\n");

/***/ })

};
;