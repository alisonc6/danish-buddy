"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/event-target-shim";
exports.ids = ["vendor-chunks/event-target-shim"];
exports.modules = {

/***/ "(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

eval("/**\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n * @copyright 2015 Toru Nagashima. All rights reserved.\r\n * See LICENSE file in root directory for full license.\r\n */\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\r\n/**\r\n * @typedef {object} PrivateData\r\n * @property {EventTarget} eventTarget The event target.\r\n * @property {{type:string}} event The original event object.\r\n * @property {number} eventPhase The current event phase.\r\n * @property {EventTarget|null} currentTarget The current event target.\r\n * @property {boolean} canceled The flag to prevent default.\r\n * @property {boolean} stopped The flag to stop propagation.\r\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\r\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\r\n * @property {number} timeStamp The unix time.\r\n * @private\r\n */\r\n\r\n/**\r\n * Private data for event wrappers.\r\n * @type {WeakMap<Event, PrivateData>}\r\n * @private\r\n */\r\nconst privateData = new WeakMap();\r\n\r\n/**\r\n * Cache for wrapper classes.\r\n * @type {WeakMap<Object, Function>}\r\n * @private\r\n */\r\nconst wrappers = new WeakMap();\r\n\r\n/**\r\n * Get private data.\r\n * @param {Event} event The event object to get private data.\r\n * @returns {PrivateData} The private data of the event.\r\n * @private\r\n */\r\nfunction pd(event) {\r\n    const retv = privateData.get(event);\r\n    console.assert(\r\n        retv != null,\r\n        \"'this' is expected an Event object, but got\",\r\n        event\r\n    );\r\n    return retv\r\n}\r\n\r\n/**\r\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\r\n * @param data {PrivateData} private data.\r\n */\r\nfunction setCancelFlag(data) {\r\n    if (data.passiveListener != null) {\r\n        if (\r\n            typeof console !== \"undefined\" &&\r\n            typeof console.error === \"function\"\r\n        ) {\r\n            console.error(\r\n                \"Unable to preventDefault inside passive event listener invocation.\",\r\n                data.passiveListener\r\n            );\r\n        }\r\n        return\r\n    }\r\n    if (!data.event.cancelable) {\r\n        return\r\n    }\r\n\r\n    data.canceled = true;\r\n    if (typeof data.event.preventDefault === \"function\") {\r\n        data.event.preventDefault();\r\n    }\r\n}\r\n\r\n/**\r\n * @see https://dom.spec.whatwg.org/#interface-event\r\n * @private\r\n */\r\n/**\r\n * The event wrapper.\r\n * @constructor\r\n * @param {EventTarget} eventTarget The event target of this dispatching.\r\n * @param {Event|{type:string}} event The original event to wrap.\r\n */\r\nfunction Event(eventTarget, event) {\r\n    privateData.set(this, {\r\n        eventTarget,\r\n        event,\r\n        eventPhase: 2,\r\n        currentTarget: eventTarget,\r\n        canceled: false,\r\n        stopped: false,\r\n        immediateStopped: false,\r\n        passiveListener: null,\r\n        timeStamp: event.timeStamp || Date.now(),\r\n    });\r\n\r\n    // https://heycam.github.io/webidl/#Unforgeable\r\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\r\n\r\n    // Define accessors\r\n    const keys = Object.keys(event);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const key = keys[i];\r\n        if (!(key in this)) {\r\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\r\n        }\r\n    }\r\n}\r\n\r\n// Should be enumerable, but class methods are not enumerable.\r\nEvent.prototype = {\r\n    /**\r\n     * The type of this event.\r\n     * @type {string}\r\n     */\r\n    get type() {\r\n        return pd(this).event.type\r\n    },\r\n\r\n    /**\r\n     * The target of this event.\r\n     * @type {EventTarget}\r\n     */\r\n    get target() {\r\n        return pd(this).eventTarget\r\n    },\r\n\r\n    /**\r\n     * The target of this event.\r\n     * @type {EventTarget}\r\n     */\r\n    get currentTarget() {\r\n        return pd(this).currentTarget\r\n    },\r\n\r\n    /**\r\n     * @returns {EventTarget[]} The composed path of this event.\r\n     */\r\n    composedPath() {\r\n        const currentTarget = pd(this).currentTarget;\r\n        if (currentTarget == null) {\r\n            return []\r\n        }\r\n        return [currentTarget]\r\n    },\r\n\r\n    /**\r\n     * Constant of NONE.\r\n     * @type {number}\r\n     */\r\n    get NONE() {\r\n        return 0\r\n    },\r\n\r\n    /**\r\n     * Constant of CAPTURING_PHASE.\r\n     * @type {number}\r\n     */\r\n    get CAPTURING_PHASE() {\r\n        return 1\r\n    },\r\n\r\n    /**\r\n     * Constant of AT_TARGET.\r\n     * @type {number}\r\n     */\r\n    get AT_TARGET() {\r\n        return 2\r\n    },\r\n\r\n    /**\r\n     * Constant of BUBBLING_PHASE.\r\n     * @type {number}\r\n     */\r\n    get BUBBLING_PHASE() {\r\n        return 3\r\n    },\r\n\r\n    /**\r\n     * The target of this event.\r\n     * @type {number}\r\n     */\r\n    get eventPhase() {\r\n        return pd(this).eventPhase\r\n    },\r\n\r\n    /**\r\n     * Stop event bubbling.\r\n     * @returns {void}\r\n     */\r\n    stopPropagation() {\r\n        const data = pd(this);\r\n\r\n        data.stopped = true;\r\n        if (typeof data.event.stopPropagation === \"function\") {\r\n            data.event.stopPropagation();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stop event bubbling.\r\n     * @returns {void}\r\n     */\r\n    stopImmediatePropagation() {\r\n        const data = pd(this);\r\n\r\n        data.stopped = true;\r\n        data.immediateStopped = true;\r\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\r\n            data.event.stopImmediatePropagation();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The flag to be bubbling.\r\n     * @type {boolean}\r\n     */\r\n    get bubbles() {\r\n        return Boolean(pd(this).event.bubbles)\r\n    },\r\n\r\n    /**\r\n     * The flag to be cancelable.\r\n     * @type {boolean}\r\n     */\r\n    get cancelable() {\r\n        return Boolean(pd(this).event.cancelable)\r\n    },\r\n\r\n    /**\r\n     * Cancel this event.\r\n     * @returns {void}\r\n     */\r\n    preventDefault() {\r\n        setCancelFlag(pd(this));\r\n    },\r\n\r\n    /**\r\n     * The flag to indicate cancellation state.\r\n     * @type {boolean}\r\n     */\r\n    get defaultPrevented() {\r\n        return pd(this).canceled\r\n    },\r\n\r\n    /**\r\n     * The flag to be composed.\r\n     * @type {boolean}\r\n     */\r\n    get composed() {\r\n        return Boolean(pd(this).event.composed)\r\n    },\r\n\r\n    /**\r\n     * The unix time of this event.\r\n     * @type {number}\r\n     */\r\n    get timeStamp() {\r\n        return pd(this).timeStamp\r\n    },\r\n\r\n    /**\r\n     * The target of this event.\r\n     * @type {EventTarget}\r\n     * @deprecated\r\n     */\r\n    get srcElement() {\r\n        return pd(this).eventTarget\r\n    },\r\n\r\n    /**\r\n     * The flag to stop event bubbling.\r\n     * @type {boolean}\r\n     * @deprecated\r\n     */\r\n    get cancelBubble() {\r\n        return pd(this).stopped\r\n    },\r\n    set cancelBubble(value) {\r\n        if (!value) {\r\n            return\r\n        }\r\n        const data = pd(this);\r\n\r\n        data.stopped = true;\r\n        if (typeof data.event.cancelBubble === \"boolean\") {\r\n            data.event.cancelBubble = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The flag to indicate cancellation state.\r\n     * @type {boolean}\r\n     * @deprecated\r\n     */\r\n    get returnValue() {\r\n        return !pd(this).canceled\r\n    },\r\n    set returnValue(value) {\r\n        if (!value) {\r\n            setCancelFlag(pd(this));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Initialize this event object. But do nothing under event dispatching.\r\n     * @param {string} type The event type.\r\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\r\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\r\n     * @deprecated\r\n     */\r\n    initEvent() {\r\n        // Do nothing.\r\n    },\r\n};\r\n\r\n// `constructor` is not enumerable.\r\nObject.defineProperty(Event.prototype, \"constructor\", {\r\n    value: Event,\r\n    configurable: true,\r\n    writable: true,\r\n});\r\n\r\n// Ensure `event instanceof window.Event` is `true`.\r\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\r\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\r\n\r\n    // Make association for wrappers.\r\n    wrappers.set(window.Event.prototype, Event);\r\n}\r\n\r\n/**\r\n * Get the property descriptor to redirect a given property.\r\n * @param {string} key Property name to define property descriptor.\r\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\r\n * @private\r\n */\r\nfunction defineRedirectDescriptor(key) {\r\n    return {\r\n        get() {\r\n            return pd(this).event[key]\r\n        },\r\n        set(value) {\r\n            pd(this).event[key] = value;\r\n        },\r\n        configurable: true,\r\n        enumerable: true,\r\n    }\r\n}\r\n\r\n/**\r\n * Get the property descriptor to call a given method property.\r\n * @param {string} key Property name to define property descriptor.\r\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\r\n * @private\r\n */\r\nfunction defineCallDescriptor(key) {\r\n    return {\r\n        value() {\r\n            const event = pd(this).event;\r\n            return event[key].apply(event, arguments)\r\n        },\r\n        configurable: true,\r\n        enumerable: true,\r\n    }\r\n}\r\n\r\n/**\r\n * Define new wrapper class.\r\n * @param {Function} BaseEvent The base wrapper class.\r\n * @param {Object} proto The prototype of the original event.\r\n * @returns {Function} The defined wrapper class.\r\n * @private\r\n */\r\nfunction defineWrapper(BaseEvent, proto) {\r\n    const keys = Object.keys(proto);\r\n    if (keys.length === 0) {\r\n        return BaseEvent\r\n    }\r\n\r\n    /** CustomEvent */\r\n    function CustomEvent(eventTarget, event) {\r\n        BaseEvent.call(this, eventTarget, event);\r\n    }\r\n\r\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\r\n        constructor: { value: CustomEvent, configurable: true, writable: true },\r\n    });\r\n\r\n    // Define accessors.\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const key = keys[i];\r\n        if (!(key in BaseEvent.prototype)) {\r\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\r\n            const isFunc = typeof descriptor.value === \"function\";\r\n            Object.defineProperty(\r\n                CustomEvent.prototype,\r\n                key,\r\n                isFunc\r\n                    ? defineCallDescriptor(key)\r\n                    : defineRedirectDescriptor(key)\r\n            );\r\n        }\r\n    }\r\n\r\n    return CustomEvent\r\n}\r\n\r\n/**\r\n * Get the wrapper class of a given prototype.\r\n * @param {Object} proto The prototype of the original event to get its wrapper.\r\n * @returns {Function} The wrapper class.\r\n * @private\r\n */\r\nfunction getWrapper(proto) {\r\n    if (proto == null || proto === Object.prototype) {\r\n        return Event\r\n    }\r\n\r\n    let wrapper = wrappers.get(proto);\r\n    if (wrapper == null) {\r\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\r\n        wrappers.set(proto, wrapper);\r\n    }\r\n    return wrapper\r\n}\r\n\r\n/**\r\n * Wrap a given event to management a dispatching.\r\n * @param {EventTarget} eventTarget The event target of this dispatching.\r\n * @param {Object} event The event to wrap.\r\n * @returns {Event} The wrapper instance.\r\n * @private\r\n */\r\nfunction wrapEvent(eventTarget, event) {\r\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\r\n    return new Wrapper(eventTarget, event)\r\n}\r\n\r\n/**\r\n * Get the immediateStopped flag of a given event.\r\n * @param {Event} event The event to get.\r\n * @returns {boolean} The flag to stop propagation immediately.\r\n * @private\r\n */\r\nfunction isStopped(event) {\r\n    return pd(event).immediateStopped\r\n}\r\n\r\n/**\r\n * Set the current event phase of a given event.\r\n * @param {Event} event The event to set current target.\r\n * @param {number} eventPhase New event phase.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction setEventPhase(event, eventPhase) {\r\n    pd(event).eventPhase = eventPhase;\r\n}\r\n\r\n/**\r\n * Set the current target of a given event.\r\n * @param {Event} event The event to set current target.\r\n * @param {EventTarget|null} currentTarget New current target.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction setCurrentTarget(event, currentTarget) {\r\n    pd(event).currentTarget = currentTarget;\r\n}\r\n\r\n/**\r\n * Set a passive listener of a given event.\r\n * @param {Event} event The event to set current target.\r\n * @param {Function|null} passiveListener New passive listener.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction setPassiveListener(event, passiveListener) {\r\n    pd(event).passiveListener = passiveListener;\r\n}\r\n\r\n/**\r\n * @typedef {object} ListenerNode\r\n * @property {Function} listener\r\n * @property {1|2|3} listenerType\r\n * @property {boolean} passive\r\n * @property {boolean} once\r\n * @property {ListenerNode|null} next\r\n * @private\r\n */\r\n\r\n/**\r\n * @type {WeakMap<object, Map<string, ListenerNode>>}\r\n * @private\r\n */\r\nconst listenersMap = new WeakMap();\r\n\r\n// Listener types\r\nconst CAPTURE = 1;\r\nconst BUBBLE = 2;\r\nconst ATTRIBUTE = 3;\r\n\r\n/**\r\n * Check whether a given value is an object or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if the value is an object.\r\n */\r\nfunction isObject(x) {\r\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\r\n}\r\n\r\n/**\r\n * Get listeners.\r\n * @param {EventTarget} eventTarget The event target to get.\r\n * @returns {Map<string, ListenerNode>} The listeners.\r\n * @private\r\n */\r\nfunction getListeners(eventTarget) {\r\n    const listeners = listenersMap.get(eventTarget);\r\n    if (listeners == null) {\r\n        throw new TypeError(\r\n            \"'this' is expected an EventTarget object, but got another value.\"\r\n        )\r\n    }\r\n    return listeners\r\n}\r\n\r\n/**\r\n * Get the property descriptor for the event attribute of a given event.\r\n * @param {string} eventName The event name to get property descriptor.\r\n * @returns {PropertyDescriptor} The property descriptor.\r\n * @private\r\n */\r\nfunction defineEventAttributeDescriptor(eventName) {\r\n    return {\r\n        get() {\r\n            const listeners = getListeners(this);\r\n            let node = listeners.get(eventName);\r\n            while (node != null) {\r\n                if (node.listenerType === ATTRIBUTE) {\r\n                    return node.listener\r\n                }\r\n                node = node.next;\r\n            }\r\n            return null\r\n        },\r\n\r\n        set(listener) {\r\n            if (typeof listener !== \"function\" && !isObject(listener)) {\r\n                listener = null; // eslint-disable-line no-param-reassign\r\n            }\r\n            const listeners = getListeners(this);\r\n\r\n            // Traverse to the tail while removing old value.\r\n            let prev = null;\r\n            let node = listeners.get(eventName);\r\n            while (node != null) {\r\n                if (node.listenerType === ATTRIBUTE) {\r\n                    // Remove old value.\r\n                    if (prev !== null) {\r\n                        prev.next = node.next;\r\n                    } else if (node.next !== null) {\r\n                        listeners.set(eventName, node.next);\r\n                    } else {\r\n                        listeners.delete(eventName);\r\n                    }\r\n                } else {\r\n                    prev = node;\r\n                }\r\n\r\n                node = node.next;\r\n            }\r\n\r\n            // Add new value.\r\n            if (listener !== null) {\r\n                const newNode = {\r\n                    listener,\r\n                    listenerType: ATTRIBUTE,\r\n                    passive: false,\r\n                    once: false,\r\n                    next: null,\r\n                };\r\n                if (prev === null) {\r\n                    listeners.set(eventName, newNode);\r\n                } else {\r\n                    prev.next = newNode;\r\n                }\r\n            }\r\n        },\r\n        configurable: true,\r\n        enumerable: true,\r\n    }\r\n}\r\n\r\n/**\r\n * Define an event attribute (e.g. `eventTarget.onclick`).\r\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\r\n * @param {string} eventName The event name to define.\r\n * @returns {void}\r\n */\r\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\r\n    Object.defineProperty(\r\n        eventTargetPrototype,\r\n        `on${eventName}`,\r\n        defineEventAttributeDescriptor(eventName)\r\n    );\r\n}\r\n\r\n/**\r\n * Define a custom EventTarget with event attributes.\r\n * @param {string[]} eventNames Event names for event attributes.\r\n * @returns {EventTarget} The custom EventTarget.\r\n * @private\r\n */\r\nfunction defineCustomEventTarget(eventNames) {\r\n    /** CustomEventTarget */\r\n    function CustomEventTarget() {\r\n        EventTarget.call(this);\r\n    }\r\n\r\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\r\n        constructor: {\r\n            value: CustomEventTarget,\r\n            configurable: true,\r\n            writable: true,\r\n        },\r\n    });\r\n\r\n    for (let i = 0; i < eventNames.length; ++i) {\r\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\r\n    }\r\n\r\n    return CustomEventTarget\r\n}\r\n\r\n/**\r\n * EventTarget.\r\n *\r\n * - This is constructor if no arguments.\r\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\r\n *\r\n * For example:\r\n *\r\n *     class A extends EventTarget {}\r\n *     class B extends EventTarget(\"message\") {}\r\n *     class C extends EventTarget(\"message\", \"error\") {}\r\n *     class D extends EventTarget([\"message\", \"error\"]) {}\r\n */\r\nfunction EventTarget() {\r\n    /*eslint-disable consistent-return */\r\n    if (this instanceof EventTarget) {\r\n        listenersMap.set(this, new Map());\r\n        return\r\n    }\r\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\r\n        return defineCustomEventTarget(arguments[0])\r\n    }\r\n    if (arguments.length > 0) {\r\n        const types = new Array(arguments.length);\r\n        for (let i = 0; i < arguments.length; ++i) {\r\n            types[i] = arguments[i];\r\n        }\r\n        return defineCustomEventTarget(types)\r\n    }\r\n    throw new TypeError(\"Cannot call a class as a function\")\r\n    /*eslint-enable consistent-return */\r\n}\r\n\r\n// Should be enumerable, but class methods are not enumerable.\r\nEventTarget.prototype = {\r\n    /**\r\n     * Add a given listener to this event target.\r\n     * @param {string} eventName The event name to add.\r\n     * @param {Function} listener The listener to add.\r\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\r\n     * @returns {void}\r\n     */\r\n    addEventListener(eventName, listener, options) {\r\n        if (listener == null) {\r\n            return\r\n        }\r\n        if (typeof listener !== \"function\" && !isObject(listener)) {\r\n            throw new TypeError(\"'listener' should be a function or an object.\")\r\n        }\r\n\r\n        const listeners = getListeners(this);\r\n        const optionsIsObj = isObject(options);\r\n        const capture = optionsIsObj\r\n            ? Boolean(options.capture)\r\n            : Boolean(options);\r\n        const listenerType = capture ? CAPTURE : BUBBLE;\r\n        const newNode = {\r\n            listener,\r\n            listenerType,\r\n            passive: optionsIsObj && Boolean(options.passive),\r\n            once: optionsIsObj && Boolean(options.once),\r\n            next: null,\r\n        };\r\n\r\n        // Set it as the first node if the first node is null.\r\n        let node = listeners.get(eventName);\r\n        if (node === undefined) {\r\n            listeners.set(eventName, newNode);\r\n            return\r\n        }\r\n\r\n        // Traverse to the tail while checking duplication..\r\n        let prev = null;\r\n        while (node != null) {\r\n            if (\r\n                node.listener === listener &&\r\n                node.listenerType === listenerType\r\n            ) {\r\n                // Should ignore duplication.\r\n                return\r\n            }\r\n            prev = node;\r\n            node = node.next;\r\n        }\r\n\r\n        // Add it.\r\n        prev.next = newNode;\r\n    },\r\n\r\n    /**\r\n     * Remove a given listener from this event target.\r\n     * @param {string} eventName The event name to remove.\r\n     * @param {Function} listener The listener to remove.\r\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\r\n     * @returns {void}\r\n     */\r\n    removeEventListener(eventName, listener, options) {\r\n        if (listener == null) {\r\n            return\r\n        }\r\n\r\n        const listeners = getListeners(this);\r\n        const capture = isObject(options)\r\n            ? Boolean(options.capture)\r\n            : Boolean(options);\r\n        const listenerType = capture ? CAPTURE : BUBBLE;\r\n\r\n        let prev = null;\r\n        let node = listeners.get(eventName);\r\n        while (node != null) {\r\n            if (\r\n                node.listener === listener &&\r\n                node.listenerType === listenerType\r\n            ) {\r\n                if (prev !== null) {\r\n                    prev.next = node.next;\r\n                } else if (node.next !== null) {\r\n                    listeners.set(eventName, node.next);\r\n                } else {\r\n                    listeners.delete(eventName);\r\n                }\r\n                return\r\n            }\r\n\r\n            prev = node;\r\n            node = node.next;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Dispatch a given event.\r\n     * @param {Event|{type:string}} event The event to dispatch.\r\n     * @returns {boolean} `false` if canceled.\r\n     */\r\n    dispatchEvent(event) {\r\n        if (event == null || typeof event.type !== \"string\") {\r\n            throw new TypeError('\"event.type\" should be a string.')\r\n        }\r\n\r\n        // If listeners aren't registered, terminate.\r\n        const listeners = getListeners(this);\r\n        const eventName = event.type;\r\n        let node = listeners.get(eventName);\r\n        if (node == null) {\r\n            return true\r\n        }\r\n\r\n        // Since we cannot rewrite several properties, so wrap object.\r\n        const wrappedEvent = wrapEvent(this, event);\r\n\r\n        // This doesn't process capturing phase and bubbling phase.\r\n        // This isn't participating in a tree.\r\n        let prev = null;\r\n        while (node != null) {\r\n            // Remove this listener if it's once\r\n            if (node.once) {\r\n                if (prev !== null) {\r\n                    prev.next = node.next;\r\n                } else if (node.next !== null) {\r\n                    listeners.set(eventName, node.next);\r\n                } else {\r\n                    listeners.delete(eventName);\r\n                }\r\n            } else {\r\n                prev = node;\r\n            }\r\n\r\n            // Call this listener\r\n            setPassiveListener(\r\n                wrappedEvent,\r\n                node.passive ? node.listener : null\r\n            );\r\n            if (typeof node.listener === \"function\") {\r\n                try {\r\n                    node.listener.call(this, wrappedEvent);\r\n                } catch (err) {\r\n                    if (\r\n                        typeof console !== \"undefined\" &&\r\n                        typeof console.error === \"function\"\r\n                    ) {\r\n                        console.error(err);\r\n                    }\r\n                }\r\n            } else if (\r\n                node.listenerType !== ATTRIBUTE &&\r\n                typeof node.listener.handleEvent === \"function\"\r\n            ) {\r\n                node.listener.handleEvent(wrappedEvent);\r\n            }\r\n\r\n            // Break if `event.stopImmediatePropagation` was called.\r\n            if (isStopped(wrappedEvent)) {\r\n                break\r\n            }\r\n\r\n            node = node.next;\r\n        }\r\n        setPassiveListener(wrappedEvent, null);\r\n        setEventPhase(wrappedEvent, 0);\r\n        setCurrentTarget(wrappedEvent, null);\r\n\r\n        return !wrappedEvent.defaultPrevented\r\n    },\r\n};\r\n\r\n// `constructor` is not enumerable.\r\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\r\n    value: EventTarget,\r\n    configurable: true,\r\n    writable: true,\r\n});\r\n\r\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\r\nif (\r\n    typeof window !== \"undefined\" &&\r\n    typeof window.EventTarget !== \"undefined\"\r\n) {\r\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\r\n}\r\n\r\nexports.defineEventAttribute = defineEventAttribute;\r\nexports.EventTarget = EventTarget;\r\nexports[\"default\"] = EventTarget;\r\n\r\nmodule.exports = EventTarget\r\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget\r\nmodule.exports.defineEventAttribute = defineEventAttribute\r\n//# sourceMappingURL=event-target-shim.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vZGlzdC9ldmVudC10YXJnZXQtc2hpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsYUFBYTtBQUMzQixlQUFlLGNBQWM7QUFDN0IsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsZ0NBQWdDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FB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YztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsa0JBQWU7QUFDZjtBQUNBO0FBQ0EsMEJBQTBCLEdBQUcseUJBQXlCO0FBQ3RELG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzPzdkMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBhdXRob3IgVG9ydSBOYWdhc2hpbWEgPGh0dHBzOi8vZ2l0aHViLmNvbS9teXN0aWNhdGVhPlxyXG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcclxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldC5cclxuICogQHByb3BlcnR5IHt7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cclxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IFRoZSBjdXJyZW50IGV2ZW50IHRhcmdldC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5jZWxlZCBUaGUgZmxhZyB0byBwcmV2ZW50IGRlZmF1bHQuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGltbWVkaWF0ZVN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgVGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJyZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUuIE90aGVyd2lzZSB0aGlzIGlzIG51bGwuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG4vKipcclxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cclxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxyXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXHJcbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwZChldmVudCkge1xyXG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudCk7XHJcbiAgICBjb25zb2xlLmFzc2VydChcclxuICAgICAgICByZXR2ICE9IG51bGwsXHJcbiAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnQgb2JqZWN0LCBidXQgZ290XCIsXHJcbiAgICAgICAgZXZlbnRcclxuICAgICk7XHJcbiAgICByZXR1cm4gcmV0dlxyXG59XHJcblxyXG4vKipcclxuICogaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNzZXQtdGhlLWNhbmNlbGVkLWZsYWdcclxuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDYW5jZWxGbGFnKGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxyXG4gICAgICAgICAgICAgICAgZGF0YS5wYXNzaXZlTGlzdGVuZXJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGV2ZW50IHdyYXBwZXIuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXHJcbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcclxuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XHJcbiAgICAgICAgZXZlbnRUYXJnZXQsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZXZlbnRQaGFzZTogMixcclxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcclxuICAgICAgICBjYW5jZWxlZDogZmFsc2UsXHJcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXHJcbiAgICAgICAgaW1tZWRpYXRlU3RvcHBlZDogZmFsc2UsXHJcbiAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBudWxsLFxyXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNVbmZvcmdlYWJsZVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5cclxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxyXG5FdmVudC5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgdHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnQudHlwZVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge0V2ZW50VGFyZ2V0W119IFRoZSBjb21wb3NlZCBwYXRoIG9mIHRoaXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGNvbXBvc2VkUGF0aCgpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gcGQodGhpcykuY3VycmVudFRhcmdldDtcclxuICAgICAgICBpZiAoY3VycmVudFRhcmdldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2N1cnJlbnRUYXJnZXRdXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBOT05FKCkge1xyXG4gICAgICAgIHJldHVybiAwXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RhbnQgb2YgQ0FQVFVSSU5HX1BIQVNFLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IENBUFRVUklOR19QSEFTRSgpIHtcclxuICAgICAgICByZXR1cm4gMVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBBVF9UQVJHRVQoKSB7XHJcbiAgICAgICAgcmV0dXJuIDJcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcclxuICAgICAgICByZXR1cm4gM1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBldmVudFBoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xyXG5cclxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XHJcblxyXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuYnViYmxlcylcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIHRoaXMgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgcHJldmVudERlZmF1bHQoKSB7XHJcbiAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xyXG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGdldCBjb21wb3NlZCgpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jb21wb3NlZClcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgdGltZVN0YW1wKCkge1xyXG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBnZXQgc3JjRWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxhZyB0byBzdG9wIGV2ZW50IGJ1YmJsaW5nLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xyXG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXHJcbiAgICB9LFxyXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcclxuXHJcbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IHJldHVyblZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiAhcGQodGhpcykuY2FuY2VsZWRcclxuICAgIH0sXHJcbiAgICBzZXQgcmV0dXJuVmFsdWUodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoaXMgZXZlbnQgb2JqZWN0LiBCdXQgZG8gbm90aGluZyB1bmRlciBldmVudCBkaXNwYXRjaGluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYnViYmxlcz1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gYnViYmxlIHVwLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2FuY2VsYWJsZT1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gY2FuY2VsLlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgaW5pdEV2ZW50KCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcuXHJcbiAgICB9LFxyXG59O1xyXG5cclxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcbiAgICB2YWx1ZTogRXZlbnQsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxufSk7XHJcblxyXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudC5wcm90b3R5cGUpO1xyXG5cclxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxyXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXHJcbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cclxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlKCkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgbmV3IHdyYXBwZXIgY2xhc3MuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGRlZmluZWQgd3JhcHBlciBjbGFzcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVdyYXBwZXIoQmFzZUV2ZW50LCBwcm90bykge1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cclxuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xyXG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRXZlbnQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzLlxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRnVuYyA9IHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGlzRnVuY1xyXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBnZXQgaXRzIHdyYXBwZXIuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XHJcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIHJldHVybiBFdmVudFxyXG4gICAgfVxyXG5cclxuICAgIGxldCB3cmFwcGVyID0gd3JhcHBlcnMuZ2V0KHByb3RvKTtcclxuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcclxuICAgICAgICB3cmFwcGVyID0gZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpLCBwcm90byk7XHJcbiAgICAgICAgd3JhcHBlcnMuc2V0KHByb3RvLCB3cmFwcGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3cmFwcGVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgdG8gbWFuYWdlbWVudCBhIGRpc3BhdGNoaW5nLlxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cclxuICogQHJldHVybnMge0V2ZW50fSBUaGUgd3JhcHBlciBpbnN0YW5jZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcclxuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xyXG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgaW1tZWRpYXRlU3RvcHBlZCBmbGFnIG9mIGEgZ2l2ZW4gZXZlbnQuXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gcGQoZXZlbnQpLmltbWVkaWF0ZVN0b3BwZWRcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXZlbnRQaGFzZSBOZXcgZXZlbnQgcGhhc2UuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xyXG4gICAgcGQoZXZlbnQpLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBjdXJyZW50IHRhcmdldCBvZiBhIGdpdmVuIGV2ZW50LlxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcclxuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UGFzc2l2ZUxpc3RlbmVyKGV2ZW50LCBwYXNzaXZlTGlzdGVuZXIpIHtcclxuICAgIHBkKGV2ZW50KS5wYXNzaXZlTGlzdGVuZXIgPSBwYXNzaXZlTGlzdGVuZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICogQHByb3BlcnR5IHsxfDJ8M30gbGlzdGVuZXJUeXBlXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcclxuICogQHByb3BlcnR5IHtMaXN0ZW5lck5vZGV8bnVsbH0gbmV4dFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8vIExpc3RlbmVyIHR5cGVzXHJcbmNvbnN0IENBUFRVUkUgPSAxO1xyXG5jb25zdCBCVUJCTEUgPSAyO1xyXG5jb25zdCBBVFRSSUJVVEUgPSAzO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxyXG4gKiBAcGFyYW0ge2FueX0geCBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcclxuICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGxpc3RlbmVycy5cclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+fSBUaGUgbGlzdGVuZXJzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2ZW50VGFyZ2V0KSB7XHJcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcclxuICAgIGlmIChsaXN0ZW5lcnMgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3RlbmVyc1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgZXZlbnQgYXR0cmlidXRlIG9mIGEgZ2l2ZW4gZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IuXHJcbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGlzdGVuZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIHJlbW92aW5nIG9sZCB2YWx1ZS5cclxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJUeXBlOiBBVFRSSUJVVEUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlIChlLmcuIGBldmVudFRhcmdldC5vbmNsaWNrYCkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZGVmaW5lLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBldmVudE5hbWUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcclxuICAgICAgICBgb24ke2V2ZW50TmFtZX1gLFxyXG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnROYW1lcyBFdmVudCBuYW1lcyBmb3IgZXZlbnQgYXR0cmlidXRlcy5cclxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xyXG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXHJcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudFRhcmdldCgpIHtcclxuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUV2ZW50VGFyZ2V0LFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxyXG59XHJcblxyXG4vKipcclxuICogRXZlbnRUYXJnZXQuXHJcbiAqXHJcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXHJcbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIGNsYXNzIEEgZXh0ZW5kcyBFdmVudFRhcmdldCB7fVxyXG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxyXG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XHJcbiAqICAgICBjbGFzcyBEIGV4dGVuZHMgRXZlbnRUYXJnZXQoW1wibWVzc2FnZVwiLCBcImVycm9yXCJdKSB7fVxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XHJcbiAgICAvKmVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XHJcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSlcclxuICAgIH1cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpXHJcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cclxufVxyXG5cclxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInbGlzdGVuZXInIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC5cIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBjYXB0dXJlID0gb3B0aW9uc0lzT2JqXHJcbiAgICAgICAgICAgID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpXHJcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcixcclxuICAgICAgICAgICAgbGlzdGVuZXJUeXBlLFxyXG4gICAgICAgICAgICBwYXNzaXZlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLnBhc3NpdmUpLFxyXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxyXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNldCBpdCBhcyB0aGUgZmlyc3Qgbm9kZSBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBudWxsLlxyXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xyXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIGNoZWNraW5nIGR1cGxpY2F0aW9uLi5cclxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBpdC5cclxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKVxyXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxyXG4gICAgICAgICAgICA6IEJvb2xlYW4ob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XHJcblxyXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcclxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcclxuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXHJcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJldmVudC50eXBlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLicpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcclxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcclxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXHJcbiAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cclxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBsaXN0ZW5lciBpZiBpdCdzIG9uY2VcclxuICAgICAgICAgICAgaWYgKG5vZGUub25jZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCB0aGlzIGxpc3RlbmVyXHJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudCxcclxuICAgICAgICAgICAgICAgIG5vZGUucGFzc2l2ZSA/IG5vZGUubGlzdGVuZXIgOiBudWxsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICBpZiAoaXNTdG9wcGVkKHdyYXBwZWRFdmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcih3cmFwcGVkRXZlbnQsIG51bGwpO1xyXG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKTtcclxuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbCk7XHJcblxyXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcclxuICAgIH0sXHJcbn07XHJcblxyXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcclxuICAgIHZhbHVlOiBFdmVudFRhcmdldCxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG59KTtcclxuXHJcbi8vIEVuc3VyZSBgZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRUYXJnZXRgIGlzIGB0cnVlYC5cclxuaWYgKFxyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIlxyXG4pIHtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpO1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGU7XHJcbmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRUYXJnZXQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0XHJcbm1vZHVsZS5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRXZlbnRUYXJnZXRcclxubW9kdWxlLmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC10YXJnZXQtc2hpbS5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js\n");

/***/ })

};
;