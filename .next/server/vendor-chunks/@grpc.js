"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.registerAdminService = registerAdminService;\r\nexports.addAdminServicesToServer = addAdminServicesToServer;\r\nconst registeredAdminServices = [];\r\nfunction registerAdminService(getServiceDefinition, getHandlers) {\r\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\r\n}\r\nfunction addAdminServicesToServer(server) {\r\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\r\n        server.addService(getServiceDefinition(), getHandlers());\r\n    }\r\n}\r\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2FkbWluLmpzP2ZlMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSByZWdpc3RlckFkbWluU2VydmljZTtcclxuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7XHJcbmNvbnN0IHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzID0gW107XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQWRtaW5TZXJ2aWNlKGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycykge1xyXG4gICAgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMucHVzaCh7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9KTtcclxufVxyXG5mdW5jdGlvbiBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIoc2VydmVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcclxuICAgICAgICBzZXJ2ZXIuYWRkU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbigpLCBnZXRIYW5kbGVycygpKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZG1pbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BackoffTimeout = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'backoff';\r\nconst INITIAL_BACKOFF_MS = 1000;\r\nconst BACKOFF_MULTIPLIER = 1.6;\r\nconst MAX_BACKOFF_MS = 120000;\r\nconst BACKOFF_JITTER = 0.2;\r\n/**\r\n * Get a number uniformly at random in the range [min, max)\r\n * @param min\r\n * @param max\r\n */\r\nfunction uniformRandom(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\nclass BackoffTimeout {\r\n    constructor(callback, options) {\r\n        this.callback = callback;\r\n        /**\r\n         * The delay time at the start, and after each reset.\r\n         */\r\n        this.initialDelay = INITIAL_BACKOFF_MS;\r\n        /**\r\n         * The exponential backoff multiplier.\r\n         */\r\n        this.multiplier = BACKOFF_MULTIPLIER;\r\n        /**\r\n         * The maximum delay time\r\n         */\r\n        this.maxDelay = MAX_BACKOFF_MS;\r\n        /**\r\n         * The maximum fraction by which the delay time can randomly vary after\r\n         * applying the multiplier.\r\n         */\r\n        this.jitter = BACKOFF_JITTER;\r\n        /**\r\n         * Indicates whether the timer is currently running.\r\n         */\r\n        this.running = false;\r\n        /**\r\n         * Indicates whether the timer should keep the Node process running if no\r\n         * other async operation is doing so.\r\n         */\r\n        this.hasRef = true;\r\n        /**\r\n         * The time that the currently running timer was started. Only valid if\r\n         * running is true.\r\n         */\r\n        this.startTime = new Date();\r\n        /**\r\n         * The approximate time that the currently running timer will end. Only valid\r\n         * if running is true.\r\n         */\r\n        this.endTime = new Date();\r\n        this.id = BackoffTimeout.getNextId();\r\n        if (options) {\r\n            if (options.initialDelay) {\r\n                this.initialDelay = options.initialDelay;\r\n            }\r\n            if (options.multiplier) {\r\n                this.multiplier = options.multiplier;\r\n            }\r\n            if (options.jitter) {\r\n                this.jitter = options.jitter;\r\n            }\r\n            if (options.maxDelay) {\r\n                this.maxDelay = options.maxDelay;\r\n            }\r\n        }\r\n        this.trace('constructed initialDelay=' + this.initialDelay + ' multiplier=' + this.multiplier + ' jitter=' + this.jitter + ' maxDelay=' + this.maxDelay);\r\n        this.nextDelay = this.initialDelay;\r\n        this.timerId = setTimeout(() => { }, 0);\r\n        clearTimeout(this.timerId);\r\n    }\r\n    static getNextId() {\r\n        return this.nextId++;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '{' + this.id + '} ' + text);\r\n    }\r\n    runTimer(delay) {\r\n        var _a, _b;\r\n        this.trace('runTimer(delay=' + delay + ')');\r\n        this.endTime = this.startTime;\r\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + delay);\r\n        clearTimeout(this.timerId);\r\n        this.timerId = setTimeout(() => {\r\n            this.trace('timer fired');\r\n            this.running = false;\r\n            this.callback();\r\n        }, delay);\r\n        if (!this.hasRef) {\r\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    }\r\n    /**\r\n     * Call the callback after the current amount of delay time\r\n     */\r\n    runOnce() {\r\n        this.trace('runOnce()');\r\n        this.running = true;\r\n        this.startTime = new Date();\r\n        this.runTimer(this.nextDelay);\r\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\r\n        const jitterMagnitude = nextBackoff * this.jitter;\r\n        this.nextDelay =\r\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\r\n    }\r\n    /**\r\n     * Stop the timer. The callback will not be called until `runOnce` is called\r\n     * again.\r\n     */\r\n    stop() {\r\n        this.trace('stop()');\r\n        clearTimeout(this.timerId);\r\n        this.running = false;\r\n    }\r\n    /**\r\n     * Reset the delay time to its initial value. If the timer is still running,\r\n     * retroactively apply that reset to the current timer.\r\n     */\r\n    reset() {\r\n        this.trace('reset() running=' + this.running);\r\n        this.nextDelay = this.initialDelay;\r\n        if (this.running) {\r\n            const now = new Date();\r\n            const newEndTime = this.startTime;\r\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\r\n            clearTimeout(this.timerId);\r\n            if (now < newEndTime) {\r\n                this.runTimer(newEndTime.getTime() - now.getTime());\r\n            }\r\n            else {\r\n                this.running = false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check whether the timer is currently running.\r\n     */\r\n    isRunning() {\r\n        return this.running;\r\n    }\r\n    /**\r\n     * Set that while the timer is running, it should keep the Node process\r\n     * running.\r\n     */\r\n    ref() {\r\n        var _a, _b;\r\n        this.hasRef = true;\r\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    /**\r\n     * Set that while the timer is running, it should not keep the Node process\r\n     * running.\r\n     */\r\n    unref() {\r\n        var _a, _b;\r\n        this.hasRef = false;\r\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    /**\r\n     * Get the approximate timestamp of when the timer will fire. Only valid if\r\n     * this.isRunning() is true.\r\n     */\r\n    getEndTime() {\r\n        return this.endTime;\r\n    }\r\n}\r\nexports.BackoffTimeout = BackoffTimeout;\r\nBackoffTimeout.nextId = 0;\r\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzPzk3ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSB2b2lkIDA7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAnYmFja29mZic7XHJcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XHJcbmNvbnN0IEJBQ0tPRkZfTVVMVElQTElFUiA9IDEuNjtcclxuY29uc3QgTUFYX0JBQ0tPRkZfTVMgPSAxMjAwMDA7XHJcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xyXG4vKipcclxuICogR2V0IGEgbnVtYmVyIHVuaWZvcm1seSBhdCByYW5kb20gaW4gdGhlIHJhbmdlIFttaW4sIG1heClcclxuICogQHBhcmFtIG1pblxyXG4gKiBAcGFyYW0gbWF4XHJcbiAqL1xyXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG59XHJcbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkZWxheSB0aW1lIGF0IHRoZSBzdGFydCwgYW5kIGFmdGVyIGVhY2ggcmVzZXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGV4cG9uZW50aWFsIGJhY2tvZmYgbXVsdGlwbGllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBCQUNLT0ZGX01VTFRJUExJRVI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4RGVsYXkgPSBNQVhfQkFDS09GRl9NUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWF4aW11bSBmcmFjdGlvbiBieSB3aGljaCB0aGUgZGVsYXkgdGltZSBjYW4gcmFuZG9tbHkgdmFyeSBhZnRlclxyXG4gICAgICAgICAqIGFwcGx5aW5nIHRoZSBtdWx0aXBsaWVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaml0dGVyID0gQkFDS09GRl9KSVRURVI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzIHJ1bm5pbmcgaWYgbm9cclxuICAgICAgICAgKiBvdGhlciBhc3luYyBvcGVyYXRpb24gaXMgZG9pbmcgc28uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXHJcbiAgICAgICAgICogcnVubmluZyBpcyB0cnVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYXBwcm94aW1hdGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3aWxsIGVuZC4gT25seSB2YWxpZFxyXG4gICAgICAgICAqIGlmIHJ1bm5pbmcgaXMgdHJ1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaWQgPSBCYWNrb2ZmVGltZW91dC5nZXROZXh0SWQoKTtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsRGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGllcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmppdHRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnY29uc3RydWN0ZWQgaW5pdGlhbERlbGF5PScgKyB0aGlzLmluaXRpYWxEZWxheSArICcgbXVsdGlwbGllcj0nICsgdGhpcy5tdWx0aXBsaWVyICsgJyBqaXR0ZXI9JyArIHRoaXMuaml0dGVyICsgJyBtYXhEZWxheT0nICsgdGhpcy5tYXhEZWxheSk7XHJcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0TmV4dElkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJZCsrO1xyXG4gICAgfVxyXG4gICAgdHJhY2UodGV4dCkge1xyXG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ3snICsgdGhpcy5pZCArICd9ICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIHJ1blRpbWVyKGRlbGF5KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLnRyYWNlKCdydW5UaW1lcihkZWxheT0nICsgZGVsYXkgKyAnKScpO1xyXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgICAgIHRoaXMuZW5kVGltZS5zZXRNaWxsaXNlY29uZHModGhpcy5lbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgZGVsYXkpO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xyXG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd0aW1lciBmaXJlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xyXG4gICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVmKSB7XHJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXHJcbiAgICAgKi9cclxuICAgIHJ1bk9uY2UoKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgncnVuT25jZSgpJyk7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5ydW5UaW1lcih0aGlzLm5leHREZWxheSk7XHJcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLm5leHREZWxheSAqIHRoaXMubXVsdGlwbGllciwgdGhpcy5tYXhEZWxheSk7XHJcbiAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gbmV4dEJhY2tvZmYgKiB0aGlzLmppdHRlcjtcclxuICAgICAgICB0aGlzLm5leHREZWxheSA9XHJcbiAgICAgICAgICAgIG5leHRCYWNrb2ZmICsgdW5pZm9ybVJhbmRvbSgtaml0dGVyTWFnbml0dWRlLCBqaXR0ZXJNYWduaXR1ZGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSB0aW1lci4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB1bnRpbCBgcnVuT25jZWAgaXMgY2FsbGVkXHJcbiAgICAgKiBhZ2Fpbi5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdzdG9wKCknKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRlbGF5IHRpbWUgdG8gaXRzIGluaXRpYWwgdmFsdWUuIElmIHRoZSB0aW1lciBpcyBzdGlsbCBydW5uaW5nLFxyXG4gICAgICogcmV0cm9hY3RpdmVseSBhcHBseSB0aGF0IHJlc2V0IHRvIHRoZSBjdXJyZW50IHRpbWVyLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdyZXNldCgpIHJ1bm5pbmc9JyArIHRoaXMucnVubmluZyk7XHJcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcclxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcclxuICAgICAgICAgICAgbmV3RW5kVGltZS5zZXRNaWxsaXNlY29uZHMobmV3RW5kVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMubmV4dERlbGF5KTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICAgICAgICAgIGlmIChub3cgPCBuZXdFbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVyKG5ld0VuZFRpbWUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXHJcbiAgICAgKi9cclxuICAgIGlzUnVubmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xyXG4gICAgICogcnVubmluZy5cclxuICAgICAqL1xyXG4gICAgcmVmKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQgbm90IGtlZXAgdGhlIE5vZGUgcHJvY2Vzc1xyXG4gICAgICogcnVubmluZy5cclxuICAgICAqL1xyXG4gICAgdW5yZWYoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLmhhc1JlZiA9IGZhbHNlO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXJJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhcHByb3hpbWF0ZSB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgdGltZXIgd2lsbCBmaXJlLiBPbmx5IHZhbGlkIGlmXHJcbiAgICAgKiB0aGlzLmlzUnVubmluZygpIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldEVuZFRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kVGltZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gQmFja29mZlRpbWVvdXQ7XHJcbkJhY2tvZmZUaW1lb3V0Lm5leHRJZCA9IDA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CallCredentials = void 0;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nfunction isCurrentOauth2Client(client) {\r\n    return ('getRequestHeaders' in client &&\r\n        typeof client.getRequestHeaders === 'function');\r\n}\r\n/**\r\n * A class that represents a generic method of adding authentication-related\r\n * metadata on a per-request basis.\r\n */\r\nclass CallCredentials {\r\n    /**\r\n     * Creates a new CallCredentials object from a given function that generates\r\n     * Metadata objects.\r\n     * @param metadataGenerator A function that accepts a set of options, and\r\n     * generates a Metadata object based on these options, which is passed back\r\n     * to the caller via a supplied (err, metadata) callback.\r\n     */\r\n    static createFromMetadataGenerator(metadataGenerator) {\r\n        return new SingleCallCredentials(metadataGenerator);\r\n    }\r\n    /**\r\n     * Create a gRPC credential from a Google credential object.\r\n     * @param googleCredentials The authentication client to use.\r\n     * @return The resulting CallCredentials object.\r\n     */\r\n    static createFromGoogleCredential(googleCredentials) {\r\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\r\n            let getHeaders;\r\n            if (isCurrentOauth2Client(googleCredentials)) {\r\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\r\n            }\r\n            else {\r\n                getHeaders = new Promise((resolve, reject) => {\r\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\r\n                        if (err) {\r\n                            reject(err);\r\n                            return;\r\n                        }\r\n                        if (!headers) {\r\n                            reject(new Error('Headers not set by metadata plugin'));\r\n                            return;\r\n                        }\r\n                        resolve(headers);\r\n                    });\r\n                });\r\n            }\r\n            getHeaders.then(headers => {\r\n                const metadata = new metadata_1.Metadata();\r\n                for (const key of Object.keys(headers)) {\r\n                    metadata.add(key, headers[key]);\r\n                }\r\n                callback(null, metadata);\r\n            }, err => {\r\n                callback(err);\r\n            });\r\n        });\r\n    }\r\n    static createEmpty() {\r\n        return new EmptyCallCredentials();\r\n    }\r\n}\r\nexports.CallCredentials = CallCredentials;\r\nclass ComposedCallCredentials extends CallCredentials {\r\n    constructor(creds) {\r\n        super();\r\n        this.creds = creds;\r\n    }\r\n    async generateMetadata(options) {\r\n        const base = new metadata_1.Metadata();\r\n        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\r\n        for (const gen of generated) {\r\n            base.merge(gen);\r\n        }\r\n        return base;\r\n    }\r\n    compose(other) {\r\n        return new ComposedCallCredentials(this.creds.concat([other]));\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof ComposedCallCredentials) {\r\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nclass SingleCallCredentials extends CallCredentials {\r\n    constructor(metadataGenerator) {\r\n        super();\r\n        this.metadataGenerator = metadataGenerator;\r\n    }\r\n    generateMetadata(options) {\r\n        return new Promise((resolve, reject) => {\r\n            this.metadataGenerator(options, (err, metadata) => {\r\n                if (metadata !== undefined) {\r\n                    resolve(metadata);\r\n                }\r\n                else {\r\n                    reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    compose(other) {\r\n        return new ComposedCallCredentials([this, other]);\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof SingleCallCredentials) {\r\n            return this.metadataGenerator === other.metadataGenerator;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nclass EmptyCallCredentials extends CallCredentials {\r\n    generateMetadata(options) {\r\n        return Promise.resolve(new metadata_1.Metadata());\r\n    }\r\n    compose(other) {\r\n        return other;\r\n    }\r\n    _equals(other) {\r\n        return other instanceof EmptyCallCredentials;\r\n    }\r\n}\r\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcz9mYjliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IHZvaWQgMDtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5mdW5jdGlvbiBpc0N1cnJlbnRPYXV0aDJDbGllbnQoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gKCdnZXRSZXF1ZXN0SGVhZGVycycgaW4gY2xpZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcclxuICogbWV0YWRhdGEgb24gYSBwZXItcmVxdWVzdCBiYXNpcy5cclxuICovXHJcbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdCBmcm9tIGEgZ2l2ZW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXNcclxuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXHJcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFHZW5lcmF0b3IgQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBzZXQgb2Ygb3B0aW9ucywgYW5kXHJcbiAgICAgKiBnZW5lcmF0ZXMgYSBNZXRhZGF0YSBvYmplY3QgYmFzZWQgb24gdGhlc2Ugb3B0aW9ucywgd2hpY2ggaXMgcGFzc2VkIGJhY2tcclxuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKG1ldGFkYXRhR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBnb29nbGVDcmVkZW50aWFscyBUaGUgYXV0aGVudGljYXRpb24gY2xpZW50IHRvIHVzZS5cclxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwoZ29vZ2xlQ3JlZGVudGlhbHMpIHtcclxuICAgICAgICByZXR1cm4gQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcigob3B0aW9ucywgY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChpc0N1cnJlbnRPYXV0aDJDbGllbnQoZ29vZ2xlQ3JlZGVudGlhbHMpKSB7XHJcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gZ29vZ2xlQ3JlZGVudGlhbHMuZ2V0UmVxdWVzdEhlYWRlcnMob3B0aW9ucy5zZXJ2aWNlX3VybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSGVhZGVycyBub3Qgc2V0IGJ5IG1ldGFkYXRhIHBsdWdpbicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0SGVhZGVycy50aGVuKGhlYWRlcnMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5hZGQoa2V5LCBoZWFkZXJzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUNhbGxDcmVkZW50aWFscygpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gQ2FsbENyZWRlbnRpYWxzO1xyXG5jbGFzcyBDb21wb3NlZENhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jcmVkcyA9IGNyZWRzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XHJcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoY3JlZCA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGdlbiBvZiBnZW5lcmF0ZWQpIHtcclxuICAgICAgICAgICAgYmFzZS5tZXJnZShnZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFzZTtcclxuICAgIH1cclxuICAgIGNvbXBvc2Uob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKHRoaXMuY3JlZHMuY29uY2F0KFtvdGhlcl0pKTtcclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWRzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlLl9lcXVhbHMob3RoZXIuY3JlZHNbaW5kZXhdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YUdlbmVyYXRvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvcihvcHRpb25zLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbXBvc2Uob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xyXG4gICAgfVxyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yID09PSBvdGhlci5tZXRhZGF0YUdlbmVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRW1wdHlDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xyXG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpKTtcclxuICAgIH1cclxuICAgIGNvbXBvc2Uob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICB9XHJcbiAgICBfZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRW1wdHlDYWxsQ3JlZGVudGlhbHM7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InterceptingListenerImpl = void 0;\r\nexports.isInterceptingListener = isInterceptingListener;\r\nfunction isInterceptingListener(listener) {\r\n    return (listener.onReceiveMetadata !== undefined &&\r\n        listener.onReceiveMetadata.length === 1);\r\n}\r\nclass InterceptingListenerImpl {\r\n    constructor(listener, nextListener) {\r\n        this.listener = listener;\r\n        this.nextListener = nextListener;\r\n        this.processingMetadata = false;\r\n        this.hasPendingMessage = false;\r\n        this.processingMessage = false;\r\n        this.pendingStatus = null;\r\n    }\r\n    processPendingMessage() {\r\n        if (this.hasPendingMessage) {\r\n            this.nextListener.onReceiveMessage(this.pendingMessage);\r\n            this.pendingMessage = null;\r\n            this.hasPendingMessage = false;\r\n        }\r\n    }\r\n    processPendingStatus() {\r\n        if (this.pendingStatus) {\r\n            this.nextListener.onReceiveStatus(this.pendingStatus);\r\n        }\r\n    }\r\n    onReceiveMetadata(metadata) {\r\n        this.processingMetadata = true;\r\n        this.listener.onReceiveMetadata(metadata, metadata => {\r\n            this.processingMetadata = false;\r\n            this.nextListener.onReceiveMetadata(metadata);\r\n            this.processPendingMessage();\r\n            this.processPendingStatus();\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    onReceiveMessage(message) {\r\n        /* If this listener processes messages asynchronously, the last message may\r\n         * be reordered with respect to the status */\r\n        this.processingMessage = true;\r\n        this.listener.onReceiveMessage(message, msg => {\r\n            this.processingMessage = false;\r\n            if (this.processingMetadata) {\r\n                this.pendingMessage = msg;\r\n                this.hasPendingMessage = true;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveMessage(msg);\r\n                this.processPendingStatus();\r\n            }\r\n        });\r\n    }\r\n    onReceiveStatus(status) {\r\n        this.listener.onReceiveStatus(status, processedStatus => {\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.pendingStatus = processedStatus;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveStatus(processedStatus);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\r\n//# sourceMappingURL=call-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanM/OWY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSB2b2lkIDA7XHJcbmV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGlzSW50ZXJjZXB0aW5nTGlzdGVuZXI7XHJcbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgIHJldHVybiAobGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XHJcbn1cclxuY2xhc3MgSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVyLCBuZXh0TGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzUGVuZGluZ1N0YXR1cygpIHtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEsIG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgLyogSWYgdGhpcyBsaXN0ZW5lciBwcm9jZXNzZXMgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHksIHRoZSBsYXN0IG1lc3NhZ2UgbWF5XHJcbiAgICAgICAgICogYmUgcmVvcmRlcmVkIHdpdGggcmVzcGVjdCB0byB0aGUgc3RhdHVzICovXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIG1zZyA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbXNnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMsIHByb2Nlc3NlZFN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBwcm9jZXNzZWRTdGF0dXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMocHJvY2Vzc2VkU3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getNextCallNumber = getNextCallNumber;\r\nlet nextCallNumber = 0;\r\nfunction getNextCallNumber() {\r\n    return nextCallNumber++;\r\n}\r\n//# sourceMappingURL=call-number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLW51bWJlci5qcz9hZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmdldE5leHRDYWxsTnVtYmVyID0gZ2V0TmV4dENhbGxOdW1iZXI7XHJcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XHJcbmZ1bmN0aW9uIGdldE5leHRDYWxsTnVtYmVyKCkge1xyXG4gICAgcmV0dXJuIG5leHRDYWxsTnVtYmVyKys7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = void 0;\r\nexports.callErrorFromStatus = callErrorFromStatus;\r\nconst events_1 = __webpack_require__(/*! events */ \"events\");\r\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\n/**\r\n * Construct a ServiceError from a StatusObject. This function exists primarily\r\n * as an attempt to make the error stack trace clearly communicate that the\r\n * error is not necessarily a problem in gRPC itself.\r\n * @param status\r\n */\r\nfunction callErrorFromStatus(status, callerStack) {\r\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\r\n    const error = new Error(message);\r\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\r\n    return Object.assign(new Error(message), status, { stack });\r\n}\r\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n}\r\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\r\nclass ClientReadableStreamImpl extends stream_1.Readable {\r\n    constructor(deserialize) {\r\n        super({ objectMode: true });\r\n        this.deserialize = deserialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _read(_size) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\r\n    }\r\n}\r\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\r\nclass ClientWritableStreamImpl extends stream_1.Writable {\r\n    constructor(serialize) {\r\n        super({ objectMode: true });\r\n        this.serialize = serialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _write(chunk, encoding, cb) {\r\n        var _a;\r\n        const context = {\r\n            callback: cb,\r\n        };\r\n        const flags = Number(encoding);\r\n        if (!Number.isNaN(flags)) {\r\n            context.flags = flags;\r\n        }\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\r\n    }\r\n    _final(cb) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\r\n        cb();\r\n    }\r\n}\r\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\r\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\r\n    constructor(serialize, deserialize) {\r\n        super({ objectMode: true });\r\n        this.serialize = serialize;\r\n        this.deserialize = deserialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _read(_size) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\r\n    }\r\n    _write(chunk, encoding, cb) {\r\n        var _a;\r\n        const context = {\r\n            callback: cb,\r\n        };\r\n        const flags = Number(encoding);\r\n        if (!Number.isNaN(flags)) {\r\n            context.flags = flags;\r\n        }\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\r\n    }\r\n    _final(cb) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\r\n        cb();\r\n    }\r\n}\r\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\r\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQjtBQUNsSSwyQkFBMkI7QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxFQUFFLGdDQUFnQyxJQUFJLGVBQWU7QUFDekY7QUFDQSxxQkFBcUIsWUFBWSxpQkFBaUIsWUFBWTtBQUM5RCx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzPzE0OTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSB2b2lkIDA7XHJcbmV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IGNhbGxFcnJvckZyb21TdGF0dXM7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhIFNlcnZpY2VFcnJvciBmcm9tIGEgU3RhdHVzT2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBwcmltYXJpbHlcclxuICogYXMgYW4gYXR0ZW1wdCB0byBtYWtlIHRoZSBlcnJvciBzdGFjayB0cmFjZSBjbGVhcmx5IGNvbW11bmljYXRlIHRoYXQgdGhlXHJcbiAqIGVycm9yIGlzIG5vdCBuZWNlc3NhcmlseSBhIHByb2JsZW0gaW4gZ1JQQyBpdHNlbGYuXHJcbiAqIEBwYXJhbSBzdGF0dXNcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IGAke3N0YXR1cy5jb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tzdGF0dXMuY29kZV19OiAke3N0YXR1cy5kZXRhaWxzfWA7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIGNvbnN0IHN0YWNrID0gYCR7ZXJyb3Iuc3RhY2t9XFxuZm9yIGNhbGwgYXRcXG4ke2NhbGxlclN0YWNrfWA7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IobWVzc2FnZSksIHN0YXR1cywgeyBzdGFjayB9KTtcclxufVxyXG5jbGFzcyBDbGllbnRVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gQ2xpZW50VW5hcnlDYWxsSW1wbDtcclxuY2xhc3MgQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xyXG4gICAgY29uc3RydWN0b3IoZGVzZXJpYWxpemUpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xyXG4gICAgfVxyXG4gICAgX3JlYWQoX3NpemUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGw7XHJcbmNsYXNzIENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSkge1xyXG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcclxuICAgIH1cclxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcclxuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcclxuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcclxuICAgIH1cclxuICAgIF9maW5hbChjYikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcclxuICAgICAgICBjYigpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsO1xyXG5jbGFzcyBDbGllbnREdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xyXG4gICAgfVxyXG4gICAgX3JlYWQoX3NpemUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XHJcbiAgICB9XHJcbiAgICBfZmluYWwoY2IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgY2IoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBDbGllbnREdXBsZXhTdHJlYW1JbXBsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/certificate-provider.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2024 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FileWatcherCertificateProvider = void 0;\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst util_1 = __webpack_require__(/*! util */ \"util\");\r\nconst TRACER_NAME = 'certificate_provider';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst readFilePromise = (0, util_1.promisify)(fs.readFile);\r\nclass FileWatcherCertificateProvider {\r\n    constructor(config) {\r\n        this.config = config;\r\n        this.refreshTimer = null;\r\n        this.fileResultPromise = null;\r\n        this.latestCaUpdate = undefined;\r\n        this.caListeners = new Set();\r\n        this.latestIdentityUpdate = undefined;\r\n        this.identityListeners = new Set();\r\n        this.lastUpdateTime = null;\r\n        if ((config.certificateFile === undefined) !== (config.privateKeyFile === undefined)) {\r\n            throw new Error('certificateFile and privateKeyFile must be set or unset together');\r\n        }\r\n        if (config.certificateFile === undefined && config.caCertificateFile === undefined) {\r\n            throw new Error('At least one of certificateFile and caCertificateFile must be set');\r\n        }\r\n        trace('File watcher constructed with config ' + JSON.stringify(config));\r\n    }\r\n    updateCertificates() {\r\n        if (this.fileResultPromise) {\r\n            return;\r\n        }\r\n        this.fileResultPromise = Promise.allSettled([\r\n            this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),\r\n            this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),\r\n            this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()\r\n        ]);\r\n        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {\r\n            if (!this.refreshTimer) {\r\n                return;\r\n            }\r\n            trace('File watcher read certificates certificate ' + certificateResult.status + ', privateKey ' + privateKeyResult.status + ', CA certificate ' + caCertificateResult.status);\r\n            this.lastUpdateTime = new Date();\r\n            this.fileResultPromise = null;\r\n            if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {\r\n                this.latestIdentityUpdate = {\r\n                    certificate: certificateResult.value,\r\n                    privateKey: privateKeyResult.value\r\n                };\r\n            }\r\n            else {\r\n                this.latestIdentityUpdate = null;\r\n            }\r\n            if (caCertificateResult.status === 'fulfilled') {\r\n                this.latestCaUpdate = {\r\n                    caCertificate: caCertificateResult.value\r\n                };\r\n            }\r\n            else {\r\n                this.latestCaUpdate = null;\r\n            }\r\n            for (const listener of this.identityListeners) {\r\n                listener(this.latestIdentityUpdate);\r\n            }\r\n            for (const listener of this.caListeners) {\r\n                listener(this.latestCaUpdate);\r\n            }\r\n        });\r\n        trace('File watcher initiated certificate update');\r\n    }\r\n    maybeStartWatchingFiles() {\r\n        if (!this.refreshTimer) {\r\n            /* Perform the first read immediately, but only if there was not already\r\n             * a recent read, to avoid reading from the filesystem significantly more\r\n             * frequently than configured if the provider quickly switches between\r\n             * used and unused. */\r\n            const timeSinceLastUpdate = this.lastUpdateTime ? (new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;\r\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs) {\r\n                this.updateCertificates();\r\n            }\r\n            if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {\r\n                // Clear out old updates if they are definitely stale\r\n                this.latestCaUpdate = undefined;\r\n                this.latestIdentityUpdate = undefined;\r\n            }\r\n            this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);\r\n            trace('File watcher started watching');\r\n        }\r\n    }\r\n    maybeStopWatchingFiles() {\r\n        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {\r\n            this.fileResultPromise = null;\r\n            if (this.refreshTimer) {\r\n                clearInterval(this.refreshTimer);\r\n                this.refreshTimer = null;\r\n            }\r\n        }\r\n    }\r\n    addCaCertificateListener(listener) {\r\n        this.caListeners.add(listener);\r\n        this.maybeStartWatchingFiles();\r\n        if (this.latestCaUpdate !== undefined) {\r\n            process.nextTick(listener, this.latestCaUpdate);\r\n        }\r\n    }\r\n    removeCaCertificateListener(listener) {\r\n        this.caListeners.delete(listener);\r\n        this.maybeStopWatchingFiles();\r\n    }\r\n    addIdentityCertificateListener(listener) {\r\n        this.identityListeners.add(listener);\r\n        this.maybeStartWatchingFiles();\r\n        if (this.latestIdentityUpdate !== undefined) {\r\n            process.nextTick(listener, this.latestIdentityUpdate);\r\n        }\r\n    }\r\n    removeIdentityCertificateListener(listener) {\r\n        this.identityListeners.delete(listener);\r\n        this.maybeStopWatchingFiles();\r\n    }\r\n}\r\nexports.FileWatcherCertificateProvider = FileWatcherCertificateProvider;\r\n//# sourceMappingURL=certificate-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2VydGlmaWNhdGUtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0M7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jZXJ0aWZpY2F0ZS1wcm92aWRlci5qcz8wNzg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyNCBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlciA9IHZvaWQgMDtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2NlcnRpZmljYXRlX3Byb3ZpZGVyJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5jb25zdCByZWFkRmlsZVByb21pc2UgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnMucmVhZEZpbGUpO1xyXG5jbGFzcyBGaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlsZVJlc3VsdFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jYUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHlMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKChjb25maWcuY2VydGlmaWNhdGVGaWxlID09PSB1bmRlZmluZWQpICE9PSAoY29uZmlnLnByaXZhdGVLZXlGaWxlID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2VydGlmaWNhdGVGaWxlIGFuZCBwcml2YXRlS2V5RmlsZSBtdXN0IGJlIHNldCBvciB1bnNldCB0b2dldGhlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLmNlcnRpZmljYXRlRmlsZSA9PT0gdW5kZWZpbmVkICYmIGNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIG9mIGNlcnRpZmljYXRlRmlsZSBhbmQgY2FDZXJ0aWZpY2F0ZUZpbGUgbXVzdCBiZSBzZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2UoJ0ZpbGUgd2F0Y2hlciBjb25zdHJ1Y3RlZCB3aXRoIGNvbmZpZyAnICsgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDZXJ0aWZpY2F0ZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsZVJlc3VsdFByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGxTZXR0bGVkKFtcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2VydGlmaWNhdGVGaWxlID8gcmVhZEZpbGVQcm9taXNlKHRoaXMuY29uZmlnLmNlcnRpZmljYXRlRmlsZSkgOiBQcm9taXNlLnJlamVjdCgpLFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5wcml2YXRlS2V5RmlsZSA/IHJlYWRGaWxlUHJvbWlzZSh0aGlzLmNvbmZpZy5wcml2YXRlS2V5RmlsZSkgOiBQcm9taXNlLnJlamVjdCgpLFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSA/IHJlYWRGaWxlUHJvbWlzZSh0aGlzLmNvbmZpZy5jYUNlcnRpZmljYXRlRmlsZSkgOiBQcm9taXNlLnJlamVjdCgpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5maWxlUmVzdWx0UHJvbWlzZS50aGVuKChbY2VydGlmaWNhdGVSZXN1bHQsIHByaXZhdGVLZXlSZXN1bHQsIGNhQ2VydGlmaWNhdGVSZXN1bHRdKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZyZXNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjZSgnRmlsZSB3YXRjaGVyIHJlYWQgY2VydGlmaWNhdGVzIGNlcnRpZmljYXRlICcgKyBjZXJ0aWZpY2F0ZVJlc3VsdC5zdGF0dXMgKyAnLCBwcml2YXRlS2V5ICcgKyBwcml2YXRlS2V5UmVzdWx0LnN0YXR1cyArICcsIENBIGNlcnRpZmljYXRlICcgKyBjYUNlcnRpZmljYXRlUmVzdWx0LnN0YXR1cyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVSZXN1bHRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNlcnRpZmljYXRlUmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgcHJpdmF0ZUtleVJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBjZXJ0aWZpY2F0ZVJlc3VsdC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5UmVzdWx0LnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhQ2VydGlmaWNhdGVSZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjYUNlcnRpZmljYXRlOiBjYUNlcnRpZmljYXRlUmVzdWx0LnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmlkZW50aXR5TGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuY2FMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMubGF0ZXN0Q2FVcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJhY2UoJ0ZpbGUgd2F0Y2hlciBpbml0aWF0ZWQgY2VydGlmaWNhdGUgdXBkYXRlJyk7XHJcbiAgICB9XHJcbiAgICBtYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVmcmVzaFRpbWVyKSB7XHJcbiAgICAgICAgICAgIC8qIFBlcmZvcm0gdGhlIGZpcnN0IHJlYWQgaW1tZWRpYXRlbHksIGJ1dCBvbmx5IGlmIHRoZXJlIHdhcyBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICAgKiBhIHJlY2VudCByZWFkLCB0byBhdm9pZCByZWFkaW5nIGZyb20gdGhlIGZpbGVzeXN0ZW0gc2lnbmlmaWNhbnRseSBtb3JlXHJcbiAgICAgICAgICAgICAqIGZyZXF1ZW50bHkgdGhhbiBjb25maWd1cmVkIGlmIHRoZSBwcm92aWRlciBxdWlja2x5IHN3aXRjaGVzIGJldHdlZW5cclxuICAgICAgICAgICAgICogdXNlZCBhbmQgdW51c2VkLiAqL1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0VXBkYXRlID0gdGhpcy5sYXN0VXBkYXRlVGltZSA/IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RVcGRhdGVUaW1lLmdldFRpbWUoKSA6IEluZmluaXR5O1xyXG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdFVwZGF0ZSA+IHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbE1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNlcnRpZmljYXRlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0VXBkYXRlID4gdGhpcy5jb25maWcucmVmcmVzaEludGVydmFsTXMgKiAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBvdXQgb2xkIHVwZGF0ZXMgaWYgdGhleSBhcmUgZGVmaW5pdGVseSBzdGFsZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnVwZGF0ZUNlcnRpZmljYXRlcygpLCB0aGlzLmNvbmZpZy5yZWZyZXNoSW50ZXJ2YWxNcyk7XHJcbiAgICAgICAgICAgIHRyYWNlKCdGaWxlIHdhdGNoZXIgc3RhcnRlZCB3YXRjaGluZycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1heWJlU3RvcFdhdGNoaW5nRmlsZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FMaXN0ZW5lcnMuc2l6ZSA9PT0gMCAmJiB0aGlzLmlkZW50aXR5TGlzdGVuZXJzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlUmVzdWx0UHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlZnJlc2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmNhTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0V2F0Y2hpbmdGaWxlcygpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENhVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaXN0ZW5lciwgdGhpcy5sYXRlc3RDYVVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jYUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMubWF5YmVTdG9wV2F0Y2hpbmdGaWxlcygpO1xyXG4gICAgfVxyXG4gICAgYWRkSWRlbnRpdHlDZXJ0aWZpY2F0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMubWF5YmVTdGFydFdhdGNoaW5nRmlsZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGlzdGVuZXIsIHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUlkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHlMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLm1heWJlU3RvcFdhdGNoaW5nRmlsZXMoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlciA9IEZpbGVXYXRjaGVyQ2VydGlmaWNhdGVQcm92aWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2VydGlmaWNhdGUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChannelCredentials = void 0;\r\nexports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;\r\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\r\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\r\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction verifyIsBufferOrNull(obj, friendlyName) {\r\n    if (obj && !(obj instanceof Buffer)) {\r\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\r\n    }\r\n}\r\n/**\r\n * A class that contains credentials for communicating over a channel, as well\r\n * as a set of per-call credentials, which are applied to every method call made\r\n * over a channel initialized with an instance of this class.\r\n */\r\nclass ChannelCredentials {\r\n    /**\r\n     * Returns a copy of this object with the included set of per-call credentials\r\n     * expanded to include callCredentials.\r\n     * @param callCredentials A CallCredentials object to associate with this\r\n     * instance.\r\n     */\r\n    compose(callCredentials) {\r\n        return new ComposedChannelCredentialsImpl(this, callCredentials);\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with a given set of credentials.\r\n     * The resulting instance can be used to construct a Channel that communicates\r\n     * over TLS.\r\n     * @param rootCerts The root certificate data.\r\n     * @param privateKey The client certificate private key, if available.\r\n     * @param certChain The client certificate key chain, if available.\r\n     * @param verifyOptions Additional options to modify certificate verification\r\n     */\r\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\r\n        var _a;\r\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\r\n        verifyIsBufferOrNull(privateKey, 'Private key');\r\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\r\n        if (privateKey && !certChain) {\r\n            throw new Error('Private key must be given with accompanying certificate chain');\r\n        }\r\n        if (!privateKey && certChain) {\r\n            throw new Error('Certificate chain must be given with accompanying private key');\r\n        }\r\n        const secureContext = (0, tls_1.createSecureContext)({\r\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\r\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\r\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\r\n            ciphers: tls_helpers_1.CIPHER_SUITES,\r\n        });\r\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with credentials created using\r\n     * the provided secureContext. The resulting instances can be used to\r\n     * construct a Channel that communicates over TLS. gRPC will not override\r\n     * anything in the provided secureContext, so the environment variables\r\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\r\n     * not be applied.\r\n     * @param secureContext The return value of tls.createSecureContext()\r\n     * @param verifyOptions Additional options to modify certificate verification\r\n     */\r\n    static createFromSecureContext(secureContext, verifyOptions) {\r\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with no credentials.\r\n     */\r\n    static createInsecure() {\r\n        return new InsecureChannelCredentialsImpl();\r\n    }\r\n}\r\nexports.ChannelCredentials = ChannelCredentials;\r\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor() {\r\n        super();\r\n    }\r\n    compose(callCredentials) {\r\n        throw new Error('Cannot compose insecure credentials');\r\n    }\r\n    _isSecure() {\r\n        return false;\r\n    }\r\n    _equals(other) {\r\n        return other instanceof InsecureChannelCredentialsImpl;\r\n    }\r\n    _createSecureConnector(channelTarget, options, callCredentials) {\r\n        return {\r\n            connect(socket) {\r\n                return Promise.resolve({\r\n                    socket,\r\n                    secure: false\r\n                });\r\n            },\r\n            waitForReady: () => {\r\n                return Promise.resolve();\r\n            },\r\n            getCallCredentials: () => {\r\n                return callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty();\r\n            },\r\n            destroy() { }\r\n        };\r\n    }\r\n}\r\nfunction getConnectionOptions(secureContext, verifyOptions, channelTarget, options) {\r\n    var _a, _b, _c, _d;\r\n    const connectionOptions = {\r\n        secureContext: secureContext\r\n    };\r\n    if (verifyOptions.checkServerIdentity) {\r\n        connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\r\n    }\r\n    if (verifyOptions.rejectUnauthorized !== undefined) {\r\n        connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;\r\n    }\r\n    connectionOptions.ALPNProtocols = ['h2'];\r\n    if (options['grpc.ssl_target_name_override']) {\r\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\r\n        const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;\r\n        connectionOptions.checkServerIdentity = (host, cert) => {\r\n            return originalCheckServerIdentity(sslTargetNameOverride, cert);\r\n        };\r\n        connectionOptions.servername = sslTargetNameOverride;\r\n    }\r\n    else {\r\n        if ('grpc.http_connect_target' in options) {\r\n            /* This is more or less how servername will be set in createSession\r\n             * if a connection is successfully established through the proxy.\r\n             * If the proxy is not used, these connectionOptions are discarded\r\n             * anyway */\r\n            const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== void 0 ? _b : {\r\n                path: 'localhost',\r\n            });\r\n            const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\r\n            connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;\r\n        }\r\n    }\r\n    if (options['grpc-node.tls_enable_trace']) {\r\n        connectionOptions.enableTrace = true;\r\n    }\r\n    let realTarget = channelTarget;\r\n    if ('grpc.http_connect_target' in options) {\r\n        const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\r\n        if (parsedTarget) {\r\n            realTarget = parsedTarget;\r\n        }\r\n    }\r\n    const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\r\n    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\r\n    const remoteHost = (_d = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _d !== void 0 ? _d : targetPath;\r\n    connectionOptions.host = remoteHost;\r\n    connectionOptions.servername = remoteHost;\r\n    return connectionOptions;\r\n}\r\nclass SecureConnectorImpl {\r\n    constructor(connectionOptions, callCredentials) {\r\n        this.connectionOptions = connectionOptions;\r\n        this.callCredentials = callCredentials;\r\n    }\r\n    connect(socket) {\r\n        const tlsConnectOptions = Object.assign({ socket: socket }, this.connectionOptions);\r\n        return new Promise((resolve, reject) => {\r\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\r\n                var _a;\r\n                if (((_a = this.connectionOptions.rejectUnauthorized) !== null && _a !== void 0 ? _a : true) && !tlsSocket.authorized) {\r\n                    reject(tlsSocket.authorizationError);\r\n                    return;\r\n                }\r\n                resolve({\r\n                    socket: tlsSocket,\r\n                    secure: true\r\n                });\r\n            });\r\n            tlsSocket.on('error', (error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    waitForReady() {\r\n        return Promise.resolve();\r\n    }\r\n    getCallCredentials() {\r\n        return this.callCredentials;\r\n    }\r\n    destroy() { }\r\n}\r\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(secureContext, verifyOptions) {\r\n        super();\r\n        this.secureContext = secureContext;\r\n        this.verifyOptions = verifyOptions;\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof SecureChannelCredentialsImpl) {\r\n            return (this.secureContext === other.secureContext &&\r\n                this.verifyOptions.checkServerIdentity ===\r\n                    other.verifyOptions.checkServerIdentity);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    _createSecureConnector(channelTarget, options, callCredentials) {\r\n        const connectionOptions = getConnectionOptions(this.secureContext, this.verifyOptions, channelTarget, options);\r\n        return new SecureConnectorImpl(connectionOptions, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\r\n    }\r\n}\r\nclass CertificateProviderChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {\r\n        super();\r\n        this.caCertificateProvider = caCertificateProvider;\r\n        this.identityCertificateProvider = identityCertificateProvider;\r\n        this.verifyOptions = verifyOptions;\r\n        this.refcount = 0;\r\n        /**\r\n         * `undefined` means that the certificates have not yet been loaded. `null`\r\n         * means that an attempt to load them has completed, and has failed.\r\n         */\r\n        this.latestCaUpdate = undefined;\r\n        /**\r\n         * `undefined` means that the certificates have not yet been loaded. `null`\r\n         * means that an attempt to load them has completed, and has failed.\r\n         */\r\n        this.latestIdentityUpdate = undefined;\r\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\r\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\r\n        this.secureContextWatchers = [];\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _equals(other) {\r\n        var _a, _b;\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof CertificateProviderChannelCredentialsImpl) {\r\n            return this.caCertificateProvider === other.caCertificateProvider &&\r\n                this.identityCertificateProvider === other.identityCertificateProvider &&\r\n                ((_a = this.verifyOptions) === null || _a === void 0 ? void 0 : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === void 0 ? void 0 : _b.checkServerIdentity);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    ref() {\r\n        var _a;\r\n        if (this.refcount === 0) {\r\n            this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);\r\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);\r\n        }\r\n        this.refcount += 1;\r\n    }\r\n    unref() {\r\n        var _a;\r\n        this.refcount -= 1;\r\n        if (this.refcount === 0) {\r\n            this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);\r\n            (_a = this.identityCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\r\n        }\r\n    }\r\n    _createSecureConnector(channelTarget, options, callCredentials) {\r\n        this.ref();\r\n        return new CertificateProviderChannelCredentialsImpl.SecureConnectorImpl(this, channelTarget, options, callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\r\n    }\r\n    maybeUpdateWatchers() {\r\n        if (this.hasReceivedUpdates()) {\r\n            for (const watcher of this.secureContextWatchers) {\r\n                watcher(this.getLatestSecureContext());\r\n            }\r\n            this.secureContextWatchers = [];\r\n        }\r\n    }\r\n    handleCaCertificateUpdate(update) {\r\n        this.latestCaUpdate = update;\r\n        this.maybeUpdateWatchers();\r\n    }\r\n    handleIdentityCertitificateUpdate(update) {\r\n        this.latestIdentityUpdate = update;\r\n        this.maybeUpdateWatchers();\r\n    }\r\n    hasReceivedUpdates() {\r\n        if (this.latestCaUpdate === undefined) {\r\n            return false;\r\n        }\r\n        if (this.identityCertificateProvider && this.latestIdentityUpdate === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getSecureContext() {\r\n        if (this.hasReceivedUpdates()) {\r\n            return Promise.resolve(this.getLatestSecureContext());\r\n        }\r\n        else {\r\n            return new Promise(resolve => {\r\n                this.secureContextWatchers.push(resolve);\r\n            });\r\n        }\r\n    }\r\n    getLatestSecureContext() {\r\n        var _a, _b;\r\n        if (!this.latestCaUpdate) {\r\n            return null;\r\n        }\r\n        if (this.identityCertificateProvider !== null && !this.latestIdentityUpdate) {\r\n            return null;\r\n        }\r\n        try {\r\n            return (0, tls_1.createSecureContext)({\r\n                ca: this.latestCaUpdate.caCertificate,\r\n                key: (_a = this.latestIdentityUpdate) === null || _a === void 0 ? void 0 : _a.privateKey,\r\n                cert: (_b = this.latestIdentityUpdate) === null || _b === void 0 ? void 0 : _b.certificate,\r\n                ciphers: tls_helpers_1.CIPHER_SUITES\r\n            });\r\n        }\r\n        catch (e) {\r\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to createSecureContext with error ' + e.message);\r\n            return null;\r\n        }\r\n    }\r\n}\r\nCertificateProviderChannelCredentialsImpl.SecureConnectorImpl = class {\r\n    constructor(parent, channelTarget, options, callCredentials) {\r\n        this.parent = parent;\r\n        this.channelTarget = channelTarget;\r\n        this.options = options;\r\n        this.callCredentials = callCredentials;\r\n    }\r\n    connect(socket) {\r\n        return new Promise((resolve, reject) => {\r\n            const secureContext = this.parent.getLatestSecureContext();\r\n            if (!secureContext) {\r\n                reject(new Error('Failed to load credentials'));\r\n                return;\r\n            }\r\n            if (socket.closed) {\r\n                reject(new Error('Socket closed while loading credentials'));\r\n            }\r\n            const connnectionOptions = getConnectionOptions(secureContext, this.parent.verifyOptions, this.channelTarget, this.options);\r\n            const tlsConnectOptions = Object.assign({ socket: socket }, connnectionOptions);\r\n            const closeCallback = () => {\r\n                reject(new Error('Socket closed'));\r\n            };\r\n            const errorCallback = (error) => {\r\n                reject(error);\r\n            };\r\n            const tlsSocket = (0, tls_1.connect)(tlsConnectOptions, () => {\r\n                var _a;\r\n                tlsSocket.removeListener('close', closeCallback);\r\n                tlsSocket.removeListener('error', errorCallback);\r\n                if (((_a = this.parent.verifyOptions.rejectUnauthorized) !== null && _a !== void 0 ? _a : true) && !tlsSocket.authorized) {\r\n                    reject(tlsSocket.authorizationError);\r\n                    return;\r\n                }\r\n                resolve({\r\n                    socket: tlsSocket,\r\n                    secure: true\r\n                });\r\n            });\r\n            tlsSocket.once('close', closeCallback);\r\n            tlsSocket.once('error', errorCallback);\r\n        });\r\n    }\r\n    async waitForReady() {\r\n        await this.parent.getSecureContext();\r\n    }\r\n    getCallCredentials() {\r\n        return this.callCredentials;\r\n    }\r\n    destroy() {\r\n        this.parent.unref();\r\n    }\r\n};\r\nfunction createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {\r\n    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\r\n}\r\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(channelCredentials, callCredentials) {\r\n        super();\r\n        this.channelCredentials = channelCredentials;\r\n        this.callCredentials = callCredentials;\r\n        if (!channelCredentials._isSecure()) {\r\n            throw new Error('Cannot compose insecure credentials');\r\n        }\r\n    }\r\n    compose(callCredentials) {\r\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\r\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof ComposedChannelCredentialsImpl) {\r\n            return (this.channelCredentials._equals(other.channelCredentials) &&\r\n                this.callCredentials._equals(other.callCredentials));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    _createSecureConnector(channelTarget, options, callCredentials) {\r\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials !== null && callCredentials !== void 0 ? callCredentials : call_credentials_1.CallCredentials.createEmpty());\r\n        return this.channelCredentials._createSecureConnector(channelTarget, options, combinedCallCredentials);\r\n    }\r\n}\r\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixtREFBbUQ7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDJCQUEyQixtQkFBTyxDQUFDLDRGQUFvQjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0xBQW9MO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcz82YjBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IHZvaWQgMDtcclxuZXhwb3J0cy5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzID0gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscztcclxuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xyXG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xyXG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XHJcbiAgICBpZiAob2JqICYmICEob2JqIGluc3RhbmNlb2YgQnVmZmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZnJpZW5kbHlOYW1lfSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBCdWZmZXIuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxyXG4gKiBhcyBhIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscywgd2hpY2ggYXJlIGFwcGxpZWQgdG8gZXZlcnkgbWV0aG9kIGNhbGwgbWFkZVxyXG4gKiBvdmVyIGEgY2hhbm5lbCBpbml0aWFsaXplZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5jbGFzcyBDaGFubmVsQ3JlZGVudGlhbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIG9iamVjdCB3aXRoIHRoZSBpbmNsdWRlZCBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHNcclxuICAgICAqIGV4cGFuZGVkIHRvIGluY2x1ZGUgY2FsbENyZWRlbnRpYWxzLlxyXG4gICAgICogQHBhcmFtIGNhbGxDcmVkZW50aWFscyBBIENhbGxDcmVkZW50aWFscyBvYmplY3QgdG8gYXNzb2NpYXRlIHdpdGggdGhpc1xyXG4gICAgICogaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY2FsbENyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWxzLlxyXG4gICAgICogVGhlIHJlc3VsdGluZyBpbnN0YW5jZSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzXHJcbiAgICAgKiBvdmVyIFRMUy5cclxuICAgICAqIEBwYXJhbSByb290Q2VydHMgVGhlIHJvb3QgY2VydGlmaWNhdGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBjbGllbnQgY2VydGlmaWNhdGUgcHJpdmF0ZSBrZXksIGlmIGF2YWlsYWJsZS5cclxuICAgICAqIEBwYXJhbSBjZXJ0Q2hhaW4gVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBrZXkgY2hhaW4sIGlmIGF2YWlsYWJsZS5cclxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBwcml2YXRlS2V5LCBjZXJ0Q2hhaW4sIHZlcmlmeU9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocm9vdENlcnRzLCAnUm9vdCBjZXJ0aWZpY2F0ZScpO1xyXG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHByaXZhdGVLZXksICdQcml2YXRlIGtleScpO1xyXG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKGNlcnRDaGFpbiwgJ0NlcnRpZmljYXRlIGNoYWluJyk7XHJcbiAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgIWNlcnRDaGFpbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgY2VydGlmaWNhdGUgY2hhaW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcml2YXRlS2V5ICYmIGNlcnRDaGFpbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNoYWluIG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgcHJpdmF0ZSBrZXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9ICgwLCB0bHNfMS5jcmVhdGVTZWN1cmVDb250ZXh0KSh7XHJcbiAgICAgICAgICAgIGNhOiAoX2EgPSByb290Q2VydHMgIT09IG51bGwgJiYgcm9vdENlcnRzICE9PSB2b2lkIDAgPyByb290Q2VydHMgOiAoMCwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5ICE9PSB2b2lkIDAgPyBwcml2YXRlS2V5IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjZXJ0OiBjZXJ0Q2hhaW4gIT09IG51bGwgJiYgY2VydENoYWluICE9PSB2b2lkIDAgPyBjZXJ0Q2hhaW4gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggY3JlZGVudGlhbHMgY3JlYXRlZCB1c2luZ1xyXG4gICAgICogdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQuIFRoZSByZXN1bHRpbmcgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgKiBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzIG92ZXIgVExTLiBnUlBDIHdpbGwgbm90IG92ZXJyaWRlXHJcbiAgICAgKiBhbnl0aGluZyBpbiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dCwgc28gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG4gICAgICogR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyBhbmQgR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEggd2lsbFxyXG4gICAgICogbm90IGJlIGFwcGxpZWQuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJlQ29udGV4dCBUaGUgcmV0dXJuIHZhbHVlIG9mIHRscy5jcmVhdGVTZWN1cmVDb250ZXh0KClcclxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIG5vIGNyZWRlbnRpYWxzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IENoYW5uZWxDcmVkZW50aWFscztcclxuY2xhc3MgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBvc2UgaW5zZWN1cmUgY3JlZGVudGlhbHMnKTtcclxuICAgIH1cclxuICAgIF9pc1NlY3VyZSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVNlY3VyZUNvbm5lY3RvcihjaGFubmVsVGFyZ2V0LCBvcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb25uZWN0KHNvY2tldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3YWl0Rm9yUmVhZHk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0Q2FsbENyZWRlbnRpYWxzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZXN0cm95KCkgeyB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uT3B0aW9ucyhzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zLCBjaGFubmVsVGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uT3B0aW9ucyA9IHtcclxuICAgICAgICBzZWN1cmVDb250ZXh0OiBzZWN1cmVDb250ZXh0XHJcbiAgICB9O1xyXG4gICAgaWYgKHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xyXG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSB2ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBpZiAodmVyaWZ5T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IHZlcmlmeU9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkO1xyXG4gICAgfVxyXG4gICAgY29ubmVjdGlvbk9wdGlvbnMuQUxQTlByb3RvY29scyA9IFsnaDInXTtcclxuICAgIGlmIChvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XHJcbiAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbENoZWNrU2VydmVySWRlbnRpdHkgPSAoX2EgPSBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0bHNfMS5jaGVja1NlcnZlcklkZW50aXR5O1xyXG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDaGVja1NlcnZlcklkZW50aXR5KHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyogVGhpcyBpcyBtb3JlIG9yIGxlc3MgaG93IHNlcnZlcm5hbWUgd2lsbCBiZSBzZXQgaW4gY3JlYXRlU2Vzc2lvblxyXG4gICAgICAgICAgICAgKiBpZiBhIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIHRocm91Z2ggdGhlIHByb3h5LlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgcHJveHkgaXMgbm90IHVzZWQsIHRoZXNlIGNvbm5lY3Rpb25PcHRpb25zIGFyZSBkaXNjYXJkZWRcclxuICAgICAgICAgICAgICogYW55d2F5ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KSgoX2IgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShvcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcclxuICAgICAgICAgICAgICAgIHBhdGg6ICdsb2NhbGhvc3QnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldFBhdGgpO1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gKF9jID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRhcmdldFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnNbJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJ10pIHtcclxuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5lbmFibGVUcmFjZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVhbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XHJcbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFRhcmdldCA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKG9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddKTtcclxuICAgICAgICBpZiAocGFyc2VkVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJlYWxUYXJnZXQgPSBwYXJzZWRUYXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKHJlYWxUYXJnZXQpO1xyXG4gICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldFBhdGgpO1xyXG4gICAgY29uc3QgcmVtb3RlSG9zdCA9IChfZCA9IGhvc3RQb3J0ID09PSBudWxsIHx8IGhvc3RQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0UG9ydC5ob3N0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0YXJnZXRQYXRoO1xyXG4gICAgY29ubmVjdGlvbk9wdGlvbnMuaG9zdCA9IHJlbW90ZUhvc3Q7XHJcbiAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gcmVtb3RlSG9zdDtcclxuICAgIHJldHVybiBjb25uZWN0aW9uT3B0aW9ucztcclxufVxyXG5jbGFzcyBTZWN1cmVDb25uZWN0b3JJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25PcHRpb25zLCBjYWxsQ3JlZGVudGlhbHMpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zID0gY29ubmVjdGlvbk9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHM7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KHNvY2tldCkge1xyXG4gICAgICAgIGNvbnN0IHRsc0Nvbm5lY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHNvY2tldDogc29ja2V0IH0sIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9ICgwLCB0bHNfMS5jb25uZWN0KSh0bHNDb25uZWN0T3B0aW9ucywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSkgJiYgIXRsc1NvY2tldC5hdXRob3JpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRsc1NvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGxzU29ja2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0bHNTb2NrZXQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHdhaXRGb3JSZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWxsQ3JlZGVudGlhbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHsgfVxyXG59XHJcbmNsYXNzIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xyXG4gICAgY29uc3RydWN0b3Ioc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0ID0gc2VjdXJlQ29udGV4dDtcclxuICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMgPSB2ZXJpZnlPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VjdXJlQ29udGV4dCA9PT0gb3RoZXIuc2VjdXJlQ29udGV4dCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25PcHRpb25zID0gZ2V0Q29ubmVjdGlvbk9wdGlvbnModGhpcy5zZWN1cmVDb250ZXh0LCB0aGlzLnZlcmlmeU9wdGlvbnMsIGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ29ubmVjdG9ySW1wbChjb25uZWN0aW9uT3B0aW9ucywgY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgdmVyaWZ5T3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgPSBjYUNlcnRpZmljYXRlUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgPSBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zID0gdmVyaWZ5T3B0aW9ucztcclxuICAgICAgICB0aGlzLnJlZmNvdW50ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgdW5kZWZpbmVkYCBtZWFucyB0aGF0IHRoZSBjZXJ0aWZpY2F0ZXMgaGF2ZSBub3QgeWV0IGJlZW4gbG9hZGVkLiBgbnVsbGBcclxuICAgICAgICAgKiBtZWFucyB0aGF0IGFuIGF0dGVtcHQgdG8gbG9hZCB0aGVtIGhhcyBjb21wbGV0ZWQsIGFuZCBoYXMgZmFpbGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2FVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHVuZGVmaW5lZGAgbWVhbnMgdGhhdCB0aGUgY2VydGlmaWNhdGVzIGhhdmUgbm90IHlldCBiZWVuIGxvYWRlZC4gYG51bGxgXHJcbiAgICAgICAgICogbWVhbnMgdGhhdCBhbiBhdHRlbXB0IHRvIGxvYWQgdGhlbSBoYXMgY29tcGxldGVkLCBhbmQgaGFzIGZhaWxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVDYUNlcnRpZmljYXRlVXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2VjdXJlQ29udGV4dFdhdGNoZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBfaXNTZWN1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBfZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy52ZXJpZnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hlY2tTZXJ2ZXJJZGVudGl0eSkgPT09ICgoX2IgPSBvdGhlci52ZXJpZnlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlci5hZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZElkZW50aXR5Q2VydGlmaWNhdGVMaXN0ZW5lcih0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcclxuICAgIH1cclxuICAgIHVucmVmKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnJlZmNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIucmVtb3ZlQ2FDZXJ0aWZpY2F0ZUxpc3RlbmVyKHRoaXMuY2FDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5yZWYoKTtcclxuICAgICAgICByZXR1cm4gbmV3IENlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHNJbXBsLlNlY3VyZUNvbm5lY3RvckltcGwodGhpcywgY2hhbm5lbFRhcmdldCwgb3B0aW9ucywgY2FsbENyZWRlbnRpYWxzICE9PSBudWxsICYmIGNhbGxDcmVkZW50aWFscyAhPT0gdm9pZCAwID8gY2FsbENyZWRlbnRpYWxzIDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpKTtcclxuICAgIH1cclxuICAgIG1heWJlVXBkYXRlV2F0Y2hlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWRVcGRhdGVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyIG9mIHRoaXMuc2VjdXJlQ29udGV4dFdhdGNoZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyKHRoaXMuZ2V0TGF0ZXN0U2VjdXJlQ29udGV4dCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHRXYXRjaGVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZUNhQ2VydGlmaWNhdGVVcGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9IHVwZGF0ZTtcclxuICAgICAgICB0aGlzLm1heWJlVXBkYXRlV2F0Y2hlcnMoKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdXBkYXRlO1xyXG4gICAgICAgIHRoaXMubWF5YmVVcGRhdGVXYXRjaGVycygpO1xyXG4gICAgfVxyXG4gICAgaGFzUmVjZWl2ZWRVcGRhdGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENhVXBkYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIgJiYgdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRTZWN1cmVDb250ZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1JlY2VpdmVkVXBkYXRlcygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5nZXRMYXRlc3RTZWN1cmVDb250ZXh0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0V2F0Y2hlcnMucHVzaChyZXNvbHZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGF0ZXN0U2VjdXJlQ29udGV4dCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDYVVwZGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICE9PSBudWxsICYmICF0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQpKHtcclxuICAgICAgICAgICAgICAgIGNhOiB0aGlzLmxhdGVzdENhVXBkYXRlLmNhQ2VydGlmaWNhdGUsXHJcbiAgICAgICAgICAgICAgICBrZXk6IChfYSA9IHRoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcml2YXRlS2V5LFxyXG4gICAgICAgICAgICAgICAgY2VydDogKF9iID0gdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNlcnRpZmljYXRlLFxyXG4gICAgICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNyZWF0ZVNlY3VyZUNvbnRleHQgd2l0aCBlcnJvciAnICsgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHNJbXBsLlNlY3VyZUNvbm5lY3RvckltcGwgPSBjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscztcclxuICAgIH1cclxuICAgIGNvbm5lY3Qoc29ja2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9IHRoaXMucGFyZW50LmdldExhdGVzdFNlY3VyZUNvbnRleHQoKTtcclxuICAgICAgICAgICAgaWYgKCFzZWN1cmVDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjcmVkZW50aWFscycpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc29ja2V0LmNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU29ja2V0IGNsb3NlZCB3aGlsZSBsb2FkaW5nIGNyZWRlbnRpYWxzJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5uZWN0aW9uT3B0aW9ucyA9IGdldENvbm5lY3Rpb25PcHRpb25zKHNlY3VyZUNvbnRleHQsIHRoaXMucGFyZW50LnZlcmlmeU9wdGlvbnMsIHRoaXMuY2hhbm5lbFRhcmdldCwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgdGxzQ29ubmVjdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc29ja2V0OiBzb2NrZXQgfSwgY29ubm5lY3Rpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NvY2tldCBjbG9zZWQnKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9ICgwLCB0bHNfMS5jb25uZWN0KSh0bHNDb25uZWN0T3B0aW9ucywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsb3NlQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnBhcmVudC52ZXJpZnlPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSkgJiYgIXRsc1NvY2tldC5hdXRob3JpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRsc1NvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGxzU29ja2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0bHNTb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUNhbGxiYWNrKTtcclxuICAgICAgICAgICAgdGxzU29ja2V0Lm9uY2UoJ2Vycm9yJywgZXJyb3JDYWxsYmFjayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3YWl0Rm9yUmVhZHkoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXJlbnQuZ2V0U2VjdXJlQ29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxDcmVkZW50aWFscztcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQudW5yZWYoKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFscyhjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgdmVyaWZ5T3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChjYUNlcnRpZmljYXRlUHJvdmlkZXIsIGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xyXG59XHJcbmNsYXNzIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgaWYgKCFjaGFubmVsQ3JlZGVudGlhbHMuX2lzU2VjdXJlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIF9pc1NlY3VyZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hhbm5lbENyZWRlbnRpYWxzKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jYWxsQ3JlZGVudGlhbHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMgIT09IG51bGwgJiYgY2FsbENyZWRlbnRpYWxzICE9PSB2b2lkIDAgPyBjYWxsQ3JlZGVudGlhbHMgOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fY3JlYXRlU2VjdXJlQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXQsIG9wdGlvbnMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.recognizedOptions = void 0;\r\nexports.channelOptionsEqual = channelOptionsEqual;\r\n/**\r\n * This is for checking provided options at runtime. This is an object for\r\n * easier membership checking.\r\n */\r\nexports.recognizedOptions = {\r\n    'grpc.ssl_target_name_override': true,\r\n    'grpc.primary_user_agent': true,\r\n    'grpc.secondary_user_agent': true,\r\n    'grpc.default_authority': true,\r\n    'grpc.keepalive_time_ms': true,\r\n    'grpc.keepalive_timeout_ms': true,\r\n    'grpc.keepalive_permit_without_calls': true,\r\n    'grpc.service_config': true,\r\n    'grpc.max_concurrent_streams': true,\r\n    'grpc.initial_reconnect_backoff_ms': true,\r\n    'grpc.max_reconnect_backoff_ms': true,\r\n    'grpc.use_local_subchannel_pool': true,\r\n    'grpc.max_send_message_length': true,\r\n    'grpc.max_receive_message_length': true,\r\n    'grpc.enable_http_proxy': true,\r\n    'grpc.enable_channelz': true,\r\n    'grpc.dns_min_time_between_resolutions_ms': true,\r\n    'grpc.enable_retries': true,\r\n    'grpc.per_rpc_retry_buffer_size': true,\r\n    'grpc.retry_buffer_size': true,\r\n    'grpc.max_connection_age_ms': true,\r\n    'grpc.max_connection_age_grace_ms': true,\r\n    'grpc-node.max_session_memory': true,\r\n    'grpc.service_config_disable_resolution': true,\r\n    'grpc.client_idle_timeout_ms': true,\r\n    'grpc-node.tls_enable_trace': true,\r\n    'grpc.lb.ring_hash.ring_size_cap': true,\r\n    'grpc-node.retry_max_attempts_limit': true,\r\n    'grpc-node.flow_control_window': true,\r\n};\r\nfunction channelOptionsEqual(options1, options2) {\r\n    const keys1 = Object.keys(options1).sort();\r\n    const keys2 = Object.keys(options2).sort();\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < keys1.length; i += 1) {\r\n        if (keys1[i] !== keys2[i]) {\r\n            return false;\r\n        }\r\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtb3B0aW9ucy5qcz9iZGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0gdm9pZCAwO1xyXG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBjaGFubmVsT3B0aW9uc0VxdWFsO1xyXG4vKipcclxuICogVGhpcyBpcyBmb3IgY2hlY2tpbmcgcHJvdmlkZWQgb3B0aW9ucyBhdCBydW50aW1lLiBUaGlzIGlzIGFuIG9iamVjdCBmb3JcclxuICogZWFzaWVyIG1lbWJlcnNoaXAgY2hlY2tpbmcuXHJcbiAqL1xyXG5leHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0ge1xyXG4gICAgJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJzogdHJ1ZSxcclxuICAgICdncnBjLnByaW1hcnlfdXNlcl9hZ2VudCc6IHRydWUsXHJcbiAgICAnZ3JwYy5zZWNvbmRhcnlfdXNlcl9hZ2VudCc6IHRydWUsXHJcbiAgICAnZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSc6IHRydWUsXHJcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiB0cnVlLFxyXG4gICAgJ2dycGMuc2VydmljZV9jb25maWcnOiB0cnVlLFxyXG4gICAgJ2dycGMubWF4X2NvbmN1cnJlbnRfc3RyZWFtcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcclxuICAgICdncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJzogdHJ1ZSxcclxuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcclxuICAgICdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcclxuICAgICdncnBjLmVuYWJsZV9odHRwX3Byb3h5JzogdHJ1ZSxcclxuICAgICdncnBjLmVuYWJsZV9jaGFubmVseic6IHRydWUsXHJcbiAgICAnZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5lbmFibGVfcmV0cmllcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcclxuICAgICdncnBjLnJldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcclxuICAgICdncnBjLm1heF9jb25uZWN0aW9uX2FnZV9tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfZ3JhY2VfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknOiB0cnVlLFxyXG4gICAgJ2dycGMuc2VydmljZV9jb25maWdfZGlzYWJsZV9yZXNvbHV0aW9uJzogdHJ1ZSxcclxuICAgICdncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJzogdHJ1ZSxcclxuICAgICdncnBjLmxiLnJpbmdfaGFzaC5yaW5nX3NpemVfY2FwJzogdHJ1ZSxcclxuICAgICdncnBjLW5vZGUucmV0cnlfbWF4X2F0dGVtcHRzX2xpbWl0JzogdHJ1ZSxcclxuICAgICdncnBjLW5vZGUuZmxvd19jb250cm9sX3dpbmRvdyc6IHRydWUsXHJcbn07XHJcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XHJcbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9wdGlvbnMxKS5zb3J0KCk7XHJcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9wdGlvbnMyKS5zb3J0KCk7XHJcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKGtleXMxW2ldICE9PSBrZXlzMltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zMVtrZXlzMVtpXV0gIT09IG9wdGlvbnMyW2tleXMyW2ldXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChannelImplementation = void 0;\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\r\nclass ChannelImplementation {\r\n    constructor(target, credentials, options) {\r\n        if (typeof target !== 'string') {\r\n            throw new TypeError('Channel target must be a string');\r\n        }\r\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\r\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\r\n        }\r\n        if (options) {\r\n            if (typeof options !== 'object') {\r\n                throw new TypeError('Channel options must be an object');\r\n            }\r\n        }\r\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\r\n    }\r\n    close() {\r\n        this.internalChannel.close();\r\n    }\r\n    getTarget() {\r\n        return this.internalChannel.getTarget();\r\n    }\r\n    getConnectivityState(tryToConnect) {\r\n        return this.internalChannel.getConnectivityState(tryToConnect);\r\n    }\r\n    watchConnectivityState(currentState, deadline, callback) {\r\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\r\n    }\r\n    /**\r\n     * Get the channelz reference object for this channel. The returned value is\r\n     * garbage if channelz is disabled for this channel.\r\n     * @returns\r\n     */\r\n    getChannelzRef() {\r\n        return this.internalChannel.getChannelzRef();\r\n    }\r\n    createCall(method, deadline, host, parentCall, propagateFlags) {\r\n        if (typeof method !== 'string') {\r\n            throw new TypeError('Channel#createCall: method must be a string');\r\n        }\r\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\r\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\r\n        }\r\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\r\n    }\r\n}\r\nexports.ChannelImplementation = ChannelImplementation;\r\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzP2UyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gdm9pZCAwO1xyXG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xyXG5jb25zdCBpbnRlcm5hbF9jaGFubmVsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC1jaGFubmVsXCIpO1xyXG5jbGFzcyBDaGFubmVsSW1wbGVtZW50YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKGNyZWRlbnRpYWxzIGluc3RhbmNlb2YgY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbCA9IG5ldyBpbnRlcm5hbF9jaGFubmVsXzEuSW50ZXJuYWxDaGFubmVsKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIGdldFRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0VGFyZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KTtcclxuICAgIH1cclxuICAgIHdhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC53YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xyXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldENoYW5uZWx6UmVmKCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodHlwZW9mIGRlYWRsaW5lID09PSAnbnVtYmVyJyB8fCBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5jcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IENoYW5uZWxJbXBsZW1lbnRhdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;\r\nexports.unregisterChannelzRef = unregisterChannelzRef;\r\nexports.getChannelzHandlers = getChannelzHandlers;\r\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\r\nexports.setup = setup;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst ordered_map_1 = __webpack_require__(/*! @js-sdsl/ordered-map */ \"(rsc)/./node_modules/@js-sdsl/ordered-map/dist/esm/index.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\r\nfunction channelRefToMessage(ref) {\r\n    return {\r\n        channel_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\nfunction subchannelRefToMessage(ref) {\r\n    return {\r\n        subchannel_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\nfunction serverRefToMessage(ref) {\r\n    return {\r\n        server_id: ref.id,\r\n    };\r\n}\r\nfunction socketRefToMessage(ref) {\r\n    return {\r\n        socket_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\n/**\r\n * The loose upper bound on the number of events that should be retained in a\r\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\r\n * number that should be large enough to contain the recent relevant\r\n * information, but small enough to not use excessive memory.\r\n */\r\nconst TARGET_RETAINED_TRACES = 32;\r\n/**\r\n * Default number of sockets/servers/channels/subchannels to return\r\n */\r\nconst DEFAULT_MAX_RESULTS = 100;\r\nclass ChannelzTraceStub {\r\n    constructor() {\r\n        this.events = [];\r\n        this.creationTimestamp = new Date();\r\n        this.eventsLogged = 0;\r\n    }\r\n    addTrace() { }\r\n    getTraceMessage() {\r\n        return {\r\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\r\n            num_events_logged: this.eventsLogged,\r\n            events: [],\r\n        };\r\n    }\r\n}\r\nexports.ChannelzTraceStub = ChannelzTraceStub;\r\nclass ChannelzTrace {\r\n    constructor() {\r\n        this.events = [];\r\n        this.eventsLogged = 0;\r\n        this.creationTimestamp = new Date();\r\n    }\r\n    addTrace(severity, description, child) {\r\n        const timestamp = new Date();\r\n        this.events.push({\r\n            description: description,\r\n            severity: severity,\r\n            timestamp: timestamp,\r\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\r\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,\r\n        });\r\n        // Whenever the trace array gets too large, discard the first half\r\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\r\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\r\n        }\r\n        this.eventsLogged += 1;\r\n    }\r\n    getTraceMessage() {\r\n        return {\r\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\r\n            num_events_logged: this.eventsLogged,\r\n            events: this.events.map(event => {\r\n                return {\r\n                    description: event.description,\r\n                    severity: event.severity,\r\n                    timestamp: dateToProtoTimestamp(event.timestamp),\r\n                    channel_ref: event.childChannel\r\n                        ? channelRefToMessage(event.childChannel)\r\n                        : null,\r\n                    subchannel_ref: event.childSubchannel\r\n                        ? subchannelRefToMessage(event.childSubchannel)\r\n                        : null,\r\n                };\r\n            }),\r\n        };\r\n    }\r\n}\r\nexports.ChannelzTrace = ChannelzTrace;\r\nclass ChannelzChildrenTracker {\r\n    constructor() {\r\n        this.channelChildren = new ordered_map_1.OrderedMap();\r\n        this.subchannelChildren = new ordered_map_1.OrderedMap();\r\n        this.socketChildren = new ordered_map_1.OrderedMap();\r\n        this.trackerMap = {\r\n            [\"channel\" /* EntityTypes.channel */]: this.channelChildren,\r\n            [\"subchannel\" /* EntityTypes.subchannel */]: this.subchannelChildren,\r\n            [\"socket\" /* EntityTypes.socket */]: this.socketChildren,\r\n        };\r\n    }\r\n    refChild(child) {\r\n        const tracker = this.trackerMap[child.kind];\r\n        const trackedChild = tracker.find(child.id);\r\n        if (trackedChild.equals(tracker.end())) {\r\n            tracker.setElement(child.id, {\r\n                ref: child,\r\n                count: 1,\r\n            }, trackedChild);\r\n        }\r\n        else {\r\n            trackedChild.pointer[1].count += 1;\r\n        }\r\n    }\r\n    unrefChild(child) {\r\n        const tracker = this.trackerMap[child.kind];\r\n        const trackedChild = tracker.getElementByKey(child.id);\r\n        if (trackedChild !== undefined) {\r\n            trackedChild.count -= 1;\r\n            if (trackedChild.count === 0) {\r\n                tracker.eraseElementByKey(child.id);\r\n            }\r\n        }\r\n    }\r\n    getChildLists() {\r\n        return {\r\n            channels: this.channelChildren,\r\n            subchannels: this.subchannelChildren,\r\n            sockets: this.socketChildren,\r\n        };\r\n    }\r\n}\r\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\r\nclass ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {\r\n    refChild() { }\r\n    unrefChild() { }\r\n}\r\nexports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;\r\nclass ChannelzCallTracker {\r\n    constructor() {\r\n        this.callsStarted = 0;\r\n        this.callsSucceeded = 0;\r\n        this.callsFailed = 0;\r\n        this.lastCallStartedTimestamp = null;\r\n    }\r\n    addCallStarted() {\r\n        this.callsStarted += 1;\r\n        this.lastCallStartedTimestamp = new Date();\r\n    }\r\n    addCallSucceeded() {\r\n        this.callsSucceeded += 1;\r\n    }\r\n    addCallFailed() {\r\n        this.callsFailed += 1;\r\n    }\r\n}\r\nexports.ChannelzCallTracker = ChannelzCallTracker;\r\nclass ChannelzCallTrackerStub extends ChannelzCallTracker {\r\n    addCallStarted() { }\r\n    addCallSucceeded() { }\r\n    addCallFailed() { }\r\n}\r\nexports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;\r\nconst entityMaps = {\r\n    [\"channel\" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),\r\n    [\"subchannel\" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),\r\n    [\"server\" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),\r\n    [\"socket\" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),\r\n};\r\nconst generateRegisterFn = (kind) => {\r\n    let nextId = 1;\r\n    function getNextId() {\r\n        return nextId++;\r\n    }\r\n    const entityMap = entityMaps[kind];\r\n    return (name, getInfo, channelzEnabled) => {\r\n        const id = getNextId();\r\n        const ref = { id, name, kind };\r\n        if (channelzEnabled) {\r\n            entityMap.setElement(id, { ref, getInfo });\r\n        }\r\n        return ref;\r\n    };\r\n};\r\nexports.registerChannelzChannel = generateRegisterFn(\"channel\" /* EntityTypes.channel */);\r\nexports.registerChannelzSubchannel = generateRegisterFn(\"subchannel\" /* EntityTypes.subchannel */);\r\nexports.registerChannelzServer = generateRegisterFn(\"server\" /* EntityTypes.server */);\r\nexports.registerChannelzSocket = generateRegisterFn(\"socket\" /* EntityTypes.socket */);\r\nfunction unregisterChannelzRef(ref) {\r\n    entityMaps[ref.kind].eraseElementByKey(ref.id);\r\n}\r\n/**\r\n * Parse a single section of an IPv6 address as two bytes\r\n * @param addressSection A hexadecimal string of length up to 4\r\n * @returns The pair of bytes representing this address section\r\n */\r\nfunction parseIPv6Section(addressSection) {\r\n    const numberValue = Number.parseInt(addressSection, 16);\r\n    return [(numberValue / 256) | 0, numberValue % 256];\r\n}\r\n/**\r\n * Parse a chunk of an IPv6 address string to some number of bytes\r\n * @param addressChunk Some number of segments of up to 4 hexadecimal\r\n *   characters each, joined by colons.\r\n * @returns The list of bytes representing this address chunk\r\n */\r\nfunction parseIPv6Chunk(addressChunk) {\r\n    if (addressChunk === '') {\r\n        return [];\r\n    }\r\n    const bytePairs = addressChunk\r\n        .split(':')\r\n        .map(section => parseIPv6Section(section));\r\n    const result = [];\r\n    return result.concat(...bytePairs);\r\n}\r\nfunction isIPv6MappedIPv4(ipAddress) {\r\n    return (0, net_1.isIPv6)(ipAddress) && ipAddress.toLowerCase().startsWith('::ffff:') && (0, net_1.isIPv4)(ipAddress.substring(7));\r\n}\r\n/**\r\n * Prerequisite: isIPv4(ipAddress)\r\n * @param ipAddress\r\n * @returns\r\n */\r\nfunction ipv4AddressStringToBuffer(ipAddress) {\r\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\r\n}\r\n/**\r\n * Converts an IPv4 or IPv6 address from string representation to binary\r\n * representation\r\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\r\n * @returns\r\n */\r\nfunction ipAddressStringToBuffer(ipAddress) {\r\n    if ((0, net_1.isIPv4)(ipAddress)) {\r\n        return ipv4AddressStringToBuffer(ipAddress);\r\n    }\r\n    else if (isIPv6MappedIPv4(ipAddress)) {\r\n        return ipv4AddressStringToBuffer(ipAddress.substring(7));\r\n    }\r\n    else if ((0, net_1.isIPv6)(ipAddress)) {\r\n        let leftSection;\r\n        let rightSection;\r\n        const doubleColonIndex = ipAddress.indexOf('::');\r\n        if (doubleColonIndex === -1) {\r\n            leftSection = ipAddress;\r\n            rightSection = '';\r\n        }\r\n        else {\r\n            leftSection = ipAddress.substring(0, doubleColonIndex);\r\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\r\n        }\r\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\r\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\r\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\r\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction connectivityStateToMessage(state) {\r\n    switch (state) {\r\n        case connectivity_state_1.ConnectivityState.CONNECTING:\r\n            return {\r\n                state: 'CONNECTING',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.IDLE:\r\n            return {\r\n                state: 'IDLE',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.READY:\r\n            return {\r\n                state: 'READY',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\r\n            return {\r\n                state: 'SHUTDOWN',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\r\n            return {\r\n                state: 'TRANSIENT_FAILURE',\r\n            };\r\n        default:\r\n            return {\r\n                state: 'UNKNOWN',\r\n            };\r\n    }\r\n}\r\nfunction dateToProtoTimestamp(date) {\r\n    if (!date) {\r\n        return null;\r\n    }\r\n    const millisSinceEpoch = date.getTime();\r\n    return {\r\n        seconds: (millisSinceEpoch / 1000) | 0,\r\n        nanos: (millisSinceEpoch % 1000) * 1000000,\r\n    };\r\n}\r\nfunction getChannelMessage(channelEntry) {\r\n    const resolvedInfo = channelEntry.getInfo();\r\n    const channelRef = [];\r\n    const subchannelRef = [];\r\n    resolvedInfo.children.channels.forEach(el => {\r\n        channelRef.push(channelRefToMessage(el[1].ref));\r\n    });\r\n    resolvedInfo.children.subchannels.forEach(el => {\r\n        subchannelRef.push(subchannelRefToMessage(el[1].ref));\r\n    });\r\n    return {\r\n        ref: channelRefToMessage(channelEntry.ref),\r\n        data: {\r\n            target: resolvedInfo.target,\r\n            state: connectivityStateToMessage(resolvedInfo.state),\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        channel_ref: channelRef,\r\n        subchannel_ref: subchannelRef,\r\n    };\r\n}\r\nfunction GetChannel(call, callback) {\r\n    const channelId = parseInt(call.request.channel_id, 10);\r\n    const channelEntry = entityMaps[\"channel\" /* EntityTypes.channel */].getElementByKey(channelId);\r\n    if (channelEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No channel data found for id ' + channelId,\r\n        });\r\n        return;\r\n    }\r\n    callback(null, { channel: getChannelMessage(channelEntry) });\r\n}\r\nfunction GetTopChannels(call, callback) {\r\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\r\n    const resultList = [];\r\n    const startId = parseInt(call.request.start_channel_id, 10);\r\n    const channelEntries = entityMaps[\"channel\" /* EntityTypes.channel */];\r\n    let i;\r\n    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {\r\n        resultList.push(getChannelMessage(i.pointer[1]));\r\n    }\r\n    callback(null, {\r\n        channel: resultList,\r\n        end: i.equals(channelEntries.end()),\r\n    });\r\n}\r\nfunction getServerMessage(serverEntry) {\r\n    const resolvedInfo = serverEntry.getInfo();\r\n    const listenSocket = [];\r\n    resolvedInfo.listenerChildren.sockets.forEach(el => {\r\n        listenSocket.push(socketRefToMessage(el[1].ref));\r\n    });\r\n    return {\r\n        ref: serverRefToMessage(serverEntry.ref),\r\n        data: {\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        listen_socket: listenSocket,\r\n    };\r\n}\r\nfunction GetServer(call, callback) {\r\n    const serverId = parseInt(call.request.server_id, 10);\r\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\r\n    const serverEntry = serverEntries.getElementByKey(serverId);\r\n    if (serverEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No server data found for id ' + serverId,\r\n        });\r\n        return;\r\n    }\r\n    callback(null, { server: getServerMessage(serverEntry) });\r\n}\r\nfunction GetServers(call, callback) {\r\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\r\n    const startId = parseInt(call.request.start_server_id, 10);\r\n    const serverEntries = entityMaps[\"server\" /* EntityTypes.server */];\r\n    const resultList = [];\r\n    let i;\r\n    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {\r\n        resultList.push(getServerMessage(i.pointer[1]));\r\n    }\r\n    callback(null, {\r\n        server: resultList,\r\n        end: i.equals(serverEntries.end()),\r\n    });\r\n}\r\nfunction GetSubchannel(call, callback) {\r\n    const subchannelId = parseInt(call.request.subchannel_id, 10);\r\n    const subchannelEntry = entityMaps[\"subchannel\" /* EntityTypes.subchannel */].getElementByKey(subchannelId);\r\n    if (subchannelEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No subchannel data found for id ' + subchannelId,\r\n        });\r\n        return;\r\n    }\r\n    const resolvedInfo = subchannelEntry.getInfo();\r\n    const listenSocket = [];\r\n    resolvedInfo.children.sockets.forEach(el => {\r\n        listenSocket.push(socketRefToMessage(el[1].ref));\r\n    });\r\n    const subchannelMessage = {\r\n        ref: subchannelRefToMessage(subchannelEntry.ref),\r\n        data: {\r\n            target: resolvedInfo.target,\r\n            state: connectivityStateToMessage(resolvedInfo.state),\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        socket_ref: listenSocket,\r\n    };\r\n    callback(null, { subchannel: subchannelMessage });\r\n}\r\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\r\n    var _a;\r\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\r\n        return {\r\n            address: 'tcpip_address',\r\n            tcpip_address: {\r\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\r\n                port: subchannelAddress.port,\r\n            },\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            address: 'uds_address',\r\n            uds_address: {\r\n                filename: subchannelAddress.path,\r\n            },\r\n        };\r\n    }\r\n}\r\nfunction GetSocket(call, callback) {\r\n    var _a, _b, _c, _d, _e;\r\n    const socketId = parseInt(call.request.socket_id, 10);\r\n    const socketEntry = entityMaps[\"socket\" /* EntityTypes.socket */].getElementByKey(socketId);\r\n    if (socketEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No socket data found for id ' + socketId,\r\n        });\r\n        return;\r\n    }\r\n    const resolvedInfo = socketEntry.getInfo();\r\n    const securityMessage = resolvedInfo.security\r\n        ? {\r\n            model: 'tls',\r\n            tls: {\r\n                cipher_suite: resolvedInfo.security.cipherSuiteStandardName\r\n                    ? 'standard_name'\r\n                    : 'other_name',\r\n                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\r\n                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\r\n                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\r\n                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,\r\n            },\r\n        }\r\n        : null;\r\n    const socketMessage = {\r\n        ref: socketRefToMessage(socketEntry.ref),\r\n        local: resolvedInfo.localAddress\r\n            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\r\n            : null,\r\n        remote: resolvedInfo.remoteAddress\r\n            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\r\n            : null,\r\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\r\n        security: securityMessage,\r\n        data: {\r\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\r\n            streams_started: resolvedInfo.streamsStarted,\r\n            streams_succeeded: resolvedInfo.streamsSucceeded,\r\n            streams_failed: resolvedInfo.streamsFailed,\r\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\r\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\r\n            messages_received: resolvedInfo.messagesReceived,\r\n            messages_sent: resolvedInfo.messagesSent,\r\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\r\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\r\n            local_flow_control_window: resolvedInfo.localFlowControlWindow\r\n                ? { value: resolvedInfo.localFlowControlWindow }\r\n                : null,\r\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\r\n                ? { value: resolvedInfo.remoteFlowControlWindow }\r\n                : null,\r\n        },\r\n    };\r\n    callback(null, { socket: socketMessage });\r\n}\r\nfunction GetServerSockets(call, callback) {\r\n    const serverId = parseInt(call.request.server_id, 10);\r\n    const serverEntry = entityMaps[\"server\" /* EntityTypes.server */].getElementByKey(serverId);\r\n    if (serverEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No server data found for id ' + serverId,\r\n        });\r\n        return;\r\n    }\r\n    const startId = parseInt(call.request.start_socket_id, 10);\r\n    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;\r\n    const resolvedInfo = serverEntry.getInfo();\r\n    // If we wanted to include listener sockets in the result, this line would\r\n    // instead say\r\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\r\n    const allSockets = resolvedInfo.sessionChildren.sockets;\r\n    const resultList = [];\r\n    let i;\r\n    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {\r\n        resultList.push(socketRefToMessage(i.pointer[1].ref));\r\n    }\r\n    callback(null, {\r\n        socket_ref: resultList,\r\n        end: i.equals(allSockets.end()),\r\n    });\r\n}\r\nfunction getChannelzHandlers() {\r\n    return {\r\n        GetChannel,\r\n        GetTopChannels,\r\n        GetServer,\r\n        GetServers,\r\n        GetSubchannel,\r\n        GetSocket,\r\n        GetServerSockets,\r\n    };\r\n}\r\nlet loadedChannelzDefinition = null;\r\nfunction getChannelzServiceDefinition() {\r\n    if (loadedChannelzDefinition) {\r\n        return loadedChannelzDefinition;\r\n    }\r\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\r\n     * runtime for users who will not use/enable channelz. */\r\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\r\n    const loadedProto = loaderLoadSync('channelz.proto', {\r\n        keepCase: true,\r\n        longs: String,\r\n        enums: String,\r\n        defaults: true,\r\n        oneofs: true,\r\n        includeDirs: [`${__dirname}/../../proto`],\r\n    });\r\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\r\n    loadedChannelzDefinition =\r\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\r\n    return loadedChannelzDefinition;\r\n}\r\nfunction setup() {\r\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\r\n}\r\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyxtQ0FBbUMsR0FBRywrQkFBK0IsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUI7QUFDbFUsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcEMsYUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDcEQsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtRUFBbUU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtFQUFrRTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrREFBK0Q7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzSEFDVjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWx6LmpzPzVmMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyU3R1YiA9IGV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IGV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViID0gZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IGV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IGV4cG9ydHMuQ2hhbm5lbHpUcmFjZVN0dWIgPSB2b2lkIDA7XHJcbmV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gdW5yZWdpc3RlckNoYW5uZWx6UmVmO1xyXG5leHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBnZXRDaGFubmVsekhhbmRsZXJzO1xyXG5leHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uO1xyXG5leHBvcnRzLnNldHVwID0gc2V0dXA7XHJcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcclxuY29uc3Qgb3JkZXJlZF9tYXBfMSA9IHJlcXVpcmUoXCJAanMtc2RzbC9vcmRlcmVkLW1hcFwiKTtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xyXG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XHJcbmZ1bmN0aW9uIGNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNoYW5uZWxfaWQ6IHJlZi5pZCxcclxuICAgICAgICBuYW1lOiByZWYubmFtZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3ViY2hhbm5lbF9pZDogcmVmLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzZXJ2ZXJSZWZUb01lc3NhZ2UocmVmKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlcnZlcl9pZDogcmVmLmlkLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxyXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogVGhlIGxvb3NlIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHJldGFpbmVkIGluIGFcclxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXHJcbiAqIG51bWJlciB0aGF0IHNob3VsZCBiZSBsYXJnZSBlbm91Z2ggdG8gY29udGFpbiB0aGUgcmVjZW50IHJlbGV2YW50XHJcbiAqIGluZm9ybWF0aW9uLCBidXQgc21hbGwgZW5vdWdoIHRvIG5vdCB1c2UgZXhjZXNzaXZlIG1lbW9yeS5cclxuICovXHJcbmNvbnN0IFRBUkdFVF9SRVRBSU5FRF9UUkFDRVMgPSAzMjtcclxuLyoqXHJcbiAqIERlZmF1bHQgbnVtYmVyIG9mIHNvY2tldHMvc2VydmVycy9jaGFubmVscy9zdWJjaGFubmVscyB0byByZXR1cm5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfTUFYX1JFU1VMVFMgPSAxMDA7XHJcbmNsYXNzIENoYW5uZWx6VHJhY2VTdHViIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xyXG4gICAgfVxyXG4gICAgYWRkVHJhY2UoKSB7IH1cclxuICAgIGdldFRyYWNlTWVzc2FnZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBudW1fZXZlbnRzX2xvZ2dlZDogdGhpcy5ldmVudHNMb2dnZWQsXHJcbiAgICAgICAgICAgIGV2ZW50czogW10sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNoYW5uZWx6VHJhY2VTdHViID0gQ2hhbm5lbHpUcmFjZVN0dWI7XHJcbmNsYXNzIENoYW5uZWx6VHJhY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICBhZGRUcmFjZShzZXZlcml0eSwgZGVzY3JpcHRpb24sIGNoaWxkKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICBzZXZlcml0eTogc2V2ZXJpdHksXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBjaGlsZENoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjaGlsZFN1YmNoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdzdWJjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdoZW5ldmVyIHRoZSB0cmFjZSBhcnJheSBnZXRzIHRvbyBsYXJnZSwgZGlzY2FyZCB0aGUgZmlyc3QgaGFsZlxyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPj0gVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyAqIDIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgKz0gMTtcclxuICAgIH1cclxuICAgIGdldFRyYWNlTWVzc2FnZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBudW1fZXZlbnRzX2xvZ2dlZDogdGhpcy5ldmVudHNMb2dnZWQsXHJcbiAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMubWFwKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGV2ZW50LmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiBldmVudC5zZXZlcml0eSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkQ2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRDaGFubmVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkU3ViY2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRTdWJjaGFubmVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XHJcbmNsYXNzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuID0gbmV3IG9yZGVyZWRfbWFwXzEuT3JkZXJlZE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4gPSBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCk7XHJcbiAgICAgICAgdGhpcy50cmFja2VyTWFwID0ge1xyXG4gICAgICAgICAgICBbXCJjaGFubmVsXCIgLyogRW50aXR5VHlwZXMuY2hhbm5lbCAqL106IHRoaXMuY2hhbm5lbENoaWxkcmVuLFxyXG4gICAgICAgICAgICBbXCJzdWJjaGFubmVsXCIgLyogRW50aXR5VHlwZXMuc3ViY2hhbm5lbCAqL106IHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLFxyXG4gICAgICAgICAgICBbXCJzb2NrZXRcIiAvKiBFbnRpdHlUeXBlcy5zb2NrZXQgKi9dOiB0aGlzLnNvY2tldENoaWxkcmVuLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZWZDaGlsZChjaGlsZCkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSB0aGlzLnRyYWNrZXJNYXBbY2hpbGQua2luZF07XHJcbiAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdHJhY2tlci5maW5kKGNoaWxkLmlkKTtcclxuICAgICAgICBpZiAodHJhY2tlZENoaWxkLmVxdWFscyh0cmFja2VyLmVuZCgpKSkge1xyXG4gICAgICAgICAgICB0cmFja2VyLnNldEVsZW1lbnQoY2hpbGQuaWQsIHtcclxuICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICBjb3VudDogMSxcclxuICAgICAgICAgICAgfSwgdHJhY2tlZENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5wb2ludGVyWzFdLmNvdW50ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdW5yZWZDaGlsZChjaGlsZCkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrZXIgPSB0aGlzLnRyYWNrZXJNYXBbY2hpbGQua2luZF07XHJcbiAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdHJhY2tlci5nZXRFbGVtZW50QnlLZXkoY2hpbGQuaWQpO1xyXG4gICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcclxuICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlci5lcmFzZUVsZW1lbnRCeUtleShjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZExpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYW5uZWxzOiB0aGlzLmNoYW5uZWxDaGlsZHJlbixcclxuICAgICAgICAgICAgc3ViY2hhbm5lbHM6IHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLFxyXG4gICAgICAgICAgICBzb2NrZXRzOiB0aGlzLnNvY2tldENoaWxkcmVuLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyO1xyXG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIgZXh0ZW5kcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XHJcbiAgICByZWZDaGlsZCgpIHsgfVxyXG4gICAgdW5yZWZDaGlsZCgpIHsgfVxyXG59XHJcbmV4cG9ydHMuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXJTdHViO1xyXG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcclxuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcclxuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhZGRDYWxsU3RhcnRlZCgpIHtcclxuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xyXG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgIH1cclxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xyXG4gICAgfVxyXG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcclxuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcclxuY2xhc3MgQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIgZXh0ZW5kcyBDaGFubmVsekNhbGxUcmFja2VyIHtcclxuICAgIGFkZENhbGxTdGFydGVkKCkgeyB9XHJcbiAgICBhZGRDYWxsU3VjY2VlZGVkKCkgeyB9XHJcbiAgICBhZGRDYWxsRmFpbGVkKCkgeyB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyU3R1YiA9IENoYW5uZWx6Q2FsbFRyYWNrZXJTdHViO1xyXG5jb25zdCBlbnRpdHlNYXBzID0ge1xyXG4gICAgW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dOiBuZXcgb3JkZXJlZF9tYXBfMS5PcmRlcmVkTWFwKCksXHJcbiAgICBbXCJzdWJjaGFubmVsXCIgLyogRW50aXR5VHlwZXMuc3ViY2hhbm5lbCAqL106IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKSxcclxuICAgIFtcInNlcnZlclwiIC8qIEVudGl0eVR5cGVzLnNlcnZlciAqL106IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKSxcclxuICAgIFtcInNvY2tldFwiIC8qIEVudGl0eVR5cGVzLnNvY2tldCAqL106IG5ldyBvcmRlcmVkX21hcF8xLk9yZGVyZWRNYXAoKSxcclxufTtcclxuY29uc3QgZ2VuZXJhdGVSZWdpc3RlckZuID0gKGtpbmQpID0+IHtcclxuICAgIGxldCBuZXh0SWQgPSAxO1xyXG4gICAgZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXh0SWQrKztcclxuICAgIH1cclxuICAgIGNvbnN0IGVudGl0eU1hcCA9IGVudGl0eU1hcHNba2luZF07XHJcbiAgICByZXR1cm4gKG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZCB9O1xyXG4gICAgICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgZW50aXR5TWFwLnNldEVsZW1lbnQoaWQsIHsgcmVmLCBnZXRJbmZvIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgfTtcclxufTtcclxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcImNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5jaGFubmVsICovKTtcclxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGdlbmVyYXRlUmVnaXN0ZXJGbihcInN1YmNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5zdWJjaGFubmVsICovKTtcclxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZ2VuZXJhdGVSZWdpc3RlckZuKFwic2VydmVyXCIgLyogRW50aXR5VHlwZXMuc2VydmVyICovKTtcclxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZ2VuZXJhdGVSZWdpc3RlckZuKFwic29ja2V0XCIgLyogRW50aXR5VHlwZXMuc29ja2V0ICovKTtcclxuZnVuY3Rpb24gdW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZikge1xyXG4gICAgZW50aXR5TWFwc1tyZWYua2luZF0uZXJhc2VFbGVtZW50QnlLZXkocmVmLmlkKTtcclxufVxyXG4vKipcclxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXHJcbiAqIEBwYXJhbSBhZGRyZXNzU2VjdGlvbiBBIGhleGFkZWNpbWFsIHN0cmluZyBvZiBsZW5ndGggdXAgdG8gNFxyXG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NlNlY3Rpb24oYWRkcmVzc1NlY3Rpb24pIHtcclxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XHJcbiAgICByZXR1cm4gWyhudW1iZXJWYWx1ZSAvIDI1NikgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xyXG4gKiBAcGFyYW0gYWRkcmVzc0NodW5rIFNvbWUgbnVtYmVyIG9mIHNlZ21lbnRzIG9mIHVwIHRvIDQgaGV4YWRlY2ltYWxcclxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXHJcbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xyXG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmtcclxuICAgICAgICAuc3BsaXQoJzonKVxyXG4gICAgICAgIC5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoLi4uYnl0ZVBhaXJzKTtcclxufVxyXG5mdW5jdGlvbiBpc0lQdjZNYXBwZWRJUHY0KGlwQWRkcmVzcykge1xyXG4gICAgcmV0dXJuICgwLCBuZXRfMS5pc0lQdjYpKGlwQWRkcmVzcykgJiYgaXBBZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnOjpmZmZmOicpICYmICgwLCBuZXRfMS5pc0lQdjQpKGlwQWRkcmVzcy5zdWJzdHJpbmcoNykpO1xyXG59XHJcbi8qKlxyXG4gKiBQcmVyZXF1aXNpdGU6IGlzSVB2NChpcEFkZHJlc3MpXHJcbiAqIEBwYXJhbSBpcEFkZHJlc3NcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGlwdjRBZGRyZXNzU3RyaW5nVG9CdWZmZXIoaXBBZGRyZXNzKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oVWludDhBcnJheS5mcm9tKGlwQWRkcmVzcy5zcGxpdCgnLicpLm1hcChzZWdtZW50ID0+IE51bWJlci5wYXJzZUludChzZWdtZW50KSkpKTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IGFkZHJlc3MgZnJvbSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdG8gYmluYXJ5XHJcbiAqIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xyXG4gICAgaWYgKCgwLCBuZXRfMS5pc0lQdjQpKGlwQWRkcmVzcykpIHtcclxuICAgICAgICByZXR1cm4gaXB2NEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihpcEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNJUHY2TWFwcGVkSVB2NChpcEFkZHJlc3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlwdjRBZGRyZXNzU3RyaW5nVG9CdWZmZXIoaXBBZGRyZXNzLnN1YnN0cmluZyg3KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoMCwgbmV0XzEuaXNJUHY2KShpcEFkZHJlc3MpKSB7XHJcbiAgICAgICAgbGV0IGxlZnRTZWN0aW9uO1xyXG4gICAgICAgIGxldCByaWdodFNlY3Rpb247XHJcbiAgICAgICAgY29uc3QgZG91YmxlQ29sb25JbmRleCA9IGlwQWRkcmVzcy5pbmRleE9mKCc6OicpO1xyXG4gICAgICAgIGlmIChkb3VibGVDb2xvbkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcztcclxuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoMCwgZG91YmxlQ29sb25JbmRleCk7XHJcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoZG91YmxlQ29sb25JbmRleCArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZWZ0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsobGVmdFNlY3Rpb24pKTtcclxuICAgICAgICBjb25zdCByaWdodEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKHJpZ2h0U2VjdGlvbikpO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiAtIGxlZnRCdWZmZXIubGVuZ3RoIC0gcmlnaHRCdWZmZXIubGVuZ3RoLCAwKTtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVmdEJ1ZmZlciwgbWlkZGxlQnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2Uoc3RhdGUpIHtcclxuICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ0NPTk5FQ1RJTkcnLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiAnSURMRScsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiAnUkVBRFknLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV046XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1NIVVRET1dOJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdUUkFOU0lFTlRfRkFJTFVSRScsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiAnVU5LTk9XTicsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGF0ZVRvUHJvdG9UaW1lc3RhbXAoZGF0ZSkge1xyXG4gICAgaWYgKCFkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtaWxsaXNTaW5jZUVwb2NoID0gZGF0ZS5nZXRUaW1lKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlY29uZHM6IChtaWxsaXNTaW5jZUVwb2NoIC8gMTAwMCkgfCAwLFxyXG4gICAgICAgIG5hbm9zOiAobWlsbGlzU2luY2VFcG9jaCAlIDEwMDApICogMTAwMDAwMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB7XHJcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xyXG4gICAgY29uc3QgY2hhbm5lbFJlZiA9IFtdO1xyXG4gICAgY29uc3Qgc3ViY2hhbm5lbFJlZiA9IFtdO1xyXG4gICAgcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLmNoYW5uZWxzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgIGNoYW5uZWxSZWYucHVzaChjaGFubmVsUmVmVG9NZXNzYWdlKGVsWzFdLnJlZikpO1xyXG4gICAgfSk7XHJcbiAgICByZXNvbHZlZEluZm8uY2hpbGRyZW4uc3ViY2hhbm5lbHMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgc3ViY2hhbm5lbFJlZi5wdXNoKHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UoZWxbMV0ucmVmKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVmOiBjaGFubmVsUmVmVG9NZXNzYWdlKGNoYW5uZWxFbnRyeS5yZWYpLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxyXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcclxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcclxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hhbm5lbF9yZWY6IGNoYW5uZWxSZWYsXHJcbiAgICAgICAgc3ViY2hhbm5lbF9yZWY6IHN1YmNoYW5uZWxSZWYsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIEdldENoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGNoYW5uZWxJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5jaGFubmVsX2lkLCAxMCk7XHJcbiAgICBjb25zdCBjaGFubmVsRW50cnkgPSBlbnRpdHlNYXBzW1wiY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLmNoYW5uZWwgKi9dLmdldEVsZW1lbnRCeUtleShjaGFubmVsSWQpO1xyXG4gICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgY2hhbm5lbElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKG51bGwsIHsgY2hhbm5lbDogZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB9KTtcclxufVxyXG5mdW5jdGlvbiBHZXRUb3BDaGFubmVscyhjYWxsLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cywgMTApIHx8IERFRkFVTFRfTUFYX1JFU1VMVFM7XHJcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XHJcbiAgICBjb25zdCBzdGFydElkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X2NoYW5uZWxfaWQsIDEwKTtcclxuICAgIGNvbnN0IGNoYW5uZWxFbnRyaWVzID0gZW50aXR5TWFwc1tcImNoYW5uZWxcIiAvKiBFbnRpdHlUeXBlcy5jaGFubmVsICovXTtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gY2hhbm5lbEVudHJpZXMubG93ZXJCb3VuZChzdGFydElkKTsgIWkuZXF1YWxzKGNoYW5uZWxFbnRyaWVzLmVuZCgpKSAmJiByZXN1bHRMaXN0Lmxlbmd0aCA8IG1heFJlc3VsdHM7IGkgPSBpLm5leHQoKSkge1xyXG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRDaGFubmVsTWVzc2FnZShpLnBvaW50ZXJbMV0pKTtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKG51bGwsIHtcclxuICAgICAgICBjaGFubmVsOiByZXN1bHRMaXN0LFxyXG4gICAgICAgIGVuZDogaS5lcXVhbHMoY2hhbm5lbEVudHJpZXMuZW5kKCkpLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xyXG4gICAgY29uc3QgbGlzdGVuU29ja2V0ID0gW107XHJcbiAgICByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgIGxpc3RlblNvY2tldC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShlbFsxXS5yZWYpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWY6IHNlcnZlclJlZlRvTWVzc2FnZShzZXJ2ZXJFbnRyeS5yZWYpLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcclxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlzdGVuX3NvY2tldDogbGlzdGVuU29ja2V0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHNlcnZlcklkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCwgMTApO1xyXG4gICAgY29uc3Qgc2VydmVyRW50cmllcyA9IGVudGl0eU1hcHNbXCJzZXJ2ZXJcIiAvKiBFbnRpdHlUeXBlcy5zZXJ2ZXIgKi9dO1xyXG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJFbnRyaWVzLmdldEVsZW1lbnRCeUtleShzZXJ2ZXJJZCk7XHJcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcclxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2FsbGJhY2sobnVsbCwgeyBzZXJ2ZXI6IGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEdldFNlcnZlcnMoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBwYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMsIDEwKSB8fCBERUZBVUxUX01BWF9SRVNVTFRTO1xyXG4gICAgY29uc3Qgc3RhcnRJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zZXJ2ZXJfaWQsIDEwKTtcclxuICAgIGNvbnN0IHNlcnZlckVudHJpZXMgPSBlbnRpdHlNYXBzW1wic2VydmVyXCIgLyogRW50aXR5VHlwZXMuc2VydmVyICovXTtcclxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gc2VydmVyRW50cmllcy5sb3dlckJvdW5kKHN0YXJ0SWQpOyAhaS5lcXVhbHMoc2VydmVyRW50cmllcy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcclxuICAgICAgICByZXN1bHRMaXN0LnB1c2goZ2V0U2VydmVyTWVzc2FnZShpLnBvaW50ZXJbMV0pKTtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKG51bGwsIHtcclxuICAgICAgICBzZXJ2ZXI6IHJlc3VsdExpc3QsXHJcbiAgICAgICAgZW5kOiBpLmVxdWFscyhzZXJ2ZXJFbnRyaWVzLmVuZCgpKSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEdldFN1YmNoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHN1YmNoYW5uZWxJZCA9IHBhcnNlSW50KGNhbGwucmVxdWVzdC5zdWJjaGFubmVsX2lkLCAxMCk7XHJcbiAgICBjb25zdCBzdWJjaGFubmVsRW50cnkgPSBlbnRpdHlNYXBzW1wic3ViY2hhbm5lbFwiIC8qIEVudGl0eVR5cGVzLnN1YmNoYW5uZWwgKi9dLmdldEVsZW1lbnRCeUtleShzdWJjaGFubmVsSWQpO1xyXG4gICAgaWYgKHN1YmNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc3ViY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc3ViY2hhbm5lbElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHN1YmNoYW5uZWxFbnRyeS5nZXRJbmZvKCk7XHJcbiAgICBjb25zdCBsaXN0ZW5Tb2NrZXQgPSBbXTtcclxuICAgIHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgIGxpc3RlblNvY2tldC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShlbFsxXS5yZWYpKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxyXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcclxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcclxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc29ja2V0X3JlZjogbGlzdGVuU29ja2V0LFxyXG4gICAgfTtcclxuICAgIGNhbGxiYWNrKG51bGwsIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbE1lc3NhZ2UgfSk7XHJcbn1cclxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHN1YmNoYW5uZWxBZGRyZXNzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKHN1YmNoYW5uZWxBZGRyZXNzKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFkZHJlc3M6ICd0Y3BpcF9hZGRyZXNzJyxcclxuICAgICAgICAgICAgdGNwaXBfYWRkcmVzczoge1xyXG4gICAgICAgICAgICAgICAgaXBfYWRkcmVzczogKF9hID0gaXBBZGRyZXNzU3RyaW5nVG9CdWZmZXIoc3ViY2hhbm5lbEFkZHJlc3MuaG9zdCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHBvcnQ6IHN1YmNoYW5uZWxBZGRyZXNzLnBvcnQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFkZHJlc3M6ICd1ZHNfYWRkcmVzcycsXHJcbiAgICAgICAgICAgIHVkc19hZGRyZXNzOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogc3ViY2hhbm5lbEFkZHJlc3MucGF0aCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIEdldFNvY2tldChjYWxsLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgIGNvbnN0IHNvY2tldElkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCwgMTApO1xyXG4gICAgY29uc3Qgc29ja2V0RW50cnkgPSBlbnRpdHlNYXBzW1wic29ja2V0XCIgLyogRW50aXR5VHlwZXMuc29ja2V0ICovXS5nZXRFbGVtZW50QnlLZXkoc29ja2V0SWQpO1xyXG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXHJcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcclxuICAgIGNvbnN0IHNlY3VyaXR5TWVzc2FnZSA9IHJlc29sdmVkSW5mby5zZWN1cml0eVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBtb2RlbDogJ3RscycsXHJcbiAgICAgICAgICAgIHRsczoge1xyXG4gICAgICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWVcclxuICAgICAgICAgICAgICAgICAgICA/ICdzdGFuZGFyZF9uYW1lJ1xyXG4gICAgICAgICAgICAgICAgICAgIDogJ290aGVyX25hbWUnLFxyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGxvY2FsX2NlcnRpZmljYXRlOiAoX2MgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkubG9jYWxDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcclxuICAgICAgICByZWY6IHNvY2tldFJlZlRvTWVzc2FnZShzb2NrZXRFbnRyeS5yZWYpLFxyXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzXHJcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpXHJcbiAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzXHJcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKVxyXG4gICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcclxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXHJcbiAgICAgICAgICAgIHN0cmVhbXNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N1Y2NlZWRlZCxcclxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsYXN0X3JlbW90ZV9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcclxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcclxuICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3JlY2VpdmVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvd1xyXG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvdyB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3dcclxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93IH1cclxuICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEdldFNlcnZlclNvY2tldHMoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHNlcnZlcklkID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCwgMTApO1xyXG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBlbnRpdHlNYXBzW1wic2VydmVyXCIgLyogRW50aXR5VHlwZXMuc2VydmVyICovXS5nZXRFbGVtZW50QnlLZXkoc2VydmVySWQpO1xyXG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXHJcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0SWQgPSBwYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc29ja2V0X2lkLCAxMCk7XHJcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gcGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzLCAxMCkgfHwgREVGQVVMVF9NQVhfUkVTVUxUUztcclxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcclxuICAgIC8vIElmIHdlIHdhbnRlZCB0byBpbmNsdWRlIGxpc3RlbmVyIHNvY2tldHMgaW4gdGhlIHJlc3VsdCwgdGhpcyBsaW5lIHdvdWxkXHJcbiAgICAvLyBpbnN0ZWFkIHNheVxyXG4gICAgLy8gY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMuY29uY2F0KHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cykuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xyXG4gICAgY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cztcclxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gYWxsU29ja2V0cy5sb3dlckJvdW5kKHN0YXJ0SWQpOyAhaS5lcXVhbHMoYWxsU29ja2V0cy5lbmQoKSkgJiYgcmVzdWx0TGlzdC5sZW5ndGggPCBtYXhSZXN1bHRzOyBpID0gaS5uZXh0KCkpIHtcclxuICAgICAgICByZXN1bHRMaXN0LnB1c2goc29ja2V0UmVmVG9NZXNzYWdlKGkucG9pbnRlclsxXS5yZWYpKTtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKG51bGwsIHtcclxuICAgICAgICBzb2NrZXRfcmVmOiByZXN1bHRMaXN0LFxyXG4gICAgICAgIGVuZDogaS5lcXVhbHMoYWxsU29ja2V0cy5lbmQoKSksXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDaGFubmVsekhhbmRsZXJzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBHZXRDaGFubmVsLFxyXG4gICAgICAgIEdldFRvcENoYW5uZWxzLFxyXG4gICAgICAgIEdldFNlcnZlcixcclxuICAgICAgICBHZXRTZXJ2ZXJzLFxyXG4gICAgICAgIEdldFN1YmNoYW5uZWwsXHJcbiAgICAgICAgR2V0U29ja2V0LFxyXG4gICAgICAgIEdldFNlcnZlclNvY2tldHMsXHJcbiAgICB9O1xyXG59XHJcbmxldCBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uKCkge1xyXG4gICAgaWYgKGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XHJcbiAgICB9XHJcbiAgICAvKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNvbXBsZXhpdHkgaXMgdG8gYXZvaWQgbG9hZGluZyBAZ3JwYy9wcm90by1sb2FkZXIgYXRcclxuICAgICAqIHJ1bnRpbWUgZm9yIHVzZXJzIHdobyB3aWxsIG5vdCB1c2UvZW5hYmxlIGNoYW5uZWx6LiAqL1xyXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKVxyXG4gICAgICAgIC5sb2FkU3luYztcclxuICAgIGNvbnN0IGxvYWRlZFByb3RvID0gbG9hZGVyTG9hZFN5bmMoJ2NoYW5uZWx6LnByb3RvJywge1xyXG4gICAgICAgIGtlZXBDYXNlOiB0cnVlLFxyXG4gICAgICAgIGxvbmdzOiBTdHJpbmcsXHJcbiAgICAgICAgZW51bXM6IFN0cmluZyxcclxuICAgICAgICBkZWZhdWx0czogdHJ1ZSxcclxuICAgICAgICBvbmVvZnM6IHRydWUsXHJcbiAgICAgICAgaW5jbHVkZURpcnM6IFtgJHtfX2Rpcm5hbWV9Ly4uLy4uL3Byb3RvYF0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNoYW5uZWx6R3JwY09iamVjdCA9ICgwLCBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbikobG9hZGVkUHJvdG8pO1xyXG4gICAgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID1cclxuICAgICAgICBjaGFubmVsekdycGNPYmplY3QuZ3JwYy5jaGFubmVsei52MS5DaGFubmVsei5zZXJ2aWNlO1xyXG4gICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcclxufVxyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlKShnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uLCBnZXRDaGFubmVsekhhbmRsZXJzKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsei5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\r\nexports.getInterceptingCall = getInterceptingCall;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\n/**\r\n * Error class associated with passing both interceptors and interceptor\r\n * providers to a client constructor or as call options.\r\n */\r\nclass InterceptorConfigurationError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'InterceptorConfigurationError';\r\n        Error.captureStackTrace(this, InterceptorConfigurationError);\r\n    }\r\n}\r\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\r\nclass ListenerBuilder {\r\n    constructor() {\r\n        this.metadata = undefined;\r\n        this.message = undefined;\r\n        this.status = undefined;\r\n    }\r\n    withOnReceiveMetadata(onReceiveMetadata) {\r\n        this.metadata = onReceiveMetadata;\r\n        return this;\r\n    }\r\n    withOnReceiveMessage(onReceiveMessage) {\r\n        this.message = onReceiveMessage;\r\n        return this;\r\n    }\r\n    withOnReceiveStatus(onReceiveStatus) {\r\n        this.status = onReceiveStatus;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            onReceiveMetadata: this.metadata,\r\n            onReceiveMessage: this.message,\r\n            onReceiveStatus: this.status,\r\n        };\r\n    }\r\n}\r\nexports.ListenerBuilder = ListenerBuilder;\r\nclass RequesterBuilder {\r\n    constructor() {\r\n        this.start = undefined;\r\n        this.message = undefined;\r\n        this.halfClose = undefined;\r\n        this.cancel = undefined;\r\n    }\r\n    withStart(start) {\r\n        this.start = start;\r\n        return this;\r\n    }\r\n    withSendMessage(sendMessage) {\r\n        this.message = sendMessage;\r\n        return this;\r\n    }\r\n    withHalfClose(halfClose) {\r\n        this.halfClose = halfClose;\r\n        return this;\r\n    }\r\n    withCancel(cancel) {\r\n        this.cancel = cancel;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            start: this.start,\r\n            sendMessage: this.message,\r\n            halfClose: this.halfClose,\r\n            cancel: this.cancel,\r\n        };\r\n    }\r\n}\r\nexports.RequesterBuilder = RequesterBuilder;\r\n/**\r\n * A Listener with a default pass-through implementation of each method. Used\r\n * for filling out Listeners with some methods omitted.\r\n */\r\nconst defaultListener = {\r\n    onReceiveMetadata: (metadata, next) => {\r\n        next(metadata);\r\n    },\r\n    onReceiveMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    onReceiveStatus: (status, next) => {\r\n        next(status);\r\n    },\r\n};\r\n/**\r\n * A Requester with a default pass-through implementation of each method. Used\r\n * for filling out Requesters with some methods omitted.\r\n */\r\nconst defaultRequester = {\r\n    start: (metadata, listener, next) => {\r\n        next(metadata, listener);\r\n    },\r\n    sendMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    halfClose: next => {\r\n        next();\r\n    },\r\n    cancel: next => {\r\n        next();\r\n    },\r\n};\r\nclass InterceptingCall {\r\n    constructor(nextCall, requester) {\r\n        var _a, _b, _c, _d;\r\n        this.nextCall = nextCall;\r\n        /**\r\n         * Indicates that metadata has been passed to the requester's start\r\n         * method but it has not been passed to the corresponding next callback\r\n         */\r\n        this.processingMetadata = false;\r\n        /**\r\n         * Message context for a pending message that is waiting for\r\n         */\r\n        this.pendingMessageContext = null;\r\n        /**\r\n         * Indicates that a message has been passed to the requester's sendMessage\r\n         * method but it has not been passed to the corresponding next callback\r\n         */\r\n        this.processingMessage = false;\r\n        /**\r\n         * Indicates that a status was received but could not be propagated because\r\n         * a message was still being processed.\r\n         */\r\n        this.pendingHalfClose = false;\r\n        if (requester) {\r\n            this.requester = {\r\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\r\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\r\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\r\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\r\n            };\r\n        }\r\n        else {\r\n            this.requester = defaultRequester;\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.requester.cancel(() => {\r\n            this.nextCall.cancelWithStatus(status, details);\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.nextCall.getPeer();\r\n    }\r\n    processPendingMessage() {\r\n        if (this.pendingMessageContext) {\r\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\r\n            this.pendingMessageContext = null;\r\n            this.pendingMessage = null;\r\n        }\r\n    }\r\n    processPendingHalfClose() {\r\n        if (this.pendingHalfClose) {\r\n            this.nextCall.halfClose();\r\n        }\r\n    }\r\n    start(metadata, interceptingListener) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const fullInterceptingListener = {\r\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\r\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\r\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\r\n        };\r\n        this.processingMetadata = true;\r\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\r\n            var _a, _b, _c;\r\n            this.processingMetadata = false;\r\n            let finalInterceptingListener;\r\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\r\n                finalInterceptingListener = listener;\r\n            }\r\n            else {\r\n                const fullListener = {\r\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\r\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\r\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\r\n                };\r\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\r\n            }\r\n            this.nextCall.start(md, finalInterceptingListener);\r\n            this.processPendingMessage();\r\n            this.processPendingHalfClose();\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessageWithContext(context, message) {\r\n        this.processingMessage = true;\r\n        this.requester.sendMessage(message, finalMessage => {\r\n            this.processingMessage = false;\r\n            if (this.processingMetadata) {\r\n                this.pendingMessageContext = context;\r\n                this.pendingMessage = message;\r\n            }\r\n            else {\r\n                this.nextCall.sendMessageWithContext(context, finalMessage);\r\n                this.processPendingHalfClose();\r\n            }\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessage(message) {\r\n        this.sendMessageWithContext({}, message);\r\n    }\r\n    startRead() {\r\n        this.nextCall.startRead();\r\n    }\r\n    halfClose() {\r\n        this.requester.halfClose(() => {\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.pendingHalfClose = true;\r\n            }\r\n            else {\r\n                this.nextCall.halfClose();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.InterceptingCall = InterceptingCall;\r\nfunction getCall(channel, path, options) {\r\n    var _a, _b;\r\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\r\n    const host = options.host;\r\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\r\n    const propagateFlags = options.propagate_flags;\r\n    const credentials = options.credentials;\r\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\r\n    if (credentials) {\r\n        call.setCredentials(credentials);\r\n    }\r\n    return call;\r\n}\r\n/**\r\n * InterceptingCall implementation that directly owns the underlying Call\r\n * object and handles serialization and deseraizliation.\r\n */\r\nclass BaseInterceptingCall {\r\n    constructor(call, \r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    methodDefinition) {\r\n        this.call = call;\r\n        this.methodDefinition = methodDefinition;\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.call.cancelWithStatus(status, details);\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessageWithContext(context, message) {\r\n        let serialized;\r\n        try {\r\n            serialized = this.methodDefinition.requestSerialize(message);\r\n        }\r\n        catch (e) {\r\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\r\n            return;\r\n        }\r\n        this.call.sendMessageWithContext(context, serialized);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessage(message) {\r\n        this.sendMessageWithContext({}, message);\r\n    }\r\n    start(metadata, interceptingListener) {\r\n        let readError = null;\r\n        this.call.start(metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                var _a;\r\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\r\n            },\r\n            onReceiveMessage: message => {\r\n                var _a;\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                let deserialized;\r\n                try {\r\n                    deserialized = this.methodDefinition.responseDeserialize(message);\r\n                }\r\n                catch (e) {\r\n                    readError = {\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    };\r\n                    this.call.cancelWithStatus(readError.code, readError.details);\r\n                    return;\r\n                }\r\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\r\n            },\r\n            onReceiveStatus: status => {\r\n                var _a, _b;\r\n                if (readError) {\r\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\r\n                }\r\n                else {\r\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\r\n                }\r\n            },\r\n        });\r\n    }\r\n    startRead() {\r\n        this.call.startRead();\r\n    }\r\n    halfClose() {\r\n        this.call.halfClose();\r\n    }\r\n}\r\n/**\r\n * BaseInterceptingCall with special-cased behavior for methods with unary\r\n * responses.\r\n */\r\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    constructor(call, methodDefinition) {\r\n        super(call, methodDefinition);\r\n    }\r\n    start(metadata, listener) {\r\n        var _a, _b;\r\n        let receivedMessage = false;\r\n        const wrapperListener = {\r\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage: (message) => {\r\n                var _a;\r\n                receivedMessage = true;\r\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\r\n            },\r\n            onReceiveStatus: (status) => {\r\n                var _a, _b;\r\n                if (!receivedMessage) {\r\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\r\n                }\r\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\r\n            },\r\n        };\r\n        super.start(metadata, wrapperListener);\r\n        this.call.startRead();\r\n    }\r\n}\r\n/**\r\n * BaseInterceptingCall with special-cased behavior for methods with streaming\r\n * responses.\r\n */\r\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\r\n}\r\nfunction getBottomInterceptingCall(channel, options, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nmethodDefinition) {\r\n    const call = getCall(channel, methodDefinition.path, options);\r\n    if (methodDefinition.responseStream) {\r\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\r\n    }\r\n    else {\r\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\r\n    }\r\n}\r\nfunction getInterceptingCall(interceptorArgs, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nmethodDefinition, options, channel) {\r\n    if (interceptorArgs.clientInterceptors.length > 0 &&\r\n        interceptorArgs.clientInterceptorProviders.length > 0) {\r\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\r\n            'to the client constructor. Only one of these is allowed.');\r\n    }\r\n    if (interceptorArgs.callInterceptors.length > 0 &&\r\n        interceptorArgs.callInterceptorProviders.length > 0) {\r\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\r\n            'options. Only one of these is allowed.');\r\n    }\r\n    let interceptors = [];\r\n    // Interceptors passed to the call override interceptors passed to the client constructor\r\n    if (interceptorArgs.callInterceptors.length > 0 ||\r\n        interceptorArgs.callInterceptorProviders.length > 0) {\r\n        interceptors = []\r\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\r\n            .filter(interceptor => interceptor);\r\n        // Filter out falsy values when providers return nothing\r\n    }\r\n    else {\r\n        interceptors = []\r\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\r\n            .filter(interceptor => interceptor);\r\n        // Filter out falsy values when providers return nothing\r\n    }\r\n    const interceptorOptions = Object.assign({}, options, {\r\n        method_definition: methodDefinition,\r\n    });\r\n    /* For each interceptor in the list, the nextCall function passed to it is\r\n     * based on the next interceptor in the list, using a nextCall function\r\n     * constructed with the following interceptor in the list, and so on. The\r\n     * initialValue, which is effectively at the end of the list, is a nextCall\r\n     * function that invokes getBottomInterceptingCall, the result of which\r\n     * handles (de)serialization and also gets the underlying call from the\r\n     * channel. */\r\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\r\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\r\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\r\n    return getCall(interceptorOptions);\r\n}\r\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQztBQUNySCwyQkFBMkI7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9SQUFvUjtBQUNwUixpUkFBaVI7QUFDalIsOFFBQThRO0FBQzlRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsZ0NBQWdDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQ0FBZ0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9PQUFvTztBQUNwTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcz8xZDFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSB2b2lkIDA7XHJcbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuY29uc3QgY2FsbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2NhbGwtaW50ZXJmYWNlXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xyXG4vKipcclxuICogRXJyb3IgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHBhc3NpbmcgYm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yXHJcbiAqIHByb3ZpZGVycyB0byBhIGNsaWVudCBjb25zdHJ1Y3RvciBvciBhcyBjYWxsIG9wdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3InO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7XHJcbmNsYXNzIExpc3RlbmVyQnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHdpdGhPblJlY2VpdmVNZXRhZGF0YShvblJlY2VpdmVNZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBvblJlY2VpdmVNZXNzYWdlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgd2l0aE9uUmVjZWl2ZVN0YXR1cyhvblJlY2VpdmVTdGF0dXMpIHtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IG9uUmVjZWl2ZVN0YXR1cztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGJ1aWxkKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogdGhpcy5zdGF0dXMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IExpc3RlbmVyQnVpbGRlcjtcclxuY2xhc3MgUmVxdWVzdGVyQnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNhbmNlbCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHdpdGhTdGFydChzdGFydCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhTZW5kTWVzc2FnZShzZW5kTWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgd2l0aEhhbGZDbG9zZShoYWxmQ2xvc2UpIHtcclxuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IGhhbGZDbG9zZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhDYW5jZWwoY2FuY2VsKSB7XHJcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcclxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgICAgICAgaGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcclxuICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IFJlcXVlc3RlckJ1aWxkZXI7XHJcbi8qKlxyXG4gKiBBIExpc3RlbmVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxyXG4gKiBmb3IgZmlsbGluZyBvdXQgTGlzdGVuZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TGlzdGVuZXIgPSB7XHJcbiAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhLCBuZXh0KSA9PiB7XHJcbiAgICAgICAgbmV4dChtZXRhZGF0YSk7XHJcbiAgICB9LFxyXG4gICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcclxuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xyXG4gICAgfSxcclxuICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cywgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQoc3RhdHVzKTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBBIFJlcXVlc3RlciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcclxuICogZm9yIGZpbGxpbmcgb3V0IFJlcXVlc3RlcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cclxuICovXHJcbmNvbnN0IGRlZmF1bHRSZXF1ZXN0ZXIgPSB7XHJcbiAgICBzdGFydDogKG1ldGFkYXRhLCBsaXN0ZW5lciwgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQobWV0YWRhdGEsIGxpc3RlbmVyKTtcclxuICAgIH0sXHJcbiAgICBzZW5kTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcclxuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xyXG4gICAgfSxcclxuICAgIGhhbGZDbG9zZTogbmV4dCA9PiB7XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfSxcclxuICAgIGNhbmNlbDogbmV4dCA9PiB7XHJcbiAgICAgICAgbmV4dCgpO1xyXG4gICAgfSxcclxufTtcclxuY2xhc3MgSW50ZXJjZXB0aW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihuZXh0Q2FsbCwgcmVxdWVzdGVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHRoaXMubmV4dENhbGwgPSBuZXh0Q2FsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBtZXRhZGF0YSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHN0YXJ0XHJcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1lc3NhZ2UgY29udGV4dCBmb3IgYSBwZW5kaW5nIG1lc3NhZ2UgdGhhdCBpcyB3YWl0aW5nIGZvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIG1lc3NhZ2UgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzZW5kTWVzc2FnZVxyXG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgc3RhdHVzIHdhcyByZWNlaXZlZCBidXQgY291bGQgbm90IGJlIHByb3BhZ2F0ZWQgYmVjYXVzZVxyXG4gICAgICAgICAqIGEgbWVzc2FnZSB3YXMgc3RpbGwgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogKF9hID0gcmVxdWVzdGVyLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0UmVxdWVzdGVyLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYiA9IHJlcXVlc3Rlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlcXVlc3Rlci5zZW5kTWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIGhhbGZDbG9zZTogKF9jID0gcmVxdWVzdGVyLmhhbGZDbG9zZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlcXVlc3Rlci5oYWxmQ2xvc2UsXHJcbiAgICAgICAgICAgICAgICBjYW5jZWw6IChfZCA9IHJlcXVlc3Rlci5jYW5jZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRSZXF1ZXN0ZXIuY2FuY2VsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSBkZWZhdWx0UmVxdWVzdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuY2FuY2VsKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDYWxsLmdldFBlZXIoKTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgY29uc3QgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyID0ge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChtZXRhZGF0YSA9PiB7IH0pLFxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2QgPSAoX2MgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAobWVzc2FnZSA9PiB7IH0pLFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChfZiA9IChfZSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogKHN0YXR1cyA9PiB7IH0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdGVyLnN0YXJ0KG1ldGFkYXRhLCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIsIChtZCwgbGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyO1xyXG4gICAgICAgICAgICBpZiAoKDAsIGNhbGxfaW50ZXJmYWNlXzEuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcikobGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGlzdGVuZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYSA9IGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2MgPSBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IG5ldyBjYWxsX2ludGVyZmFjZV8xLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbChmdWxsTGlzdGVuZXIsIGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydChtZCwgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zZW5kTWVzc2FnZShtZXNzYWdlLCBmaW5hbE1lc3NhZ2UgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmluYWxNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRSZWFkKCkge1xyXG4gICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbiAgICBoYWxmQ2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuaGFsZkNsb3NlKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gSW50ZXJjZXB0aW5nQ2FsbDtcclxuZnVuY3Rpb24gZ2V0Q2FsbChjaGFubmVsLCBwYXRoLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgZGVhZGxpbmUgPSAoX2EgPSBvcHRpb25zLmRlYWRsaW5lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLmhvc3Q7XHJcbiAgICBjb25zdCBwYXJlbnQgPSAoX2IgPSBvcHRpb25zLnBhcmVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcclxuICAgIGNvbnN0IHByb3BhZ2F0ZUZsYWdzID0gb3B0aW9ucy5wcm9wYWdhdGVfZmxhZ3M7XHJcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHM7XHJcbiAgICBjb25zdCBjYWxsID0gY2hhbm5lbC5jcmVhdGVDYWxsKHBhdGgsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnQsIHByb3BhZ2F0ZUZsYWdzKTtcclxuICAgIGlmIChjcmVkZW50aWFscykge1xyXG4gICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbGw7XHJcbn1cclxuLyoqXHJcbiAqIEludGVyY2VwdGluZ0NhbGwgaW1wbGVtZW50YXRpb24gdGhhdCBkaXJlY3RseSBvd25zIHRoZSB1bmRlcmx5aW5nIENhbGxcclxuICogb2JqZWN0IGFuZCBoYW5kbGVzIHNlcmlhbGl6YXRpb24gYW5kIGRlc2VyYWl6bGlhdGlvbi5cclxuICovXHJcbmNsYXNzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIG1ldGhvZERlZmluaXRpb24pIHtcclxuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIHRoaXMubWV0aG9kRGVmaW5pdGlvbiA9IG1ldGhvZERlZmluaXRpb247XHJcbiAgICB9XHJcbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xyXG4gICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xyXG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVxdWVzdFNlcmlhbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgUmVxdWVzdCBtZXNzYWdlIHNlcmlhbGl6YXRpb24gZmFpbHVyZTogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIHNlcmlhbGl6ZWQpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQobWV0YWRhdGEsIGludGVyY2VwdGluZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgbGV0IHJlYWRFcnJvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0KG1ldGFkYXRhLCB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWQ7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZURlc2VyaWFsaXplKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkRXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3BvbnNlIG1lc3NhZ2UgcGFyc2luZyBlcnJvcjogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMocmVhZEVycm9yLmNvZGUsIHJlYWRFcnJvci5kZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIGRlc2VyaWFsaXplZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVhZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHJlYWRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAoX2IgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbiAgICBoYWxmQ2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCB1bmFyeVxyXG4gKiByZXNwb25zZXMuXHJcbiAqL1xyXG5jbGFzcyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGhvZERlZmluaXRpb24pIHtcclxuICAgICAgICBzdXBlcihjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IHJlY2VpdmVkTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZXJMaXN0ZW5lciA9IHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQobGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobWV0YWRhdGEgPT4geyB9KSxcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVkTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2IgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChsaXN0ZW5lciwgc3RhdHVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN1cGVyLnN0YXJ0KG1ldGFkYXRhLCB3cmFwcGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggc3RyZWFtaW5nXHJcbiAqIHJlc3BvbnNlcy5cclxuICovXHJcbmNsYXNzIEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xyXG59XHJcbmZ1bmN0aW9uIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgb3B0aW9ucywgXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbm1ldGhvZERlZmluaXRpb24pIHtcclxuICAgIGNvbnN0IGNhbGwgPSBnZXRDYWxsKGNoYW5uZWwsIG1ldGhvZERlZmluaXRpb24ucGF0aCwgb3B0aW9ucyk7XHJcbiAgICBpZiAobWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5tZXRob2REZWZpbml0aW9uLCBvcHRpb25zLCBjaGFubmVsKSB7XHJcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcclxuICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBjYWxsICcgK1xyXG4gICAgICAgICAgICAnb3B0aW9ucy4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcclxuICAgIH1cclxuICAgIGxldCBpbnRlcmNlcHRvcnMgPSBbXTtcclxuICAgIC8vIEludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNhbGwgb3ZlcnJpZGUgaW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yXHJcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCB8fFxyXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXHJcbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcclxuICAgICAgICAgICAgLmZpbHRlcihpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvcik7XHJcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXHJcbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xyXG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRlcmNlcHRvck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgICAgbWV0aG9kX2RlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXHJcbiAgICB9KTtcclxuICAgIC8qIEZvciBlYWNoIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB0aGUgbmV4dENhbGwgZnVuY3Rpb24gcGFzc2VkIHRvIGl0IGlzXHJcbiAgICAgKiBiYXNlZCBvbiB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdXNpbmcgYSBuZXh0Q2FsbCBmdW5jdGlvblxyXG4gICAgICogY29uc3RydWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCBhbmQgc28gb24uIFRoZVxyXG4gICAgICogaW5pdGlhbFZhbHVlLCB3aGljaCBpcyBlZmZlY3RpdmVseSBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBpcyBhIG5leHRDYWxsXHJcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGludm9rZXMgZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCwgdGhlIHJlc3VsdCBvZiB3aGljaFxyXG4gICAgICogaGFuZGxlcyAoZGUpc2VyaWFsaXphdGlvbiBhbmQgYWxzbyBnZXRzIHRoZSB1bmRlcmx5aW5nIGNhbGwgZnJvbSB0aGVcclxuICAgICAqIGNoYW5uZWwuICovXHJcbiAgICBjb25zdCBnZXRDYWxsID0gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KChuZXh0Q2FsbCwgbmV4dEludGVyY2VwdG9yKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPcHRpb25zID0+IG5leHRJbnRlcmNlcHRvcihjdXJyZW50T3B0aW9ucywgbmV4dENhbGwpO1xyXG4gICAgfSwgKGZpbmFsT3B0aW9ucykgPT4gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBmaW5hbE9wdGlvbnMsIG1ldGhvZERlZmluaXRpb24pKTtcclxuICAgIHJldHVybiBnZXRDYWxsKGludGVyY2VwdG9yT3B0aW9ucyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LWludGVyY2VwdG9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Client = void 0;\r\nconst call_1 = __webpack_require__(/*! ./call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\");\r\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\r\nconst CHANNEL_SYMBOL = Symbol();\r\nconst INTERCEPTOR_SYMBOL = Symbol();\r\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\r\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\r\nfunction isFunction(arg) {\r\n    return typeof arg === 'function';\r\n}\r\nfunction getErrorStackString(error) {\r\n    var _a;\r\n    return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\\n').slice(1).join('\\n')) || 'no stack trace available';\r\n}\r\n/**\r\n * A generic gRPC client. Primarily useful as a base class for all generated\r\n * clients.\r\n */\r\nclass Client {\r\n    constructor(address, credentials, options = {}) {\r\n        var _a, _b;\r\n        options = Object.assign({}, options);\r\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\r\n        delete options.interceptors;\r\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\r\n        delete options.interceptor_providers;\r\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\r\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\r\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\r\n                'to the client constructor. Only one of these is allowed.');\r\n        }\r\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\r\n            options.callInvocationTransformer;\r\n        delete options.callInvocationTransformer;\r\n        if (options.channelOverride) {\r\n            this[CHANNEL_SYMBOL] = options.channelOverride;\r\n        }\r\n        else if (options.channelFactoryOverride) {\r\n            const channelFactoryOverride = options.channelFactoryOverride;\r\n            delete options.channelFactoryOverride;\r\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\r\n        }\r\n        else {\r\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\r\n        }\r\n    }\r\n    close() {\r\n        this[CHANNEL_SYMBOL].close();\r\n    }\r\n    getChannel() {\r\n        return this[CHANNEL_SYMBOL];\r\n    }\r\n    waitForReady(deadline, callback) {\r\n        const checkState = (err) => {\r\n            if (err) {\r\n                callback(new Error('Failed to connect before the deadline'));\r\n                return;\r\n            }\r\n            let newState;\r\n            try {\r\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\r\n            }\r\n            catch (e) {\r\n                callback(new Error('The channel has been closed'));\r\n                return;\r\n            }\r\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n                callback();\r\n            }\r\n            else {\r\n                try {\r\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\r\n                }\r\n                catch (e) {\r\n                    callback(new Error('The channel has been closed'));\r\n                }\r\n            }\r\n        };\r\n        setImmediate(checkState);\r\n    }\r\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\r\n        if (isFunction(arg1)) {\r\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\r\n        }\r\n        else if (isFunction(arg2)) {\r\n            if (arg1 instanceof metadata_1.Metadata) {\r\n                return { metadata: arg1, options: {}, callback: arg2 };\r\n            }\r\n            else {\r\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\r\n            }\r\n        }\r\n        else {\r\n            if (!(arg1 instanceof metadata_1.Metadata &&\r\n                arg2 instanceof Object &&\r\n                isFunction(arg3))) {\r\n                throw new Error('Incorrect arguments passed');\r\n            }\r\n            return { metadata: arg1, options: arg2, callback: arg3 };\r\n        }\r\n    }\r\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: false,\r\n            responseStream: false,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            argument: argument,\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientUnaryCallImpl(),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n            callback: checkedArguments.callback,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const emitter = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        emitter.call = call;\r\n        let responseMessage = null;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                emitter.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                if (responseMessage !== null) {\r\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\r\n                }\r\n                responseMessage = message;\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                if (status.code === constants_1.Status.OK) {\r\n                    if (responseMessage === null) {\r\n                        const callerStack = getErrorStackString(callerStackError);\r\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\r\n                            code: constants_1.Status.UNIMPLEMENTED,\r\n                            details: 'No message received',\r\n                            metadata: status.metadata,\r\n                        }, callerStack));\r\n                    }\r\n                    else {\r\n                        callProperties.callback(null, responseMessage);\r\n                    }\r\n                }\r\n                else {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                emitter.emit('status', status);\r\n            },\r\n        });\r\n        call.sendMessage(argument);\r\n        call.halfClose();\r\n        return emitter;\r\n    }\r\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: true,\r\n            responseStream: false,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientWritableStreamImpl(serialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n            callback: checkedArguments.callback,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const emitter = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        emitter.call = call;\r\n        let responseMessage = null;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                emitter.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                if (responseMessage !== null) {\r\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\r\n                }\r\n                responseMessage = message;\r\n                call.startRead();\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                if (status.code === constants_1.Status.OK) {\r\n                    if (responseMessage === null) {\r\n                        const callerStack = getErrorStackString(callerStackError);\r\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\r\n                            code: constants_1.Status.UNIMPLEMENTED,\r\n                            details: 'No message received',\r\n                            metadata: status.metadata,\r\n                        }, callerStack));\r\n                    }\r\n                    else {\r\n                        callProperties.callback(null, responseMessage);\r\n                    }\r\n                }\r\n                else {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                emitter.emit('status', status);\r\n            },\r\n        });\r\n        return emitter;\r\n    }\r\n    checkMetadataAndOptions(arg1, arg2) {\r\n        let metadata;\r\n        let options;\r\n        if (arg1 instanceof metadata_1.Metadata) {\r\n            metadata = arg1;\r\n            if (arg2) {\r\n                options = arg2;\r\n            }\r\n            else {\r\n                options = {};\r\n            }\r\n        }\r\n        else {\r\n            if (arg1) {\r\n                options = arg1;\r\n            }\r\n            else {\r\n                options = {};\r\n            }\r\n            metadata = new metadata_1.Metadata();\r\n        }\r\n        return { metadata, options };\r\n    }\r\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: false,\r\n            responseStream: true,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            argument: argument,\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientReadableStreamImpl(deserialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const stream = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        stream.call = call;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata(metadata) {\r\n                stream.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                stream.push(message);\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                stream.push(null);\r\n                if (status.code !== constants_1.Status.OK) {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                stream.emit('status', status);\r\n            },\r\n        });\r\n        call.sendMessage(argument);\r\n        call.halfClose();\r\n        return stream;\r\n    }\r\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: true,\r\n            responseStream: true,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const stream = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        stream.call = call;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata(metadata) {\r\n                stream.emit('metadata', metadata);\r\n            },\r\n            onReceiveMessage(message) {\r\n                stream.push(message);\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                stream.push(null);\r\n                if (status.code !== constants_1.Status.OK) {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                stream.emit('status', status);\r\n            },\r\n        });\r\n        return stream;\r\n    }\r\n}\r\nexports.Client = Client;\r\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBZ0Q7QUFDckU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanM/N2E5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XHJcbmNvbnN0IGNhbGxfMSA9IHJlcXVpcmUoXCIuL2NhbGxcIik7XHJcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xyXG5jb25zdCBDSEFOTkVMX1NZTUJPTCA9IFN5bWJvbCgpO1xyXG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcclxuY29uc3QgSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MID0gU3ltYm9sKCk7XHJcbmNvbnN0IENBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wgPSBTeW1ib2woKTtcclxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKF9hID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJykpIHx8ICdubyBzdGFjayB0cmFjZSBhdmFpbGFibGUnO1xyXG59XHJcbi8qKlxyXG4gKiBBIGdlbmVyaWMgZ1JQQyBjbGllbnQuIFByaW1hcmlseSB1c2VmdWwgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ2VuZXJhdGVkXHJcbiAqIGNsaWVudHMuXHJcbiAqL1xyXG5jbGFzcyBDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSA9IChfYSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcnM7XHJcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdID0gKF9iID0gb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycztcclxuICAgICAgICBpZiAodGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXHJcbiAgICAgICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSA9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lcjtcclxuICAgICAgICBkZWxldGUgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxPdmVycmlkZSkge1xyXG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZhY3RvcnlPdmVycmlkZSA9IG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcclxuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBjaGFubmVsRmFjdG9yeU92ZXJyaWRlKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gbmV3IGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBnZXRDaGFubmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW0NIQU5ORUxfU1lNQk9MXTtcclxuICAgIH1cclxuICAgIHdhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBjaGVja1N0YXRlID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IGJlZm9yZSB0aGUgZGVhZGxpbmUnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzW0NIQU5ORUxfU1lNQk9MXS5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0ud2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShuZXdTdGF0ZSwgZGVhZGxpbmUsIGNoZWNrU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMoYXJnMSwgYXJnMiwgYXJnMykge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzEgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xyXG4gICAgICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzIgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiBhcmcxLCBjYWxsYmFjazogYXJnMiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSAmJlxyXG4gICAgICAgICAgICAgICAgYXJnMiBpbnN0YW5jZW9mIE9iamVjdCAmJlxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihhcmczKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50cyBwYXNzZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczogYXJnMiwgY2FsbGJhY2s6IGFyZzMgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYWtlVW5hcnlSZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxyXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50VW5hcnlDYWxsSW1wbCgpLFxyXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcclxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcclxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xyXG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcclxuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcclxuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxyXG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXHJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcclxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXHJcbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcclxuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNhbGxlclN0YWNrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhudWxsLCByZXNwb25zZU1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxyXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xyXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XHJcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcclxuICAgICAgICByZXR1cm4gZW1pdHRlcjtcclxuICAgIH1cclxuICAgIG1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcclxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxyXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcclxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwoc2VyaWFsaXplKSxcclxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXHJcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcclxuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XHJcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xyXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcclxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcclxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcclxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XHJcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcclxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXHJcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xyXG4gICAgICAgIGVtaXR0ZXIuY2FsbCA9IGNhbGw7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsICdUb28gbWFueSByZXNwb25zZXMgcmVjZWl2ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXHJcbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZW1pdHRlcjtcclxuICAgIH1cclxuICAgIGNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKGFyZzEsIGFyZzIpIHtcclxuICAgICAgICBsZXQgbWV0YWRhdGE7XHJcbiAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcclxuICAgICAgICAgICAgaWYgKGFyZzIpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYXJnMSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBtZXRhZGF0YSwgb3B0aW9ucyB9O1xyXG4gICAgfVxyXG4gICAgbWFrZVNlcnZlclN0cmVhbVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxyXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcclxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxyXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcclxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwoZGVzZXJpYWxpemUpLFxyXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcclxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcclxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XHJcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XHJcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xyXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcclxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcclxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcclxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XHJcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcclxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXHJcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xyXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcclxuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxyXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xyXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcclxuICAgICAgICBjYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICB9XHJcbiAgICBtYWtlQmlkaVN0cmVhbVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBtZXRhZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcclxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxyXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudER1cGxleFN0cmVhbUltcGwoc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSksXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxyXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxyXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcclxuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcclxuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcclxuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxyXG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXHJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcclxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXHJcbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXHJcbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CompressionAlgorithms = void 0;\r\nvar CompressionAlgorithms;\r\n(function (CompressionAlgorithms) {\r\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\r\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\r\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\r\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));\r\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsNkJBQTZCLDZCQUE2QjtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzPzY0ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gdm9pZCAwO1xyXG52YXIgQ29tcHJlc3Npb25BbGdvcml0aG1zO1xyXG4oZnVuY3Rpb24gKENvbXByZXNzaW9uQWxnb3JpdGhtcykge1xyXG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImlkZW50aXR5XCJdID0gMF0gPSBcImlkZW50aXR5XCI7XHJcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZGVmbGF0ZVwiXSA9IDFdID0gXCJkZWZsYXRlXCI7XHJcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZ3ppcFwiXSA9IDJdID0gXCJnemlwXCI7XHJcbn0pKENvbXByZXNzaW9uQWxnb3JpdGhtcyB8fCAoZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSBDb21wcmVzc2lvbkFsZ29yaXRobXMgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst isCompressionAlgorithmKey = (key) => {\r\n    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');\r\n};\r\nclass CompressionHandler {\r\n    /**\r\n     * @param message Raw uncompressed message bytes\r\n     * @param compress Indicates whether the message should be compressed\r\n     * @return Framed message, compressed if applicable\r\n     */\r\n    async writeMessage(message, compress) {\r\n        let messageBuffer = message;\r\n        if (compress) {\r\n            messageBuffer = await this.compressMessage(messageBuffer);\r\n        }\r\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\r\n        output.writeUInt8(compress ? 1 : 0, 0);\r\n        output.writeUInt32BE(messageBuffer.length, 1);\r\n        messageBuffer.copy(output, 5);\r\n        return output;\r\n    }\r\n    /**\r\n     * @param data Framed message, possibly compressed\r\n     * @return Uncompressed message\r\n     */\r\n    async readMessage(data) {\r\n        const compressed = data.readUInt8(0) === 1;\r\n        let messageBuffer = data.slice(5);\r\n        if (compressed) {\r\n            messageBuffer = await this.decompressMessage(messageBuffer);\r\n        }\r\n        return messageBuffer;\r\n    }\r\n}\r\nclass IdentityHandler extends CompressionHandler {\r\n    async compressMessage(message) {\r\n        return message;\r\n    }\r\n    async writeMessage(message, compress) {\r\n        const output = Buffer.allocUnsafe(message.length + 5);\r\n        /* With \"identity\" compression, messages should always be marked as\r\n         * uncompressed */\r\n        output.writeUInt8(0, 0);\r\n        output.writeUInt32BE(message.length, 1);\r\n        message.copy(output, 5);\r\n        return output;\r\n    }\r\n    decompressMessage(message) {\r\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\r\n    }\r\n}\r\nclass DeflateHandler extends CompressionHandler {\r\n    constructor(maxRecvMessageLength) {\r\n        super();\r\n        this.maxRecvMessageLength = maxRecvMessageLength;\r\n    }\r\n    compressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            zlib.deflate(message, (err, output) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(output);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    decompressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            let totalLength = 0;\r\n            const messageParts = [];\r\n            const decompresser = zlib.createInflate();\r\n            decompresser.on('data', (chunk) => {\r\n                messageParts.push(chunk);\r\n                totalLength += chunk.byteLength;\r\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\r\n                    decompresser.destroy();\r\n                    reject({\r\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\r\n                    });\r\n                }\r\n            });\r\n            decompresser.on('end', () => {\r\n                resolve(Buffer.concat(messageParts));\r\n            });\r\n            decompresser.write(message);\r\n            decompresser.end();\r\n        });\r\n    }\r\n}\r\nclass GzipHandler extends CompressionHandler {\r\n    constructor(maxRecvMessageLength) {\r\n        super();\r\n        this.maxRecvMessageLength = maxRecvMessageLength;\r\n    }\r\n    compressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            zlib.gzip(message, (err, output) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(output);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    decompressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            let totalLength = 0;\r\n            const messageParts = [];\r\n            const decompresser = zlib.createGunzip();\r\n            decompresser.on('data', (chunk) => {\r\n                messageParts.push(chunk);\r\n                totalLength += chunk.byteLength;\r\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\r\n                    decompresser.destroy();\r\n                    reject({\r\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\r\n                    });\r\n                }\r\n            });\r\n            decompresser.on('end', () => {\r\n                resolve(Buffer.concat(messageParts));\r\n            });\r\n            decompresser.write(message);\r\n            decompresser.end();\r\n        });\r\n    }\r\n}\r\nclass UnknownHandler extends CompressionHandler {\r\n    constructor(compressionName) {\r\n        super();\r\n        this.compressionName = compressionName;\r\n    }\r\n    compressMessage(message) {\r\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\r\n    }\r\n    decompressMessage(message) {\r\n        // This should be unreachable\r\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\r\n    }\r\n}\r\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\r\n    switch (compressionName) {\r\n        case 'identity':\r\n            return new IdentityHandler();\r\n        case 'deflate':\r\n            return new DeflateHandler(maxReceiveMessageSize);\r\n        case 'gzip':\r\n            return new GzipHandler(maxReceiveMessageSize);\r\n        default:\r\n            return new UnknownHandler(compressionName);\r\n    }\r\n}\r\nclass CompressionFilter extends filter_1.BaseFilter {\r\n    constructor(channelOptions, sharedFilterConfig) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.sharedFilterConfig = sharedFilterConfig;\r\n        this.sendCompression = new IdentityHandler();\r\n        this.receiveCompression = new IdentityHandler();\r\n        this.currentCompressionAlgorithm = 'identity';\r\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\r\n        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\r\n        if (compressionAlgorithmKey !== undefined) {\r\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\r\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\r\n                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === void 0 ? void 0 : _c.split(',');\r\n                /**\r\n                 * There are two possible situations here:\r\n                 * 1) We don't have any info yet from the server about what compression it supports\r\n                 *    In that case we should just use what the client tells us to use\r\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\r\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\r\n                 */\r\n                if (!serverSupportedEncodings ||\r\n                    serverSupportedEncodings.includes(clientSelectedEncoding)) {\r\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\r\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\r\n                }\r\n            }\r\n            else {\r\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\r\n            }\r\n        }\r\n    }\r\n    async sendMetadata(metadata) {\r\n        const headers = await metadata;\r\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\r\n        headers.set('accept-encoding', 'identity');\r\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\r\n        if (this.currentCompressionAlgorithm === 'identity') {\r\n            headers.remove('grpc-encoding');\r\n        }\r\n        else {\r\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\r\n        }\r\n        return headers;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        const receiveEncoding = metadata.get('grpc-encoding');\r\n        if (receiveEncoding.length > 0) {\r\n            const encoding = receiveEncoding[0];\r\n            if (typeof encoding === 'string') {\r\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\r\n            }\r\n        }\r\n        metadata.remove('grpc-encoding');\r\n        /* Check to see if the compression we're using to send messages is supported by the server\r\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\r\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\r\n        if (serverSupportedEncodingsHeader) {\r\n            this.sharedFilterConfig.serverSupportedEncodingHeader =\r\n                serverSupportedEncodingsHeader;\r\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\r\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\r\n                this.sendCompression = new IdentityHandler();\r\n                this.currentCompressionAlgorithm = 'identity';\r\n            }\r\n        }\r\n        metadata.remove('grpc-accept-encoding');\r\n        return metadata;\r\n    }\r\n    async sendMessage(message) {\r\n        var _a;\r\n        /* This filter is special. The input message is the bare message bytes,\r\n         * and the output is a framed and possibly compressed message. For this\r\n         * reason, this filter should be at the bottom of the filter stack */\r\n        const resolvedMessage = await message;\r\n        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {\r\n            throw {\r\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`\r\n            };\r\n        }\r\n        let compress;\r\n        if (this.sendCompression instanceof IdentityHandler) {\r\n            compress = false;\r\n        }\r\n        else {\r\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\r\n        }\r\n        return {\r\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\r\n            flags: resolvedMessage.flags,\r\n        };\r\n    }\r\n    async receiveMessage(message) {\r\n        /* This filter is also special. The input message is framed and possibly\r\n         * compressed, and the output message is deframed and uncompressed. So\r\n         * this is another reason that this filter should be at the bottom of the\r\n         * filter stack. */\r\n        return this.receiveCompression.readMessage(await message);\r\n    }\r\n}\r\nexports.CompressionFilter = CompressionFilter;\r\nclass CompressionFilterFactory {\r\n    constructor(channel, options) {\r\n        this.options = options;\r\n        this.sharedFilterConfig = {};\r\n    }\r\n    createFilter() {\r\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\r\n    }\r\n}\r\nexports.CompressionFilterFactory = CompressionFilterFactory;\r\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcseUJBQXlCO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQ0FBaUMsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RiwwQkFBMEI7QUFDdkgscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHFCQUFxQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscUJBQXFCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLHdCQUF3QjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDBCQUEwQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzP2ViZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IHZvaWQgMDtcclxuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xyXG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gKGtleSkgPT4ge1xyXG4gICAgcmV0dXJuICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1trZXldID09PSAnc3RyaW5nJyk7XHJcbn07XHJcbmNsYXNzIENvbXByZXNzaW9uSGFuZGxlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFJhdyB1bmNvbXByZXNzZWQgbWVzc2FnZSBieXRlc1xyXG4gICAgICogQHBhcmFtIGNvbXByZXNzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBjb21wcmVzc2VkXHJcbiAgICAgKiBAcmV0dXJuIEZyYW1lZCBtZXNzYWdlLCBjb21wcmVzc2VkIGlmIGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChjb21wcmVzcykge1xyXG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5jb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlQnVmZmVyLmxlbmd0aCArIDUpO1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KGNvbXByZXNzID8gMSA6IDAsIDApO1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2VCdWZmZXIubGVuZ3RoLCAxKTtcclxuICAgICAgICBtZXNzYWdlQnVmZmVyLmNvcHkob3V0cHV0LCA1KTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBGcmFtZWQgbWVzc2FnZSwgcG9zc2libHkgY29tcHJlc3NlZFxyXG4gICAgICogQHJldHVybiBVbmNvbXByZXNzZWQgbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkTWVzc2FnZShkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGRhdGEucmVhZFVJbnQ4KDApID09PSAxO1xyXG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gZGF0YS5zbGljZSg1KTtcclxuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xyXG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdWZmZXI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgSWRlbnRpdHlIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcclxuICAgIGFzeW5jIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZS5sZW5ndGggKyA1KTtcclxuICAgICAgICAvKiBXaXRoIFwiaWRlbnRpdHlcIiBjb21wcmVzc2lvbiwgbWVzc2FnZXMgc2hvdWxkIGFsd2F5cyBiZSBtYXJrZWQgYXNcclxuICAgICAgICAgKiB1bmNvbXByZXNzZWQgKi9cclxuICAgICAgICBvdXRwdXQud3JpdGVVSW50OCgwLCAwKTtcclxuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlLmxlbmd0aCwgMSk7XHJcbiAgICAgICAgbWVzc2FnZS5jb3B5KG91dHB1dCwgNSk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSZWNlaXZlZCBjb21wcmVzc2VkIG1lc3NhZ2UgYnV0IFwiZ3JwYy1lbmNvZGluZ1wiIGhlYWRlciB3YXMgaWRlbnRpdHknKSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmbGF0ZUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xyXG4gICAgY29uc3RydWN0b3IobWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggPSBtYXhSZWN2TWVzc2FnZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgemxpYi5kZWZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVJbmZsYXRlKCk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZGF0YScsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoICE9PSAtMSAmJiB0b3RhbExlbmd0aCA+IHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQobWVzc2FnZVBhcnRzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHemlwSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCA9IG1heFJlY3ZNZXNzYWdlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB6bGliLmd6aXAobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUd1bnppcCgpO1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdG90YWxMZW5ndGggPiB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSB0aGF0IGRlY29tcHJlc3NlcyB0byBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RofWBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVjb21wcmVzc2VyLndyaXRlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZXIuZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVW5rbm93bkhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29tcHJlc3Npb25OYW1lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTmFtZSA9IGNvbXByZXNzaW9uTmFtZTtcclxuICAgIH1cclxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xyXG4gICAgfVxyXG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQ6ICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENvbXByZXNzaW9uSGFuZGxlcihjb21wcmVzc2lvbk5hbWUsIG1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xyXG4gICAgc3dpdGNoIChjb21wcmVzc2lvbk5hbWUpIHtcclxuICAgICAgICBjYXNlICdpZGVudGl0eSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XHJcbiAgICAgICAgY2FzZSAnZGVmbGF0ZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZUhhbmRsZXIobWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcclxuICAgICAgICBjYXNlICdnemlwJzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHemlwSGFuZGxlcihtYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbE9wdGlvbnMsIHNoYXJlZEZpbHRlckNvbmZpZykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSBzaGFyZWRGaWx0ZXJDb25maWc7XHJcbiAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0nXTtcclxuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoID0gKF9hID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcclxuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlTGVuZ3RoID0gKF9iID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcclxuICAgICAgICBpZiAoY29tcHJlc3Npb25BbGdvcml0aG1LZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleShjb21wcmVzc2lvbkFsZ29yaXRobUtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IChfYyA9IHNoYXJlZEZpbHRlckNvbmZpZy5zZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxyXG4gICAgICAgICAgICAgICAgICogMSkgV2UgZG9uJ3QgaGF2ZSBhbnkgaW5mbyB5ZXQgZnJvbSB0aGUgc2VydmVyIGFib3V0IHdoYXQgY29tcHJlc3Npb24gaXQgc3VwcG9ydHNcclxuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBzaG91bGQganVzdCB1c2Ugd2hhdCB0aGUgY2xpZW50IHRlbGxzIHVzIHRvIHVzZVxyXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoZSBlbmNvZGluZyBjaG9zZW4gYnkgdGhlIGNsaWVudCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIGl0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKGNsaWVudFNlbGVjdGVkRW5jb2RpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSBjbGllbnRTZWxlY3RlZEVuY29kaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtIG9wdGlvbjogJHtjb21wcmVzc2lvbkFsZ29yaXRobUtleX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBtZXRhZGF0YTtcclxuICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyk7XHJcbiAgICAgICAgaGVhZGVycy5zZXQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScpO1xyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VuZCB0aGUgaGVhZGVyIGlmIGl0J3MgXCJpZGVudGl0eVwiIC0gIGJlaGF2aW9yIGlzIGlkZW50aWNhbDsgc2F2ZSB0aGUgYmFuZHdpZHRoXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID09PSAnaWRlbnRpdHknKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnMucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1lbmNvZGluZycsIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCByZWNlaXZlRW5jb2RpbmcgPSBtZXRhZGF0YS5nZXQoJ2dycGMtZW5jb2RpbmcnKTtcclxuICAgICAgICBpZiAocmVjZWl2ZUVuY29kaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZWNlaXZlRW5jb2RpbmdbMF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcihlbmNvZGluZywgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWVuY29kaW5nJyk7XHJcbiAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjb21wcmVzc2lvbiB3ZSdyZSB1c2luZyB0byBzZW5kIG1lc3NhZ2VzIGlzIHN1cHBvcnRlZCBieSB0aGUgc2VydmVyXHJcbiAgICAgICAgICogSWYgbm90LCByZXNldCB0aGUgc2VuZENvbXByZXNzaW9uIGZpbHRlciBhbmQgaGF2ZSBpdCB1c2UgdGhlIGRlZmF1bHQgSWRlbnRpdHlIYW5kbGVyICovXHJcbiAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyID0gbWV0YWRhdGEuZ2V0KCdncnBjLWFjY2VwdC1lbmNvZGluZycpWzBdO1xyXG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIgPVxyXG4gICAgICAgICAgICAgICAgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyO1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXModGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyB0aGUgYmFyZSBtZXNzYWdlIGJ5dGVzLFxyXG4gICAgICAgICAqIGFuZCB0aGUgb3V0cHV0IGlzIGEgZnJhbWVkIGFuZCBwb3NzaWJseSBjb21wcmVzc2VkIG1lc3NhZ2UuIEZvciB0aGlzXHJcbiAgICAgICAgICogcmVhc29uLCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsdGVyIHN0YWNrICovXHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcclxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgcmVzb2x2ZWRNZXNzYWdlLm1lc3NhZ2UubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZUxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYEF0dGVtcHRlZCB0byBzZW5kIG1lc3NhZ2Ugd2l0aCBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFNlbmRNZXNzYWdlTGVuZ3RofWBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbXByZXNzO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbmRDb21wcmVzc2lvbiBpbnN0YW5jZW9mIElkZW50aXR5SGFuZGxlcikge1xyXG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxyXG4gICAgICAgICAgICBmbGFnczogcmVzb2x2ZWRNZXNzYWdlLmZsYWdzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgYWxzbyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyBmcmFtZWQgYW5kIHBvc3NpYmx5XHJcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xyXG4gICAgICAgICAqIHRoaXMgaXMgYW5vdGhlciByZWFzb24gdGhhdCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGVcclxuICAgICAgICAgKiBmaWx0ZXIgc3RhY2suICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcclxuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0ge307XHJcbiAgICB9XHJcbiAgICBjcmVhdGVGaWx0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2lvbkZpbHRlcih0aGlzLm9wdGlvbnMsIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectivityState = void 0;\r\nvar ConnectivityState;\r\n(function (ConnectivityState) {\r\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\r\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\r\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\r\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\r\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\r\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));\r\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IseUJBQXlCLHlCQUF5QjtBQUMzRSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanM/OGIwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IHZvaWQgMDtcclxudmFyIENvbm5lY3Rpdml0eVN0YXRlO1xyXG4oZnVuY3Rpb24gKENvbm5lY3Rpdml0eVN0YXRlKSB7XHJcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xyXG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcclxuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiUkVBRFlcIl0gPSAyXSA9IFwiUkVBRFlcIjtcclxuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAzXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcclxuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiU0hVVERPV05cIl0gPSA0XSA9IFwiU0hVVERPV05cIjtcclxufSkoQ29ubmVjdGl2aXR5U3RhdGUgfHwgKGV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSBDb25uZWN0aXZpdHlTdGF0ZSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpdml0eS1zdGF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\r\nvar Status;\r\n(function (Status) {\r\n    Status[Status[\"OK\"] = 0] = \"OK\";\r\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\r\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\r\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\r\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\r\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\r\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\r\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\r\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\r\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\r\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\r\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\r\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\r\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\r\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\r\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\r\n})(Status || (exports.Status = Status = {}));\r\nvar LogVerbosity;\r\n(function (LogVerbosity) {\r\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\r\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\r\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\r\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\r\n/**\r\n * NOTE: This enum is not currently used in any implemented API in this\r\n * library. It is included only for type parity with the other implementation.\r\n */\r\nvar Propagate;\r\n(function (Propagate) {\r\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\r\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\r\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\r\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\r\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\r\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\r\n})(Propagate || (exports.Propagate = Propagate = {}));\r\n// -1 means unlimited\r\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\r\n// 4 MB default\r\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\r\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsdUNBQXVDLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYSxjQUFjLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMENBQTBDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbnN0YW50cy5qcz8xYTFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEggPSBleHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSBleHBvcnRzLlByb3BhZ2F0ZSA9IGV4cG9ydHMuTG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5TdGF0dXMgPSB2b2lkIDA7XHJcbnZhciBTdGF0dXM7XHJcbihmdW5jdGlvbiAoU3RhdHVzKSB7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IDNdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiQUxSRUFEWV9FWElTVFNcIl0gPSA2XSA9IFwiQUxSRUFEWV9FWElTVFNcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJGQUlMRURfUFJFQ09ORElUSU9OXCJdID0gOV0gPSBcIkZBSUxFRF9QUkVDT05ESVRJT05cIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJVTklNUExFTUVOVEVEXCJdID0gMTJdID0gXCJVTklNUExFTUVOVEVEXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiREFUQV9MT1NTXCJdID0gMTVdID0gXCJEQVRBX0xPU1NcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xyXG59KShTdGF0dXMgfHwgKGV4cG9ydHMuU3RhdHVzID0gU3RhdHVzID0ge30pKTtcclxudmFyIExvZ1ZlcmJvc2l0eTtcclxuKGZ1bmN0aW9uIChMb2dWZXJib3NpdHkpIHtcclxuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xyXG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIklORk9cIl0gPSAxXSA9IFwiSU5GT1wiO1xyXG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiTk9ORVwiXSA9IDNdID0gXCJOT05FXCI7XHJcbn0pKExvZ1ZlcmJvc2l0eSB8fCAoZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBMb2dWZXJib3NpdHkgPSB7fSkpO1xyXG4vKipcclxuICogTk9URTogVGhpcyBlbnVtIGlzIG5vdCBjdXJyZW50bHkgdXNlZCBpbiBhbnkgaW1wbGVtZW50ZWQgQVBJIGluIHRoaXNcclxuICogbGlicmFyeS4gSXQgaXMgaW5jbHVkZWQgb25seSBmb3IgdHlwZSBwYXJpdHkgd2l0aCB0aGUgb3RoZXIgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG52YXIgUHJvcGFnYXRlO1xyXG4oZnVuY3Rpb24gKFByb3BhZ2F0ZSkge1xyXG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XHJcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0VOU1VTX1NUQVRTX0NPTlRFWFRcIl0gPSAyXSA9IFwiQ0VOU1VTX1NUQVRTX0NPTlRFWFRcIjtcclxuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDRU5TVVNfVFJBQ0lOR19DT05URVhUXCJdID0gNF0gPSBcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIjtcclxuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2luY2x1ZGUvZ3JwYy9pbXBsL2NvZGVnZW4vcHJvcGFnYXRpb25fYml0cy5oI0w0M1xyXG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFRkFVTFRTXCJdID0gNjU1MzVdID0gXCJERUZBVUxUU1wiO1xyXG59KShQcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0gUHJvcGFnYXRlID0ge30pKTtcclxuLy8gLTEgbWVhbnMgdW5saW1pdGVkXHJcbmV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IC0xO1xyXG4vLyA0IE1CIGRlZmF1bHRcclxuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gNCAqIDEwMjQgKiAxMDI0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\r\n    constants_1.Status.OK,\r\n    constants_1.Status.INVALID_ARGUMENT,\r\n    constants_1.Status.NOT_FOUND,\r\n    constants_1.Status.ALREADY_EXISTS,\r\n    constants_1.Status.FAILED_PRECONDITION,\r\n    constants_1.Status.ABORTED,\r\n    constants_1.Status.OUT_OF_RANGE,\r\n    constants_1.Status.DATA_LOSS,\r\n];\r\nfunction restrictControlPlaneStatusCode(code, details) {\r\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\r\n        return {\r\n            code: constants_1.Status.INTERNAL,\r\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,\r\n        };\r\n    }\r\n    else {\r\n        return { code, details };\r\n    }\r\n}\r\n//# sourceMappingURL=control-plane-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0M7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNLEVBQUUsMEJBQTBCLEVBQUUsUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbnRyb2wtcGxhbmUtc3RhdHVzLmpzPzhhZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTID0gW1xyXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxyXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFMUkVBRFlfRVhJU1RTLFxyXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUJPUlRFRCxcclxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5PVVRfT0ZfUkFOR0UsXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTLFxyXG5dO1xyXG5mdW5jdGlvbiByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY29kZSwgZGV0YWlscykge1xyXG4gICAgaWYgKElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgZGV0YWlsczogYEludmFsaWQgc3RhdHVzIGZyb20gY29udHJvbCBwbGFuZTogJHtjb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tjb2RlXX0gJHtkZXRhaWxzfWAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IGNvZGUsIGRldGFpbHMgfTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.minDeadline = minDeadline;\r\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\r\nexports.getRelativeTimeout = getRelativeTimeout;\r\nexports.deadlineToString = deadlineToString;\r\nexports.formatDateDifference = formatDateDifference;\r\nfunction minDeadline(...deadlineList) {\r\n    let minValue = Infinity;\r\n    for (const deadline of deadlineList) {\r\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\r\n        if (deadlineMsecs < minValue) {\r\n            minValue = deadlineMsecs;\r\n        }\r\n    }\r\n    return minValue;\r\n}\r\nconst units = [\r\n    ['m', 1],\r\n    ['S', 1000],\r\n    ['M', 60 * 1000],\r\n    ['H', 60 * 60 * 1000],\r\n];\r\nfunction getDeadlineTimeoutString(deadline) {\r\n    const now = new Date().getTime();\r\n    if (deadline instanceof Date) {\r\n        deadline = deadline.getTime();\r\n    }\r\n    const timeoutMs = Math.max(deadline - now, 0);\r\n    for (const [unit, factor] of units) {\r\n        const amount = timeoutMs / factor;\r\n        if (amount < 1e8) {\r\n            return String(Math.ceil(amount)) + unit;\r\n        }\r\n    }\r\n    throw new Error('Deadline is too far in the future');\r\n}\r\n/**\r\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\r\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\r\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\r\n * This number of milliseconds is almost 25 days.\r\n */\r\nconst MAX_TIMEOUT_TIME = 2147483647;\r\n/**\r\n * Get the timeout value that should be passed to setTimeout now for the timer\r\n * to end at the deadline. For any deadline before now, the timer should end\r\n * immediately, represented by a value of 0. For any deadline more than\r\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\r\n * end at that time, so it is treated as infinitely far in the future.\r\n * @param deadline\r\n * @returns\r\n */\r\nfunction getRelativeTimeout(deadline) {\r\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\r\n    const now = new Date().getTime();\r\n    const timeout = deadlineMs - now;\r\n    if (timeout < 0) {\r\n        return 0;\r\n    }\r\n    else if (timeout > MAX_TIMEOUT_TIME) {\r\n        return Infinity;\r\n    }\r\n    else {\r\n        return timeout;\r\n    }\r\n}\r\nfunction deadlineToString(deadline) {\r\n    if (deadline instanceof Date) {\r\n        return deadline.toISOString();\r\n    }\r\n    else {\r\n        const dateDeadline = new Date(deadline);\r\n        if (Number.isNaN(dateDeadline.getTime())) {\r\n            return '' + deadline;\r\n        }\r\n        else {\r\n            return dateDeadline.toISOString();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Calculate the difference between two dates as a number of seconds and format\r\n * it as a string.\r\n * @param startDate\r\n * @param endDate\r\n * @returns\r\n */\r\nfunction formatDateDifference(startDate, endDate) {\r\n    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';\r\n}\r\n//# sourceMappingURL=deadline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2RlYWRsaW5lLmpzPzVlZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubWluRGVhZGxpbmUgPSBtaW5EZWFkbGluZTtcclxuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XHJcbmV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZ2V0UmVsYXRpdmVUaW1lb3V0O1xyXG5leHBvcnRzLmRlYWRsaW5lVG9TdHJpbmcgPSBkZWFkbGluZVRvU3RyaW5nO1xyXG5leHBvcnRzLmZvcm1hdERhdGVEaWZmZXJlbmNlID0gZm9ybWF0RGF0ZURpZmZlcmVuY2U7XHJcbmZ1bmN0aW9uIG1pbkRlYWRsaW5lKC4uLmRlYWRsaW5lTGlzdCkge1xyXG4gICAgbGV0IG1pblZhbHVlID0gSW5maW5pdHk7XHJcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGRlYWRsaW5lTXNlY3MgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcclxuICAgICAgICBpZiAoZGVhZGxpbmVNc2VjcyA8IG1pblZhbHVlKSB7XHJcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluVmFsdWU7XHJcbn1cclxuY29uc3QgdW5pdHMgPSBbXHJcbiAgICBbJ20nLCAxXSxcclxuICAgIFsnUycsIDEwMDBdLFxyXG4gICAgWydNJywgNjAgKiAxMDAwXSxcclxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcclxuXTtcclxuZnVuY3Rpb24gZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nKGRlYWRsaW5lKSB7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGlmIChkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICBkZWFkbGluZSA9IGRlYWRsaW5lLmdldFRpbWUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRpbWVvdXRNcyA9IE1hdGgubWF4KGRlYWRsaW5lIC0gbm93LCAwKTtcclxuICAgIGZvciAoY29uc3QgW3VuaXQsIGZhY3Rvcl0gb2YgdW5pdHMpIHtcclxuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XHJcbiAgICAgICAgaWYgKGFtb3VudCA8IDFlOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGguY2VpbChhbW91bnQpKSArIHVuaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWFkbGluZSBpcyB0b28gZmFyIGluIHRoZSBmdXR1cmUnKTtcclxufVxyXG4vKipcclxuICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjc2V0dGltZW91dGNhbGxiYWNrLWRlbGF5LWFyZ3NcclxuICogSW4gcGFydGljdWxhciwgXCJXaGVuIGRlbGF5IGlzIGxhcmdlciB0aGFuIDIxNDc0ODM2NDcgb3IgbGVzcyB0aGFuIDEsIHRoZVxyXG4gKiBkZWxheSB3aWxsIGJlIHNldCB0byAxLiBOb24taW50ZWdlciBkZWxheXMgYXJlIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlwiXHJcbiAqIFRoaXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpcyBhbG1vc3QgMjUgZGF5cy5cclxuICovXHJcbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xyXG4vKipcclxuICogR2V0IHRoZSB0aW1lb3V0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBzZXRUaW1lb3V0IG5vdyBmb3IgdGhlIHRpbWVyXHJcbiAqIHRvIGVuZCBhdCB0aGUgZGVhZGxpbmUuIEZvciBhbnkgZGVhZGxpbmUgYmVmb3JlIG5vdywgdGhlIHRpbWVyIHNob3VsZCBlbmRcclxuICogaW1tZWRpYXRlbHksIHJlcHJlc2VudGVkIGJ5IGEgdmFsdWUgb2YgMC4gRm9yIGFueSBkZWFkbGluZSBtb3JlIHRoYW5cclxuICogTUFYX1RJTUVPVVRfVElNRSBtaWxsaXNlY29uZHMgaW4gdGhlIGZ1dHVyZSwgYSB0aW1lciBjYW5ub3QgYmUgc2V0IHRoYXQgd2lsbFxyXG4gKiBlbmQgYXQgdGhhdCB0aW1lLCBzbyBpdCBpcyB0cmVhdGVkIGFzIGluZmluaXRlbHkgZmFyIGluIHRoZSBmdXR1cmUuXHJcbiAqIEBwYXJhbSBkZWFkbGluZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVUaW1lb3V0KGRlYWRsaW5lKSB7XHJcbiAgICBjb25zdCBkZWFkbGluZU1zID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBkZWFkbGluZU1zIC0gbm93O1xyXG4gICAgaWYgKHRpbWVvdXQgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aW1lb3V0ID4gTUFYX1RJTUVPVVRfVElNRSkge1xyXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlYWRsaW5lVG9TdHJpbmcoZGVhZGxpbmUpIHtcclxuICAgIGlmIChkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICByZXR1cm4gZGVhZGxpbmUudG9JU09TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRhdGVEZWFkbGluZSA9IG5ldyBEYXRlKGRlYWRsaW5lKTtcclxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGVEZWFkbGluZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJyArIGRlYWRsaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVEZWFkbGluZS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGRhdGVzIGFzIGEgbnVtYmVyIG9mIHNlY29uZHMgYW5kIGZvcm1hdFxyXG4gKiBpdCBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHN0YXJ0RGF0ZVxyXG4gKiBAcGFyYW0gZW5kRGF0ZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZm9ybWF0RGF0ZURpZmZlcmVuY2Uoc3RhcnREYXRlLCBlbmREYXRlKSB7XHJcbiAgICByZXR1cm4gKChlbmREYXRlLmdldFRpbWUoKSAtIHN0YXJ0RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMCkudG9GaXhlZCgzKSArICdzJztcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWFkbGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.msToDuration = msToDuration;\r\nexports.durationToMs = durationToMs;\r\nexports.isDuration = isDuration;\r\nexports.parseDuration = parseDuration;\r\nfunction msToDuration(millis) {\r\n    return {\r\n        seconds: (millis / 1000) | 0,\r\n        nanos: ((millis % 1000) * 1000000) | 0,\r\n    };\r\n}\r\nfunction durationToMs(duration) {\r\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\r\n}\r\nfunction isDuration(value) {\r\n    return typeof value.seconds === 'number' && typeof value.nanos === 'number';\r\n}\r\nconst durationRegex = /^(\\d+)(?:\\.(\\d+))?s$/;\r\nfunction parseDuration(value) {\r\n    const match = value.match(durationRegex);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    return {\r\n        seconds: Number.parseInt(match[1], 10),\r\n        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, '0'), 10) : 0\r\n    };\r\n}\r\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2R1cmF0aW9uLmpzP2UxOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubXNUb0R1cmF0aW9uID0gbXNUb0R1cmF0aW9uO1xyXG5leHBvcnRzLmR1cmF0aW9uVG9NcyA9IGR1cmF0aW9uVG9NcztcclxuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcclxuZXhwb3J0cy5wYXJzZUR1cmF0aW9uID0gcGFyc2VEdXJhdGlvbjtcclxuZnVuY3Rpb24gbXNUb0R1cmF0aW9uKG1pbGxpcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzZWNvbmRzOiAobWlsbGlzIC8gMTAwMCkgfCAwLFxyXG4gICAgICAgIG5hbm9zOiAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkgfCAwLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkdXJhdGlvblRvTXMoZHVyYXRpb24pIHtcclxuICAgIHJldHVybiAoZHVyYXRpb24uc2Vjb25kcyAqIDEwMDAgKyBkdXJhdGlvbi5uYW5vcyAvIDEwMDAwMDApIHwgMDtcclxufVxyXG5mdW5jdGlvbiBpc0R1cmF0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XHJcbn1cclxuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eKFxcZCspKD86XFwuKFxcZCspKT9zJC87XHJcbmZ1bmN0aW9uIHBhcnNlRHVyYXRpb24odmFsdWUpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goZHVyYXRpb25SZWdleCk7XHJcbiAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlY29uZHM6IE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTApLFxyXG4gICAgICAgIG5hbm9zOiBtYXRjaFsyXSA/IE51bWJlci5wYXJzZUludChtYXRjaFsyXS5wYWRFbmQoOSwgJzAnKSwgMTApIDogMFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kdXJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/environment.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2024 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;\r\nexports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== void 0 ? _a : 'false') === 'true';\r\n//# sourceMappingURL=environment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZW52aXJvbm1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZW52aXJvbm1lbnQuanM/YjlhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjQgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbnZhciBfYTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIgPSB2b2lkIDA7XHJcbmV4cG9ydHMuR1JQQ19OT0RFX1VTRV9BTFRFUk5BVElWRV9SRVNPTFZFUiA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVVNFX0FMVEVSTkFUSVZFX1JFU09MVkVSKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZmFsc2UnKSA9PT0gJ3RydWUnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getErrorMessage = getErrorMessage;\r\nexports.getErrorCode = getErrorCode;\r\nfunction getErrorMessage(error) {\r\n    if (error instanceof Error) {\r\n        return error.message;\r\n    }\r\n    else {\r\n        return String(error);\r\n    }\r\n}\r\nfunction getErrorCode(error) {\r\n    if (typeof error === 'object' &&\r\n        error !== null &&\r\n        'code' in error &&\r\n        typeof error.code === 'number') {\r\n        return error.code;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanM/N2RkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XHJcbmV4cG9ydHMuZ2V0RXJyb3JDb2RlID0gZ2V0RXJyb3JDb2RlO1xyXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFcnJvckNvZGUoZXJyb3IpIHtcclxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcclxuICAgICAgICAnY29kZScgaW4gZXJyb3IgJiZcclxuICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gZXJyb3IuY29kZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\r\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\r\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\r\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\r\nObject.defineProperty(exports, \"createResolver\", ({ enumerable: true, get: function () { return resolver_1.createResolver; } }));\r\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\r\nObject.defineProperty(exports, \"splitHostPort\", ({ enumerable: true, get: function () { return uri_parser_1.splitHostPort; } }));\r\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\r\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\r\nObject.defineProperty(exports, \"parseDuration\", ({ enumerable: true, get: function () { return duration_1.parseDuration; } }));\r\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\r\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\r\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\r\nObject.defineProperty(exports, \"selectLbConfigFromList\", ({ enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } }));\r\nObject.defineProperty(exports, \"parseLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } }));\r\nObject.defineProperty(exports, \"isLoadBalancerNameRegistered\", ({ enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } }));\r\nvar load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\r\nObject.defineProperty(exports, \"LeafLoadBalancer\", ({ enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } }));\r\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\r\nObject.defineProperty(exports, \"endpointToString\", ({ enumerable: true, get: function () { return subchannel_address_1.endpointToString; } }));\r\nObject.defineProperty(exports, \"endpointHasAddress\", ({ enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } }));\r\nObject.defineProperty(exports, \"EndpointMap\", ({ enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } }));\r\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\r\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\r\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\r\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\r\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\r\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\r\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\r\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\r\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\r\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\r\nvar server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\r\nObject.defineProperty(exports, \"createServerCredentialsWithInterceptors\", ({ enumerable: true, get: function () { return server_credentials_1.createServerCredentialsWithInterceptors; } }));\r\nObject.defineProperty(exports, \"createCertificateProviderServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.createCertificateProviderServerCredentials; } }));\r\nvar certificate_provider_1 = __webpack_require__(/*! ./certificate-provider */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/certificate-provider.js\");\r\nObject.defineProperty(exports, \"FileWatcherCertificateProvider\", ({ enumerable: true, get: function () { return certificate_provider_1.FileWatcherCertificateProvider; } }));\r\nvar channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nObject.defineProperty(exports, \"createCertificateProviderChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.createCertificateProviderChannelCredentials; } }));\r\nvar internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\r\nObject.defineProperty(exports, \"SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX\", ({ enumerable: true, get: function () { return internal_channel_1.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX; } }));\r\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQyxHQUFHLG1EQUFtRCxHQUFHLHNDQUFzQyxHQUFHLGtEQUFrRCxHQUFHLCtDQUErQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLGlDQUFpQyxHQUFHLHdCQUF3QixHQUFHLG9DQUFvQyxHQUFHLGdDQUFnQyxHQUFHLDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QyxHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLFdBQVcsR0FBRyxhQUFhO0FBQzU5QixnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDM0csdUNBQXNDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3ZHLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnREFBK0MsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDMUgsaURBQWdELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzVILHdCQUF3QixtQkFBTyxDQUFDLDBGQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQy9DLG1FQUFrRSxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUNySyw0REFBMkQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDdkosMERBQXlELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQ25KLDREQUEyRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUN2SixnRUFBK0QsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDL0osaUNBQWlDLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3JFLG9EQUFtRCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUNsSiwyQkFBMkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDekQsNkRBQTRELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQzlKLG9EQUFtRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM1SSxzREFBcUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDaEosK0NBQThDLEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ2xJLG9DQUFvQyxtQkFBTyxDQUFDLGtIQUErQjtBQUMzRSw0REFBMkQsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDckssZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLHFEQUFvRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNsSSwrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEgsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0Isd0RBQXVELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3ZJLDZCQUE2QixtQkFBTyxDQUFDLG9HQUF3QjtBQUM3RCx5REFBd0QsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDeEosMkJBQTJCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQ3pELDJFQUEwRSxFQUFFLHFDQUFxQyx3RUFBd0UsRUFBQztBQUMxTCw4RUFBNkUsRUFBRSxxQ0FBcUMsMkVBQTJFLEVBQUM7QUFDaE0sNkJBQTZCLG1CQUFPLENBQUMsb0dBQXdCO0FBQzdELGtFQUFpRSxFQUFFLHFDQUFxQyxpRUFBaUUsRUFBQztBQUMxSyw0QkFBNEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDM0QsK0VBQThFLEVBQUUscUNBQXFDLDZFQUE2RSxFQUFDO0FBQ25NLHlCQUF5QixtQkFBTyxDQUFDLDRGQUFvQjtBQUNyRCxzRUFBcUUsRUFBRSxxQ0FBcUMsaUVBQWlFLEVBQUM7QUFDOUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzPzQzMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYID0gZXhwb3J0cy5jcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy5GaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXIgPSBleHBvcnRzLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyA9IGV4cG9ydHMuY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzID0gZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBleHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VGaWx0ZXIgPSBleHBvcnRzLlBpY2tSZXN1bHRUeXBlID0gZXhwb3J0cy5RdWV1ZVBpY2tlciA9IGV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBleHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IGV4cG9ydHMuRW5kcG9pbnRNYXAgPSBleHBvcnRzLmVuZHBvaW50SGFzQWRkcmVzcyA9IGV4cG9ydHMuZW5kcG9pbnRUb1N0cmluZyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IGV4cG9ydHMuTGVhZkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGV4cG9ydHMucGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnID0gZXhwb3J0cy5zZWxlY3RMYkNvbmZpZ0Zyb21MaXN0ID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5wYXJzZUR1cmF0aW9uID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcclxudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEudHJhY2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcclxudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcclxudmFyIHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaVRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmc7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNwbGl0SG9zdFBvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0OyB9IH0pO1xyXG52YXIgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUR1cmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkdXJhdGlvbl8xLnBhcnNlRHVyYXRpb247IH0gfSk7XHJcbnZhciBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xyXG52YXIgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0TGJDb25maWdGcm9tTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnNlbGVjdExiQ29uZmlnRnJvbUxpc3Q7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7IH0gfSk7XHJcbnZhciBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGVhZkxvYWRCYWxhbmNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0XzEuTGVhZkxvYWRCYWxhbmNlcjsgfSB9KTtcclxudmFyIHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmRwb2ludFRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5lbmRwb2ludFRvU3RyaW5nOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmRwb2ludEhhc0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50SGFzQWRkcmVzczsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kcG9pbnRNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLkVuZHBvaW50TWFwOyB9IH0pO1xyXG52YXIgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyOyB9IH0pO1xyXG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuYXZhaWxhYmxlUGlja2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVldWVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlF1ZXVlUGlja2VyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XHJcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUZpbHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyXzEuQmFzZUZpbHRlcjsgfSB9KTtcclxudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWx0ZXJTdGFja0ZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeTsgfSB9KTtcclxudmFyIGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XHJcbnZhciBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VTdWJjaGFubmVsV3JhcHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXI7IH0gfSk7XHJcbnZhciBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlU2VydmVyQ3JlZGVudGlhbHNXaXRoSW50ZXJjZXB0b3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5jcmVhdGVTZXJ2ZXJDcmVkZW50aWFsc1dpdGhJbnRlcmNlcHRvcnM7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzOyB9IH0pO1xyXG52YXIgY2VydGlmaWNhdGVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2NlcnRpZmljYXRlLXByb3ZpZGVyXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWxlV2F0Y2hlckNlcnRpZmljYXRlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNlcnRpZmljYXRlX3Byb3ZpZGVyXzEuRmlsZVdhdGNoZXJDZXJ0aWZpY2F0ZVByb3ZpZGVyOyB9IH0pO1xyXG52YXIgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlckNoYW5uZWxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF9jcmVkZW50aWFsc18xLmNyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJDaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XHJcbnZhciBpbnRlcm5hbF9jaGFubmVsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC1jaGFubmVsXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTVUJDSEFOTkVMX0FSR1NfRVhDTFVERV9LRVlfUFJFRklYXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9jaGFubmVsXzEuU1VCQ0hBTk5FTF9BUkdTX0VYQ0xVREVfS0VZX1BSRUZJWDsgfSB9KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FilterStackFactory = exports.FilterStack = void 0;\r\nclass FilterStack {\r\n    constructor(filters) {\r\n        this.filters = filters;\r\n    }\r\n    sendMetadata(metadata) {\r\n        let result = metadata;\r\n        for (let i = 0; i < this.filters.length; i++) {\r\n            result = this.filters[i].sendMetadata(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        let result = metadata;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveMetadata(result);\r\n        }\r\n        return result;\r\n    }\r\n    sendMessage(message) {\r\n        let result = message;\r\n        for (let i = 0; i < this.filters.length; i++) {\r\n            result = this.filters[i].sendMessage(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveMessage(message) {\r\n        let result = message;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveMessage(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveTrailers(status) {\r\n        let result = status;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveTrailers(result);\r\n        }\r\n        return result;\r\n    }\r\n    push(filters) {\r\n        this.filters.unshift(...filters);\r\n    }\r\n    getFilters() {\r\n        return this.filters;\r\n    }\r\n}\r\nexports.FilterStack = FilterStack;\r\nclass FilterStackFactory {\r\n    constructor(factories) {\r\n        this.factories = factories;\r\n    }\r\n    push(filterFactories) {\r\n        this.factories.unshift(...filterFactories);\r\n    }\r\n    clone() {\r\n        return new FilterStackFactory([...this.factories]);\r\n    }\r\n    createFilter() {\r\n        return new FilterStack(this.factories.map(factory => factory.createFilter()));\r\n    }\r\n}\r\nexports.FilterStackFactory = FilterStackFactory;\r\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzP2FlZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gZXhwb3J0cy5GaWx0ZXJTdGFjayA9IHZvaWQgMDtcclxuY2xhc3MgRmlsdGVyU3RhY2sge1xyXG4gICAgY29uc3RydWN0b3IoZmlsdGVycykge1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XHJcbiAgICB9XHJcbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXRhZGF0YShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXRhZGF0YShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWVzc2FnZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXNzYWdlKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXR1cztcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlVHJhaWxlcnMocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHB1c2goZmlsdGVycykge1xyXG4gICAgICAgIHRoaXMuZmlsdGVycy51bnNoaWZ0KC4uLmZpbHRlcnMpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmlsdGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRmlsdGVyU3RhY2sgPSBGaWx0ZXJTdGFjaztcclxuY2xhc3MgRmlsdGVyU3RhY2tGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKGZhY3Rvcmllcykge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xyXG4gICAgfVxyXG4gICAgcHVzaChmaWx0ZXJGYWN0b3JpZXMpIHtcclxuICAgICAgICB0aGlzLmZhY3Rvcmllcy51bnNoaWZ0KC4uLmZpbHRlckZhY3Rvcmllcyk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrRmFjdG9yeShbLi4udGhpcy5mYWN0b3JpZXNdKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrKHRoaXMuZmFjdG9yaWVzLm1hcChmYWN0b3J5ID0+IGZhY3RvcnkuY3JlYXRlRmlsdGVyKCkpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IEZpbHRlclN0YWNrRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLXN0YWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseFilter = void 0;\r\nclass BaseFilter {\r\n    async sendMetadata(metadata) {\r\n        return metadata;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        return metadata;\r\n    }\r\n    async sendMessage(message) {\r\n        return message;\r\n    }\r\n    async receiveMessage(message) {\r\n        return message;\r\n    }\r\n    receiveTrailers(status) {\r\n        return status;\r\n    }\r\n}\r\nexports.BaseFilter = BaseFilter;\r\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzP2NiYWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQmFzZUZpbHRlciA9IHZvaWQgMDtcclxuY2xhc3MgQmFzZUZpbHRlciB7XHJcbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhc2VGaWx0ZXIgPSBCYXNlRmlsdGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parseCIDR = parseCIDR;\r\nexports.mapProxyName = mapProxyName;\r\nexports.getProxiedConnection = getProxiedConnection;\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst url_1 = __webpack_require__(/*! url */ \"url\");\r\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\r\nconst TRACER_NAME = 'proxy';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nfunction getProxyInfo() {\r\n    let proxyEnv = '';\r\n    let envVar = '';\r\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\r\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\r\n     * fallback behavior can be removed if there's a demand for it.\r\n     */\r\n    if (process.env.grpc_proxy) {\r\n        envVar = 'grpc_proxy';\r\n        proxyEnv = process.env.grpc_proxy;\r\n    }\r\n    else if (process.env.https_proxy) {\r\n        envVar = 'https_proxy';\r\n        proxyEnv = process.env.https_proxy;\r\n    }\r\n    else if (process.env.http_proxy) {\r\n        envVar = 'http_proxy';\r\n        proxyEnv = process.env.http_proxy;\r\n    }\r\n    else {\r\n        return {};\r\n    }\r\n    let proxyUrl;\r\n    try {\r\n        proxyUrl = new url_1.URL(proxyEnv);\r\n    }\r\n    catch (e) {\r\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\r\n        return {};\r\n    }\r\n    if (proxyUrl.protocol !== 'http:') {\r\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\r\n        return {};\r\n    }\r\n    let userCred = null;\r\n    if (proxyUrl.username) {\r\n        if (proxyUrl.password) {\r\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\r\n            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);\r\n        }\r\n        else {\r\n            userCred = proxyUrl.username;\r\n        }\r\n    }\r\n    const hostname = proxyUrl.hostname;\r\n    let port = proxyUrl.port;\r\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\r\n     * 80. We need to set that explicitly here if it is omitted because otherwise\r\n     * it will use gRPC's default port 443. */\r\n    if (port === '') {\r\n        port = '80';\r\n    }\r\n    const result = {\r\n        address: `${hostname}:${port}`,\r\n    };\r\n    if (userCred) {\r\n        result.creds = userCred;\r\n    }\r\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\r\n    return result;\r\n}\r\nfunction getNoProxyHostList() {\r\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\r\n    let noProxyStr = process.env.no_grpc_proxy;\r\n    let envVar = 'no_grpc_proxy';\r\n    if (!noProxyStr) {\r\n        noProxyStr = process.env.no_proxy;\r\n        envVar = 'no_proxy';\r\n    }\r\n    if (noProxyStr) {\r\n        trace('No proxy server list set by environment variable ' + envVar);\r\n        return noProxyStr.split(',');\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n/*\r\n * The groups correspond to CIDR parts as follows:\r\n * 1. ip\r\n * 2. prefixLength\r\n */\r\nfunction parseCIDR(cidrString) {\r\n    const splitRange = cidrString.split('/');\r\n    if (splitRange.length !== 2) {\r\n        return null;\r\n    }\r\n    const prefixLength = parseInt(splitRange[1], 10);\r\n    if (!(0, net_1.isIPv4)(splitRange[0]) || Number.isNaN(prefixLength) || prefixLength < 0 || prefixLength > 32) {\r\n        return null;\r\n    }\r\n    return {\r\n        ip: ipToInt(splitRange[0]),\r\n        prefixLength: prefixLength\r\n    };\r\n}\r\nfunction ipToInt(ip) {\r\n    return ip.split(\".\").reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);\r\n}\r\nfunction isIpInCIDR(cidr, serverHost) {\r\n    const ip = cidr.ip;\r\n    const mask = -1 << (32 - cidr.prefixLength);\r\n    const hostIP = ipToInt(serverHost);\r\n    return (hostIP & mask) === (ip & mask);\r\n}\r\nfunction hostMatchesNoProxyList(serverHost) {\r\n    for (const host of getNoProxyHostList()) {\r\n        const parsedCIDR = parseCIDR(host);\r\n        // host is a CIDR and serverHost is an IP address\r\n        if ((0, net_1.isIPv4)(serverHost) && parsedCIDR && isIpInCIDR(parsedCIDR, serverHost)) {\r\n            return true;\r\n        }\r\n        else if (serverHost.endsWith(host)) {\r\n            // host is a single IP or a domain name suffix\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction mapProxyName(target, options) {\r\n    var _a;\r\n    const noProxyResult = {\r\n        target: target,\r\n        extraOptions: {},\r\n    };\r\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\r\n        return noProxyResult;\r\n    }\r\n    if (target.scheme === 'unix') {\r\n        return noProxyResult;\r\n    }\r\n    const proxyInfo = getProxyInfo();\r\n    if (!proxyInfo.address) {\r\n        return noProxyResult;\r\n    }\r\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\r\n    if (!hostPort) {\r\n        return noProxyResult;\r\n    }\r\n    const serverHost = hostPort.host;\r\n    if (hostMatchesNoProxyList(serverHost)) {\r\n        trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\r\n        return noProxyResult;\r\n    }\r\n    const extraOptions = {\r\n        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),\r\n    };\r\n    if (proxyInfo.creds) {\r\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\r\n    }\r\n    return {\r\n        target: {\r\n            scheme: 'dns',\r\n            path: proxyInfo.address,\r\n        },\r\n        extraOptions: extraOptions,\r\n    };\r\n}\r\nfunction getProxiedConnection(address, channelOptions) {\r\n    var _a;\r\n    if (!('grpc.http_connect_target' in channelOptions)) {\r\n        return Promise.resolve(null);\r\n    }\r\n    const realTarget = channelOptions['grpc.http_connect_target'];\r\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\r\n    if (parsedTarget === null) {\r\n        return Promise.resolve(null);\r\n    }\r\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\r\n    if (splitHostPost === null) {\r\n        return Promise.resolve(null);\r\n    }\r\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\r\n    const options = {\r\n        method: 'CONNECT',\r\n        path: hostPort,\r\n    };\r\n    const headers = {\r\n        Host: hostPort,\r\n    };\r\n    // Connect to the subchannel address as a proxy\r\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\r\n        options.host = address.host;\r\n        options.port = address.port;\r\n    }\r\n    else {\r\n        options.socketPath = address.path;\r\n    }\r\n    if ('grpc.http_connect_creds' in channelOptions) {\r\n        headers['Proxy-Authorization'] =\r\n            'Basic ' +\r\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\r\n    }\r\n    options.headers = headers;\r\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\r\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\r\n    return new Promise((resolve, reject) => {\r\n        const request = http.request(options);\r\n        request.once('connect', (res, socket, head) => {\r\n            request.removeAllListeners();\r\n            socket.removeAllListeners();\r\n            if (res.statusCode === 200) {\r\n                trace('Successfully connected to ' +\r\n                    options.path +\r\n                    ' through proxy ' +\r\n                    proxyAddressString);\r\n                // The HTTP client may have already read a few bytes of the proxied\r\n                // connection. If that's the case, put them back into the socket.\r\n                // See https://github.com/grpc/grpc-node/issues/2744.\r\n                if (head.length > 0) {\r\n                    socket.unshift(head);\r\n                }\r\n                trace('Successfully established a plaintext connection to ' +\r\n                    options.path +\r\n                    ' through proxy ' +\r\n                    proxyAddressString);\r\n                resolve(socket);\r\n            }\r\n            else {\r\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\r\n                    options.path +\r\n                    ' through proxy ' +\r\n                    proxyAddressString +\r\n                    ' with status ' +\r\n                    res.statusCode);\r\n                reject();\r\n            }\r\n        });\r\n        request.once('error', err => {\r\n            request.removeAllListeners();\r\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\r\n                proxyAddressString +\r\n                ' with error ' +\r\n                err.message);\r\n            reject();\r\n        });\r\n        request.end();\r\n    });\r\n}\r\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQix1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsT0FBTztBQUM1RjtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEdBQUcsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLEdBQUcsdUZBQXVGO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2h0dHBfcHJveHkuanM/YjdkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5wYXJzZUNJRFIgPSBwYXJzZUNJRFI7XHJcbmV4cG9ydHMubWFwUHJveHlOYW1lID0gbWFwUHJveHlOYW1lO1xyXG5leHBvcnRzLmdldFByb3hpZWRDb25uZWN0aW9uID0gZ2V0UHJveGllZENvbm5lY3Rpb247XHJcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbmNvbnN0IHJlc29sdmVyX2Ruc18xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdwcm94eSc7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UHJveHlJbmZvKCkge1xyXG4gICAgbGV0IHByb3h5RW52ID0gJyc7XHJcbiAgICBsZXQgZW52VmFyID0gJyc7XHJcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnaHR0cF9wcm94eScgaWYgaXQgaXMgbm90IHNldC5cclxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxyXG4gICAgICogZmFsbGJhY2sgYmVoYXZpb3IgY2FuIGJlIHJlbW92ZWQgaWYgdGhlcmUncyBhIGRlbWFuZCBmb3IgaXQuXHJcbiAgICAgKi9cclxuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XHJcbiAgICAgICAgZW52VmFyID0gJ2dycGNfcHJveHknO1xyXG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuZ3JwY19wcm94eTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5KSB7XHJcbiAgICAgICAgZW52VmFyID0gJ2h0dHBzX3Byb3h5JztcclxuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkge1xyXG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcclxuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBfcHJveHk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBsZXQgcHJveHlVcmw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChwcm94eUVudik7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XHJcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYFwiJHtwcm94eVVybC5wcm90b2NvbH1cIiBzY2hlbWUgbm90IHN1cHBvcnRlZCBpbiBwcm94eSBVUklgKTtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBsZXQgdXNlckNyZWQgPSBudWxsO1xyXG4gICAgaWYgKHByb3h5VXJsLnVzZXJuYW1lKSB7XHJcbiAgICAgICAgaWYgKHByb3h5VXJsLnBhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xyXG4gICAgICAgICAgICB1c2VyQ3JlZCA9IGRlY29kZVVSSUNvbXBvbmVudChgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVzZXJDcmVkID0gcHJveHlVcmwudXNlcm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgaG9zdG5hbWUgPSBwcm94eVVybC5ob3N0bmFtZTtcclxuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcclxuICAgIC8qIFRoZSBwcm94eSBVUkwgdXNlcyB0aGUgc2NoZW1lIFwiaHR0cDpcIiwgd2hpY2ggaGFzIGEgZGVmYXVsdCBwb3J0IG51bWJlciBvZlxyXG4gICAgICogODAuIFdlIG5lZWQgdG8gc2V0IHRoYXQgZXhwbGljaXRseSBoZXJlIGlmIGl0IGlzIG9taXR0ZWQgYmVjYXVzZSBvdGhlcndpc2VcclxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xyXG4gICAgaWYgKHBvcnQgPT09ICcnKSB7XHJcbiAgICAgICAgcG9ydCA9ICc4MCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgYWRkcmVzczogYCR7aG9zdG5hbWV9OiR7cG9ydH1gLFxyXG4gICAgfTtcclxuICAgIGlmICh1c2VyQ3JlZCkge1xyXG4gICAgICAgIHJlc3VsdC5jcmVkcyA9IHVzZXJDcmVkO1xyXG4gICAgfVxyXG4gICAgdHJhY2UoJ1Byb3h5IHNlcnZlciAnICsgcmVzdWx0LmFkZHJlc3MgKyAnIHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Tm9Qcm94eUhvc3RMaXN0KCkge1xyXG4gICAgLyogUHJlZmVyIHVzaW5nICdub19ncnBjX3Byb3h5Jy4gRmFsbGJhY2sgb24gJ25vX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LiAqL1xyXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xyXG4gICAgbGV0IGVudlZhciA9ICdub19ncnBjX3Byb3h5JztcclxuICAgIGlmICghbm9Qcm94eVN0cikge1xyXG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcclxuICAgICAgICBlbnZWYXIgPSAnbm9fcHJveHknO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vUHJveHlTdHIpIHtcclxuICAgICAgICB0cmFjZSgnTm8gcHJveHkgc2VydmVyIGxpc3Qgc2V0IGJ5IGVudmlyb25tZW50IHZhcmlhYmxlICcgKyBlbnZWYXIpO1xyXG4gICAgICAgIHJldHVybiBub1Byb3h5U3RyLnNwbGl0KCcsJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLypcclxuICogVGhlIGdyb3VwcyBjb3JyZXNwb25kIHRvIENJRFIgcGFydHMgYXMgZm9sbG93czpcclxuICogMS4gaXBcclxuICogMi4gcHJlZml4TGVuZ3RoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUNJRFIoY2lkclN0cmluZykge1xyXG4gICAgY29uc3Qgc3BsaXRSYW5nZSA9IGNpZHJTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgIGlmIChzcGxpdFJhbmdlLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gcGFyc2VJbnQoc3BsaXRSYW5nZVsxXSwgMTApO1xyXG4gICAgaWYgKCEoMCwgbmV0XzEuaXNJUHY0KShzcGxpdFJhbmdlWzBdKSB8fCBOdW1iZXIuaXNOYU4ocHJlZml4TGVuZ3RoKSB8fCBwcmVmaXhMZW5ndGggPCAwIHx8IHByZWZpeExlbmd0aCA+IDMyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlwOiBpcFRvSW50KHNwbGl0UmFuZ2VbMF0pLFxyXG4gICAgICAgIHByZWZpeExlbmd0aDogcHJlZml4TGVuZ3RoXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlwVG9JbnQoaXApIHtcclxuICAgIHJldHVybiBpcC5zcGxpdChcIi5cIikucmVkdWNlKChhY2MsIG9jdGV0KSA9PiAoYWNjIDw8IDgpICsgcGFyc2VJbnQob2N0ZXQsIDEwKSwgMCk7XHJcbn1cclxuZnVuY3Rpb24gaXNJcEluQ0lEUihjaWRyLCBzZXJ2ZXJIb3N0KSB7XHJcbiAgICBjb25zdCBpcCA9IGNpZHIuaXA7XHJcbiAgICBjb25zdCBtYXNrID0gLTEgPDwgKDMyIC0gY2lkci5wcmVmaXhMZW5ndGgpO1xyXG4gICAgY29uc3QgaG9zdElQID0gaXBUb0ludChzZXJ2ZXJIb3N0KTtcclxuICAgIHJldHVybiAoaG9zdElQICYgbWFzaykgPT09IChpcCAmIG1hc2spO1xyXG59XHJcbmZ1bmN0aW9uIGhvc3RNYXRjaGVzTm9Qcm94eUxpc3Qoc2VydmVySG9zdCkge1xyXG4gICAgZm9yIChjb25zdCBob3N0IG9mIGdldE5vUHJveHlIb3N0TGlzdCgpKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkQ0lEUiA9IHBhcnNlQ0lEUihob3N0KTtcclxuICAgICAgICAvLyBob3N0IGlzIGEgQ0lEUiBhbmQgc2VydmVySG9zdCBpcyBhbiBJUCBhZGRyZXNzXHJcbiAgICAgICAgaWYgKCgwLCBuZXRfMS5pc0lQdjQpKHNlcnZlckhvc3QpICYmIHBhcnNlZENJRFIgJiYgaXNJcEluQ0lEUihwYXJzZWRDSURSLCBzZXJ2ZXJIb3N0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VydmVySG9zdC5lbmRzV2l0aChob3N0KSkge1xyXG4gICAgICAgICAgICAvLyBob3N0IGlzIGEgc2luZ2xlIElQIG9yIGEgZG9tYWluIG5hbWUgc3VmZml4XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBub1Byb3h5UmVzdWx0ID0ge1xyXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgIGV4dHJhT3B0aW9uczoge30sXHJcbiAgICB9O1xyXG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcclxuICAgIGlmICghcHJveHlJbmZvLmFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcclxuICAgIH1cclxuICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XHJcbiAgICBpZiAoIWhvc3RQb3J0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJIb3N0ID0gaG9zdFBvcnQuaG9zdDtcclxuICAgIGlmIChob3N0TWF0Y2hlc05vUHJveHlMaXN0KHNlcnZlckhvc3QpKSB7XHJcbiAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcclxuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcclxuICAgICAgICAnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JzogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSxcclxuICAgIH07XHJcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XHJcbiAgICAgICAgZXh0cmFPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddID0gcHJveHlJbmZvLmNyZWRzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXJnZXQ6IHtcclxuICAgICAgICAgICAgc2NoZW1lOiAnZG5zJyxcclxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHRyYU9wdGlvbnM6IGV4dHJhT3B0aW9ucyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UHJveGllZENvbm5lY3Rpb24oYWRkcmVzcywgY2hhbm5lbE9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICghKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIGNoYW5uZWxPcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWFsVGFyZ2V0ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddO1xyXG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkocmVhbFRhcmdldCk7XHJcbiAgICBpZiAocGFyc2VkVGFyZ2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNwbGl0SG9zdFBvc3QgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhcnNlZFRhcmdldC5wYXRoKTtcclxuICAgIGlmIChzcGxpdEhvc3RQb3N0ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhvc3RQb3J0ID0gYCR7c3BsaXRIb3N0UG9zdC5ob3N0fTokeyhfYSA9IHNwbGl0SG9zdFBvc3QucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzb2x2ZXJfZG5zXzEuREVGQVVMVF9QT1JUfWA7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxyXG4gICAgICAgIHBhdGg6IGhvc3RQb3J0LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XHJcbiAgICAgICAgSG9zdDogaG9zdFBvcnQsXHJcbiAgICB9O1xyXG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcclxuICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzcykpIHtcclxuICAgICAgICBvcHRpb25zLmhvc3QgPSBhZGRyZXNzLmhvc3Q7XHJcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xyXG4gICAgfVxyXG4gICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF9jcmVkcycgaW4gY2hhbm5lbE9wdGlvbnMpIHtcclxuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxyXG4gICAgICAgICAgICAnQmFzaWMgJyArXHJcbiAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIGNvbnN0IHByb3h5QWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKTtcclxuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xyXG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xyXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcclxuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIEhUVFAgY2xpZW50IG1heSBoYXZlIGFscmVhZHkgcmVhZCBhIGZldyBieXRlcyBvZiB0aGUgcHJveGllZFxyXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbi4gSWYgdGhhdCdzIHRoZSBjYXNlLCBwdXQgdGhlbSBiYWNrIGludG8gdGhlIHNvY2tldC5cclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvaXNzdWVzLzI3NDQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnVuc2hpZnQoaGVhZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcclxuICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc29ja2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xyXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcclxuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgd2l0aCBzdGF0dXMgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHByb3h5ICcgK1xyXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcclxuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBfcHJveHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\r\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\r\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\r\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\r\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\r\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\r\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\r\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\r\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\r\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\r\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\r\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\r\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\r\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\r\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\");\r\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\r\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\r\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\r\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\r\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\r\n/**** Client Credentials ****/\r\n// Using assign only copies enumerable properties, which is what we want\r\nexports.credentials = {\r\n    /**\r\n     * Combine a ChannelCredentials with any number of CallCredentials into a\r\n     * single ChannelCredentials object.\r\n     * @param channelCredentials The ChannelCredentials object.\r\n     * @param callCredentials Any number of CallCredentials objects.\r\n     * @return The resulting ChannelCredentials object.\r\n     */\r\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\r\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\r\n    },\r\n    /**\r\n     * Combine any number of CallCredentials into a single CallCredentials\r\n     * object.\r\n     * @param first The first CallCredentials object.\r\n     * @param additional Any number of additional CallCredentials objects.\r\n     * @return The resulting CallCredentials object.\r\n     */\r\n    combineCallCredentials: (first, ...additional) => {\r\n        return additional.reduce((acc, other) => acc.compose(other), first);\r\n    },\r\n    // from channel-credentials.ts\r\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\r\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\r\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\r\n    // from call-credentials.ts\r\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\r\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\r\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\r\n};\r\n/**\r\n * Close a Client object.\r\n * @param client The client to close.\r\n */\r\nconst closeClient = (client) => client.close();\r\nexports.closeClient = closeClient;\r\nconst waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\r\nexports.waitForClientReady = waitForClientReady;\r\n/* eslint-enable @typescript-eslint/no-explicit-any */\r\n/**** Unimplemented function stubs ****/\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst loadObject = (value, options) => {\r\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\r\n};\r\nexports.loadObject = loadObject;\r\nconst load = (filename, format, options) => {\r\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\r\n};\r\nexports.load = load;\r\nconst setLogger = (logger) => {\r\n    logging.setLogger(logger);\r\n};\r\nexports.setLogger = setLogger;\r\nconst setLogVerbosity = (verbosity) => {\r\n    logging.setLoggerVerbosity(verbosity);\r\n};\r\nexports.setLogVerbosity = setLogVerbosity;\r\nconst getClientChannel = (client) => {\r\n    return client_1.Client.prototype.getChannel.call(client);\r\n};\r\nexports.getClientChannel = getClientChannel;\r\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\r\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\r\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\r\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\r\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\r\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\r\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\r\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\r\nvar server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\r\nObject.defineProperty(exports, \"ServerListenerBuilder\", ({ enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } }));\r\nObject.defineProperty(exports, \"ResponderBuilder\", ({ enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } }));\r\nObject.defineProperty(exports, \"ServerInterceptingCall\", ({ enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } }));\r\nconst experimental = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\r\nexports.experimental = experimental;\r\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\r\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\r\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\r\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\r\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\r\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\r\nconst channelz = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\n(() => {\r\n    resolver_dns.setup();\r\n    resolver_uds.setup();\r\n    resolver_ip.setup();\r\n    load_balancer_pick_first.setup();\r\n    load_balancer_round_robin.setup();\r\n    load_balancer_outlier_detection.setup();\r\n    channelz.setup();\r\n})();\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyw4QkFBOEIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyxxQ0FBcUMsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxjQUFjLEdBQUcsNkJBQTZCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUN2NUIsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN4SSxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDN0gsaUNBQWlDLG1CQUFPLENBQUMsd0dBQTBCO0FBQ25FLHlEQUF3RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUMxSiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDhCQUE4QixtQkFBTyxDQUFDLGtHQUF1QjtBQUM3RCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSx5REFBd0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDL0ksZ0VBQStELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3RKLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFEQUFvRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM5SSx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsaURBQWdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2xJO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzNELG1EQUFrRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUMzSSxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksb0RBQW1ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzdJLGlFQUFnRSxFQUFFLHFDQUFxQywrREFBK0QsRUFBQztBQUN2SyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnRUFBK0QsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDMUosdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQiw0REFBMkQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDL0ksNEJBQTRCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzNELHlEQUF3RCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUN2SixvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksMERBQXlELEVBQUUscUNBQXFDLHdEQUF3RCxFQUFDO0FBQ3pKLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDckUsa0NBQWtDLG1CQUFPLENBQUMsOEdBQTZCO0FBQ3ZFLHdDQUF3QyxtQkFBTyxDQUFDLDBIQUFtQztBQUNuRixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2luZGV4LmpzPzU3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwb3J0cy5TZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXNwb25kZXJCdWlsZGVyID0gZXhwb3J0cy5TZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IGV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBleHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmxvYWRPYmplY3QgPSBleHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IGV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSBleHBvcnRzLmNsb3NlQ2xpZW50ID0gZXhwb3J0cy5DaGFubmVsID0gZXhwb3J0cy5tYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5jb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLnByb3BhZ2F0ZSA9IGV4cG9ydHMuY29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLnN0YXR1cyA9IGV4cG9ydHMubG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5NZXRhZGF0YSA9IGV4cG9ydHMuY3JlZGVudGlhbHMgPSB2b2lkIDA7XHJcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFsczsgfSB9KTtcclxuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbjsgfSB9KTtcclxuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHJlc3Npb25BbGdvcml0aG1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zOyB9IH0pO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29ubmVjdGl2aXR5U3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlOyB9IH0pO1xyXG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XHJcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1ZlcmJvc2l0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5OyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN0YXR1czsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGFnYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Qcm9wYWdhdGU7IH0gfSk7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRQYWNrYWdlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb247IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldGFkYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXRhZGF0YV8xLk1ldGFkYXRhOyB9IH0pO1xyXG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XHJcbmNvbnN0IHNlcnZlcl9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWNyZWRlbnRpYWxzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XHJcbmNvbnN0IHN0YXR1c19idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0dXMtYnVpbGRlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHVzQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdHVzX2J1aWxkZXJfMS5TdGF0dXNCdWlsZGVyOyB9IH0pO1xyXG4vKioqKiBDbGllbnQgQ3JlZGVudGlhbHMgKioqKi9cclxuLy8gVXNpbmcgYXNzaWduIG9ubHkgY29waWVzIGVudW1lcmFibGUgcHJvcGVydGllcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XHJcbmV4cG9ydHMuY3JlZGVudGlhbHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgd2l0aCBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGFcclxuICAgICAqIHNpbmdsZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFscyBUaGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBjYWxsQ3JlZGVudGlhbHMgQW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzOiAoY2hhbm5lbENyZWRlbnRpYWxzLCAuLi5jYWxsQ3JlZGVudGlhbHMpID0+IHtcclxuICAgICAgICByZXR1cm4gY2FsbENyZWRlbnRpYWxzLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBjaGFubmVsQ3JlZGVudGlhbHMpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZSBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGEgc2luZ2xlIENhbGxDcmVkZW50aWFsc1xyXG4gICAgICogb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQW55IG51bWJlciBvZiBhZGRpdGlvbmFsIENhbGxDcmVkZW50aWFscyBvYmplY3RzLlxyXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGNvbWJpbmVDYWxsQ3JlZGVudGlhbHM6IChmaXJzdCwgLi4uYWRkaXRpb25hbCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBmaXJzdCk7XHJcbiAgICB9LFxyXG4gICAgLy8gZnJvbSBjaGFubmVsLWNyZWRlbnRpYWxzLnRzXHJcbiAgICBjcmVhdGVJbnNlY3VyZTogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSxcclxuICAgIGNyZWF0ZVNzbDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVTc2wsXHJcbiAgICBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVGcm9tU2VjdXJlQ29udGV4dCxcclxuICAgIC8vIGZyb20gY2FsbC1jcmVkZW50aWFscy50c1xyXG4gICAgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcixcclxuICAgIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsLFxyXG4gICAgY3JlYXRlRW1wdHk6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHksXHJcbn07XHJcbi8qKlxyXG4gKiBDbG9zZSBhIENsaWVudCBvYmplY3QuXHJcbiAqIEBwYXJhbSBjbGllbnQgVGhlIGNsaWVudCB0byBjbG9zZS5cclxuICovXHJcbmNvbnN0IGNsb3NlQ2xpZW50ID0gKGNsaWVudCkgPT4gY2xpZW50LmNsb3NlKCk7XHJcbmV4cG9ydHMuY2xvc2VDbGllbnQgPSBjbG9zZUNsaWVudDtcclxuY29uc3Qgd2FpdEZvckNsaWVudFJlYWR5ID0gKGNsaWVudCwgZGVhZGxpbmUsIGNhbGxiYWNrKSA9PiBjbGllbnQud2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjayk7XHJcbmV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gd2FpdEZvckNsaWVudFJlYWR5O1xyXG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuLyoqKiogVW5pbXBsZW1lbnRlZCBmdW5jdGlvbiBzdHVicyAqKioqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbmNvbnN0IGxvYWRPYmplY3QgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XHJcbn07XHJcbmV4cG9ydHMubG9hZE9iamVjdCA9IGxvYWRPYmplY3Q7XHJcbmNvbnN0IGxvYWQgPSAoZmlsZW5hbWUsIGZvcm1hdCwgb3B0aW9ucykgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlIGluIHRoaXMgbGlicmFyeS4gVXNlIEBncnBjL3Byb3RvLWxvYWRlciBhbmQgbG9hZFBhY2thZ2VEZWZpbml0aW9uIGluc3RlYWQnKTtcclxufTtcclxuZXhwb3J0cy5sb2FkID0gbG9hZDtcclxuY29uc3Qgc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xyXG4gICAgbG9nZ2luZy5zZXRMb2dnZXIobG9nZ2VyKTtcclxufTtcclxuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XHJcbmNvbnN0IHNldExvZ1ZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcclxuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyVmVyYm9zaXR5KHZlcmJvc2l0eSk7XHJcbn07XHJcbmV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gc2V0TG9nVmVyYm9zaXR5O1xyXG5jb25zdCBnZXRDbGllbnRDaGFubmVsID0gKGNsaWVudCkgPT4ge1xyXG4gICAgcmV0dXJuIGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhbm5lbC5jYWxsKGNsaWVudCk7XHJcbn07XHJcbmV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGdldENsaWVudENoYW5uZWw7XHJcbnZhciBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RlckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5SZXF1ZXN0ZXJCdWlsZGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcclxudmFyIGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XHJcbnZhciBhZG1pbl8xID0gcmVxdWlyZShcIi4vYWRtaW5cIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZEFkbWluU2VydmljZXNUb1NlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7IH0gfSk7XHJcbnZhciBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItaW50ZXJjZXB0b3JzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl9pbnRlcmNlcHRvcnNfMS5TZXJ2ZXJMaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbmRlckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl9pbnRlcmNlcHRvcnNfMS5SZXNwb25kZXJCdWlsZGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfaW50ZXJjZXB0b3JzXzEuU2VydmVySW50ZXJjZXB0aW5nQ2FsbDsgfSB9KTtcclxuY29uc3QgZXhwZXJpbWVudGFsID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xyXG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cGVyaW1lbnRhbDtcclxuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xyXG5jb25zdCByZXNvbHZlcl91ZHMgPSByZXF1aXJlKFwiLi9yZXNvbHZlci11ZHNcIik7XHJcbmNvbnN0IHJlc29sdmVyX2lwID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItaXBcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcclxuY29uc3QgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2JpbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcm91bmQtcm9iaW5cIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xyXG5jb25zdCBjaGFubmVseiA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xyXG4oKCkgPT4ge1xyXG4gICAgcmVzb2x2ZXJfZG5zLnNldHVwKCk7XHJcbiAgICByZXNvbHZlcl91ZHMuc2V0dXAoKTtcclxuICAgIHJlc29sdmVyX2lwLnNldHVwKCk7XHJcbiAgICBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3Quc2V0dXAoKTtcclxuICAgIGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4uc2V0dXAoKTtcclxuICAgIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24uc2V0dXAoKTtcclxuICAgIGNoYW5uZWx6LnNldHVwKCk7XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InternalChannel = exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = void 0;\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\r\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\r\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\r\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\r\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\n/**\r\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\r\n */\r\nconst MAX_TIMEOUT_TIME = 2147483647;\r\nconst MIN_IDLE_TIMEOUT_MS = 1000;\r\n// 30 minutes\r\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\r\nconst RETRY_THROTTLER_MAP = new Map();\r\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\r\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\r\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\r\n    constructor(childSubchannel, channel) {\r\n        super(childSubchannel);\r\n        this.channel = channel;\r\n        this.refCount = 0;\r\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\r\n            channel.throttleKeepalive(keepaliveTime);\r\n        };\r\n    }\r\n    ref() {\r\n        if (this.refCount === 0) {\r\n            this.child.addConnectivityStateListener(this.subchannelStateListener);\r\n            this.channel.addWrappedSubchannel(this);\r\n        }\r\n        this.child.ref();\r\n        this.refCount += 1;\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n        this.refCount -= 1;\r\n        if (this.refCount <= 0) {\r\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\r\n            this.channel.removeWrappedSubchannel(this);\r\n        }\r\n    }\r\n}\r\nclass ShutdownPicker {\r\n    pick(pickArgs) {\r\n        return {\r\n            pickResultType: picker_1.PickResultType.DROP,\r\n            status: {\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: 'Channel closed before call started',\r\n                metadata: new metadata_1.Metadata()\r\n            },\r\n            subchannel: null,\r\n            onCallStarted: null,\r\n            onCallEnded: null\r\n        };\r\n    }\r\n}\r\nexports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = 'grpc.internal.no_subchannel';\r\nclass ChannelzInfoTracker {\r\n    constructor(target) {\r\n        this.target = target;\r\n        this.trace = new channelz_1.ChannelzTrace();\r\n        this.callTracker = new channelz_1.ChannelzCallTracker();\r\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n        this.state = connectivity_state_1.ConnectivityState.IDLE;\r\n    }\r\n    getChannelzInfoCallback() {\r\n        return () => {\r\n            return {\r\n                target: this.target,\r\n                state: this.state,\r\n                trace: this.trace,\r\n                callTracker: this.callTracker,\r\n                children: this.childrenTracker.getChildLists()\r\n            };\r\n        };\r\n    }\r\n}\r\nclass InternalChannel {\r\n    constructor(target, credentials, options) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        this.credentials = credentials;\r\n        this.options = options;\r\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.currentPicker = new picker_1.UnavailablePicker();\r\n        /**\r\n         * Calls queued up to get a call config. Should only be populated before the\r\n         * first time the resolver returns a result, which includes the ConfigSelector.\r\n         */\r\n        this.configSelectionQueue = [];\r\n        this.pickQueue = [];\r\n        this.connectivityStateWatchers = [];\r\n        /**\r\n         * This timer does not do anything on its own. Its purpose is to hold the\r\n         * event loop open while there are any pending calls for the channel that\r\n         * have not yet been assigned to specific subchannels. In other words,\r\n         * the invariant is that callRefTimer is reffed if and only if pickQueue\r\n         * is non-empty. In addition, the timer is null while the state is IDLE or\r\n         * SHUTDOWN and there are no pending calls.\r\n         */\r\n        this.callRefTimer = null;\r\n        this.configSelector = null;\r\n        /**\r\n         * This is the error from the name resolver if it failed most recently. It\r\n         * is only used to end calls that start while there is no config selector\r\n         * and the name resolver is in backoff, so it should be nulled if\r\n         * configSelector becomes set or the channel state becomes anything other\r\n         * than TRANSIENT_FAILURE.\r\n         */\r\n        this.currentResolutionError = null;\r\n        this.wrappedSubchannels = new Set();\r\n        this.callCount = 0;\r\n        this.idleTimer = null;\r\n        // Channelz info\r\n        this.channelzEnabled = true;\r\n        /**\r\n         * Randomly generated ID to be passed to the config selector, for use by\r\n         * ring_hash in xDS. An integer distributed approximately uniformly between\r\n         * 0 and MAX_SAFE_INTEGER.\r\n         */\r\n        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\r\n        if (typeof target !== 'string') {\r\n            throw new TypeError('Channel target must be a string');\r\n        }\r\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\r\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\r\n        }\r\n        if (options) {\r\n            if (typeof options !== 'object') {\r\n                throw new TypeError('Channel options must be an object');\r\n            }\r\n        }\r\n        this.channelzInfoTracker = new ChannelzInfoTracker(target);\r\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\r\n        if (originalTargetUri === null) {\r\n            throw new Error(`Could not parse target name \"${target}\"`);\r\n        }\r\n        /* This ensures that the target has a scheme that is registered with the\r\n         * resolver */\r\n        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\r\n        if (defaultSchemeMapResult === null) {\r\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\r\n        }\r\n        if (this.options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n        }\r\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);\r\n        if (this.channelzEnabled) {\r\n            this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Channel created');\r\n        }\r\n        if (this.options['grpc.default_authority']) {\r\n            this.defaultAuthority = this.options['grpc.default_authority'];\r\n        }\r\n        else {\r\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\r\n        }\r\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\r\n        this.target = proxyMapResult.target;\r\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\r\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\r\n         * the grpc.use_local_subchannel_pool channel option means. */\r\n        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a = this.options['grpc.use_local_subchannel_pool']) !== null && _a !== void 0 ? _a : 0) === 0);\r\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b = this.options['grpc.retry_buffer_size']) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c = this.options['grpc.per_rpc_retry_buffer_size']) !== null && _c !== void 0 ? _c : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\r\n        this.keepaliveTime = (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : -1;\r\n        this.idleTimeoutMs = Math.max((_e = this.options['grpc.client_idle_timeout_ms']) !== null && _e !== void 0 ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\r\n        const channelControlHelper = {\r\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\r\n                const finalSubchannelArgs = {};\r\n                for (const [key, value] of Object.entries(subchannelArgs)) {\r\n                    if (!key.startsWith(exports.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX)) {\r\n                        finalSubchannelArgs[key] = value;\r\n                    }\r\n                }\r\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, finalSubchannelArgs, this.credentials);\r\n                subchannel.throttleKeepalive(this.keepaliveTime);\r\n                if (this.channelzEnabled) {\r\n                    this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\r\n                }\r\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\r\n                return wrappedSubchannel;\r\n            },\r\n            updateState: (connectivityState, picker) => {\r\n                this.currentPicker = picker;\r\n                const queueCopy = this.pickQueue.slice();\r\n                this.pickQueue = [];\r\n                if (queueCopy.length > 0) {\r\n                    this.callRefTimerUnref();\r\n                }\r\n                for (const call of queueCopy) {\r\n                    call.doPick();\r\n                }\r\n                this.updateState(connectivityState);\r\n            },\r\n            requestReresolution: () => {\r\n                // This should never be called.\r\n                throw new Error('Resolving load balancer should never call requestReresolution');\r\n            },\r\n            addChannelzChild: (child) => {\r\n                if (this.channelzEnabled) {\r\n                    this.channelzInfoTracker.childrenTracker.refChild(child);\r\n                }\r\n            },\r\n            removeChannelzChild: (child) => {\r\n                if (this.channelzEnabled) {\r\n                    this.channelzInfoTracker.childrenTracker.unrefChild(child);\r\n                }\r\n            },\r\n        };\r\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, this.options, (serviceConfig, configSelector) => {\r\n            var _a;\r\n            if (serviceConfig.retryThrottling) {\r\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\r\n            }\r\n            else {\r\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\r\n            }\r\n            if (this.channelzEnabled) {\r\n                this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Address resolution succeeded');\r\n            }\r\n            (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\r\n            this.configSelector = configSelector;\r\n            this.currentResolutionError = null;\r\n            /* We process the queue asynchronously to ensure that the corresponding\r\n             * load balancer update has completed. */\r\n            process.nextTick(() => {\r\n                const localQueue = this.configSelectionQueue;\r\n                this.configSelectionQueue = [];\r\n                if (localQueue.length > 0) {\r\n                    this.callRefTimerUnref();\r\n                }\r\n                for (const call of localQueue) {\r\n                    call.getConfig();\r\n                }\r\n            });\r\n        }, status => {\r\n            if (this.channelzEnabled) {\r\n                this.channelzInfoTracker.trace.addTrace('CT_WARNING', 'Address resolution failed with code ' +\r\n                    status.code +\r\n                    ' and details \"' +\r\n                    status.details +\r\n                    '\"');\r\n            }\r\n            if (this.configSelectionQueue.length > 0) {\r\n                this.trace('Name resolution failed with calls queued for config selection');\r\n            }\r\n            if (this.configSelector === null) {\r\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });\r\n            }\r\n            const localQueue = this.configSelectionQueue;\r\n            this.configSelectionQueue = [];\r\n            if (localQueue.length > 0) {\r\n                this.callRefTimerUnref();\r\n            }\r\n            for (const call of localQueue) {\r\n                call.reportResolverError(status);\r\n            }\r\n        });\r\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\r\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\r\n        ]);\r\n        this.trace('Channel constructed with options ' +\r\n            JSON.stringify(options, undefined, 2));\r\n        const error = new Error();\r\n        if ((0, logging_1.isTracerEnabled)('channel_stacktrace')) {\r\n            (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +\r\n                this.channelzRef.id +\r\n                ') ' +\r\n                'Channel constructed \\n' +\r\n                ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf('\\n') + 1)));\r\n        }\r\n        this.lastActivityTimestamp = new Date();\r\n    }\r\n    trace(text, verbosityOverride) {\r\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\r\n    }\r\n    callRefTimerRef() {\r\n        var _a, _b, _c, _d;\r\n        if (!this.callRefTimer) {\r\n            this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\r\n        }\r\n        // If the hasRef function does not exist, always run the code\r\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\r\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\r\n                this.configSelectionQueue.length +\r\n                ' pickQueue.length=' +\r\n                this.pickQueue.length);\r\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\r\n        }\r\n    }\r\n    callRefTimerUnref() {\r\n        var _a, _b, _c;\r\n        // If the timer or the hasRef function does not exist, always run the code\r\n        if (!((_a = this.callRefTimer) === null || _a === void 0 ? void 0 : _a.hasRef) || this.callRefTimer.hasRef()) {\r\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\r\n                this.configSelectionQueue.length +\r\n                ' pickQueue.length=' +\r\n                this.pickQueue.length);\r\n            (_c = (_b = this.callRefTimer) === null || _b === void 0 ? void 0 : _b.unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n        }\r\n    }\r\n    removeConnectivityStateWatcher(watcherObject) {\r\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\r\n        if (watcherIndex >= 0) {\r\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\r\n        }\r\n    }\r\n    updateState(newState) {\r\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            (0, uri_parser_1.uriToString)(this.target) +\r\n            ' ' +\r\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        if (this.channelzEnabled) {\r\n            this.channelzInfoTracker.trace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\r\n        }\r\n        this.connectivityState = newState;\r\n        this.channelzInfoTracker.state = newState;\r\n        const watchersCopy = this.connectivityStateWatchers.slice();\r\n        for (const watcherObject of watchersCopy) {\r\n            if (newState !== watcherObject.currentState) {\r\n                if (watcherObject.timer) {\r\n                    clearTimeout(watcherObject.timer);\r\n                }\r\n                this.removeConnectivityStateWatcher(watcherObject);\r\n                watcherObject.callback();\r\n            }\r\n        }\r\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n            this.currentResolutionError = null;\r\n        }\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        if (newKeepaliveTime > this.keepaliveTime) {\r\n            this.keepaliveTime = newKeepaliveTime;\r\n            for (const wrappedSubchannel of this.wrappedSubchannels) {\r\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\r\n            }\r\n        }\r\n    }\r\n    addWrappedSubchannel(wrappedSubchannel) {\r\n        this.wrappedSubchannels.add(wrappedSubchannel);\r\n    }\r\n    removeWrappedSubchannel(wrappedSubchannel) {\r\n        this.wrappedSubchannels.delete(wrappedSubchannel);\r\n    }\r\n    doPick(metadata, extraPickInfo) {\r\n        return this.currentPicker.pick({\r\n            metadata: metadata,\r\n            extraPickInfo: extraPickInfo,\r\n        });\r\n    }\r\n    queueCallForPick(call) {\r\n        this.pickQueue.push(call);\r\n        this.callRefTimerRef();\r\n    }\r\n    getConfig(method, metadata) {\r\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {\r\n            this.resolvingLoadBalancer.exitIdle();\r\n        }\r\n        if (this.configSelector) {\r\n            return {\r\n                type: 'SUCCESS',\r\n                config: this.configSelector.invoke(method, metadata, this.randomChannelId),\r\n            };\r\n        }\r\n        else {\r\n            if (this.currentResolutionError) {\r\n                return {\r\n                    type: 'ERROR',\r\n                    error: this.currentResolutionError,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: 'NONE',\r\n                };\r\n            }\r\n        }\r\n    }\r\n    queueCallForConfig(call) {\r\n        this.configSelectionQueue.push(call);\r\n        this.callRefTimerRef();\r\n    }\r\n    enterIdle() {\r\n        this.resolvingLoadBalancer.destroy();\r\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\r\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\r\n        if (this.idleTimer) {\r\n            clearTimeout(this.idleTimer);\r\n            this.idleTimer = null;\r\n        }\r\n        if (this.callRefTimer) {\r\n            clearInterval(this.callRefTimer);\r\n            this.callRefTimer = null;\r\n        }\r\n    }\r\n    startIdleTimeout(timeoutMs) {\r\n        var _a, _b;\r\n        this.idleTimer = setTimeout(() => {\r\n            if (this.callCount > 0) {\r\n                /* If there is currently a call, the channel will not go idle for a\r\n                 * period of at least idleTimeoutMs, so check again after that time.\r\n                 */\r\n                this.startIdleTimeout(this.idleTimeoutMs);\r\n                return;\r\n            }\r\n            const now = new Date();\r\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\r\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\r\n                this.trace('Idle timer triggered after ' +\r\n                    this.idleTimeoutMs +\r\n                    'ms of inactivity');\r\n                this.enterIdle();\r\n            }\r\n            else {\r\n                /* Whenever the timer fires with the latest activity being too recent,\r\n                 * set the timer again for the time when the time since the last\r\n                 * activity is equal to the timeout. This should result in the timer\r\n                 * firing no more than once every idleTimeoutMs/2 on average. */\r\n                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\r\n            }\r\n        }, timeoutMs);\r\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    maybeStartIdleTimer() {\r\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&\r\n            !this.idleTimer) {\r\n            this.startIdleTimeout(this.idleTimeoutMs);\r\n        }\r\n    }\r\n    onCallStart() {\r\n        if (this.channelzEnabled) {\r\n            this.channelzInfoTracker.callTracker.addCallStarted();\r\n        }\r\n        this.callCount += 1;\r\n    }\r\n    onCallEnd(status) {\r\n        if (this.channelzEnabled) {\r\n            if (status.code === constants_1.Status.OK) {\r\n                this.channelzInfoTracker.callTracker.addCallSucceeded();\r\n            }\r\n            else {\r\n                this.channelzInfoTracker.callTracker.addCallFailed();\r\n            }\r\n        }\r\n        this.callCount -= 1;\r\n        this.lastActivityTimestamp = new Date();\r\n        this.maybeStartIdleTimer();\r\n    }\r\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\r\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\r\n    }\r\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\r\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\r\n    }\r\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createResolvingCall [' +\r\n            callNumber +\r\n            '] method=\"' +\r\n            method +\r\n            '\", deadline=' +\r\n            (0, deadline_1.deadlineToString)(deadline));\r\n        const finalOptions = {\r\n            deadline: deadline,\r\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\r\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\r\n            parentCall: parentCall,\r\n        };\r\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), callNumber);\r\n        this.onCallStart();\r\n        call.addStatusWatcher(status => {\r\n            this.onCallEnd(status);\r\n        });\r\n        return call;\r\n    }\r\n    close() {\r\n        var _a;\r\n        this.resolvingLoadBalancer.destroy();\r\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\r\n        this.currentPicker = new ShutdownPicker();\r\n        for (const call of this.configSelectionQueue) {\r\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\r\n        }\r\n        this.configSelectionQueue = [];\r\n        for (const call of this.pickQueue) {\r\n            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');\r\n        }\r\n        this.pickQueue = [];\r\n        if (this.callRefTimer) {\r\n            clearInterval(this.callRefTimer);\r\n        }\r\n        if (this.idleTimer) {\r\n            clearTimeout(this.idleTimer);\r\n        }\r\n        if (this.channelzEnabled) {\r\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n        }\r\n        this.subchannelPool.unrefUnusedSubchannels();\r\n        (_a = this.configSelector) === null || _a === void 0 ? void 0 : _a.unref();\r\n        this.configSelector = null;\r\n    }\r\n    getTarget() {\r\n        return (0, uri_parser_1.uriToString)(this.target);\r\n    }\r\n    getConnectivityState(tryToConnect) {\r\n        const connectivityState = this.connectivityState;\r\n        if (tryToConnect) {\r\n            this.resolvingLoadBalancer.exitIdle();\r\n            this.lastActivityTimestamp = new Date();\r\n            this.maybeStartIdleTimer();\r\n        }\r\n        return connectivityState;\r\n    }\r\n    watchConnectivityState(currentState, deadline, callback) {\r\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\r\n            throw new Error('Channel has been shut down');\r\n        }\r\n        let timer = null;\r\n        if (deadline !== Infinity) {\r\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\r\n            const now = new Date();\r\n            if (deadline === -Infinity || deadlineDate <= now) {\r\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\r\n                return;\r\n            }\r\n            timer = setTimeout(() => {\r\n                this.removeConnectivityStateWatcher(watcherObject);\r\n                callback(new Error('Deadline passed without connectivity state change'));\r\n            }, deadlineDate.getTime() - now.getTime());\r\n        }\r\n        const watcherObject = {\r\n            currentState,\r\n            callback,\r\n            timer,\r\n        };\r\n        this.connectivityStateWatchers.push(watcherObject);\r\n    }\r\n    /**\r\n     * Get the channelz reference object for this channel. The returned value is\r\n     * garbage if channelz is disabled for this channel.\r\n     * @returns\r\n     */\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    createCall(method, deadline, host, parentCall, propagateFlags) {\r\n        if (typeof method !== 'string') {\r\n            throw new TypeError('Channel#createCall: method must be a string');\r\n        }\r\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\r\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\r\n        }\r\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\r\n            throw new Error('Channel has been shut down');\r\n        }\r\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n}\r\nexports.InternalChannel = InternalChannel;\r\n//# sourceMappingURL=internal-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLDBDQUEwQztBQUNwRSw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0MsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCx3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDhGQUE4RiwyQkFBMkI7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcz85NDM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IGV4cG9ydHMuU1VCQ0hBTk5FTF9BUkdTX0VYQ0xVREVfS0VZX1BSRUZJWCA9IHZvaWQgMDtcclxuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcclxuY29uc3QgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX3Bvb2xfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtcG9vbFwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xyXG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcclxuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xyXG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2luZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2luZy1jYWxsXCIpO1xyXG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XHJcbmNvbnN0IHJlc29sdmluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctY2FsbFwiKTtcclxuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xyXG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XHJcbmNvbnN0IHJldHJ5aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aW5nLWNhbGxcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcclxuLyoqXHJcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVyc19zZXRpbnRlcnZhbF9jYWxsYmFja19kZWxheV9hcmdzXHJcbiAqL1xyXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0NztcclxuY29uc3QgTUlOX0lETEVfVElNRU9VVF9NUyA9IDEwMDA7XHJcbi8vIDMwIG1pbnV0ZXNcclxuY29uc3QgREVGQVVMVF9JRExFX1RJTUVPVVRfTVMgPSAzMCAqIDYwICogMTAwMDtcclxuY29uc3QgUkVUUllfVEhST1RUTEVSX01BUCA9IG5ldyBNYXAoKTtcclxuY29uc3QgREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyA9IDEgPDwgMjQ7IC8vIDE2IE1CXHJcbmNvbnN0IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyA9IDEgPDwgMjA7IC8vIDEgTUJcclxuY2xhc3MgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBjaGFubmVsKSB7XHJcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcclxuICAgICAgICAgICAgY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShrZWVwYWxpdmVUaW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmVmKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLmFkZFdyYXBwZWRTdWJjaGFubmVsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcclxuICAgIH1cclxuICAgIHVucmVmKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5yZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU2h1dGRvd25QaWNrZXIge1xyXG4gICAgcGljayhwaWNrQXJncykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5EUk9QLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDaGFubmVsIGNsb3NlZCBiZWZvcmUgY2FsbCBzdGFydGVkJyxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXHJcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNVQkNIQU5ORUxfQVJHU19FWENMVURFX0tFWV9QUkVGSVggPSAnZ3JwYy5pbnRlcm5hbC5ub19zdWJjaGFubmVsJztcclxuY2xhc3MgQ2hhbm5lbHpJbmZvVHJhY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xyXG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpJbmZvQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgICAgIHRyYWNlOiB0aGlzLnRyYWNlLFxyXG4gICAgICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBJbnRlcm5hbENoYW5uZWwge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxzIHF1ZXVlZCB1cCB0byBnZXQgYSBjYWxsIGNvbmZpZy4gU2hvdWxkIG9ubHkgYmUgcG9wdWxhdGVkIGJlZm9yZSB0aGVcclxuICAgICAgICAgKiBmaXJzdCB0aW1lIHRoZSByZXNvbHZlciByZXR1cm5zIGEgcmVzdWx0LCB3aGljaCBpbmNsdWRlcyB0aGUgQ29uZmlnU2VsZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyB0aW1lciBkb2VzIG5vdCBkbyBhbnl0aGluZyBvbiBpdHMgb3duLiBJdHMgcHVycG9zZSBpcyB0byBob2xkIHRoZVxyXG4gICAgICAgICAqIGV2ZW50IGxvb3Agb3BlbiB3aGlsZSB0aGVyZSBhcmUgYW55IHBlbmRpbmcgY2FsbHMgZm9yIHRoZSBjaGFubmVsIHRoYXRcclxuICAgICAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBhc3NpZ25lZCB0byBzcGVjaWZpYyBzdWJjaGFubmVscy4gSW4gb3RoZXIgd29yZHMsXHJcbiAgICAgICAgICogdGhlIGludmFyaWFudCBpcyB0aGF0IGNhbGxSZWZUaW1lciBpcyByZWZmZWQgaWYgYW5kIG9ubHkgaWYgcGlja1F1ZXVlXHJcbiAgICAgICAgICogaXMgbm9uLWVtcHR5LiBJbiBhZGRpdGlvbiwgdGhlIHRpbWVyIGlzIG51bGwgd2hpbGUgdGhlIHN0YXRlIGlzIElETEUgb3JcclxuICAgICAgICAgKiBTSFVURE9XTiBhbmQgdGhlcmUgYXJlIG5vIHBlbmRpbmcgY2FsbHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGVycm9yIGZyb20gdGhlIG5hbWUgcmVzb2x2ZXIgaWYgaXQgZmFpbGVkIG1vc3QgcmVjZW50bHkuIEl0XHJcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxyXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXHJcbiAgICAgICAgICogY29uZmlnU2VsZWN0b3IgYmVjb21lcyBzZXQgb3IgdGhlIGNoYW5uZWwgc3RhdGUgYmVjb21lcyBhbnl0aGluZyBvdGhlclxyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cclxuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmFuZG9tbHkgZ2VuZXJhdGVkIElEIHRvIGJlIHBhc3NlZCB0byB0aGUgY29uZmlnIHNlbGVjdG9yLCBmb3IgdXNlIGJ5XHJcbiAgICAgICAgICogcmluZ19oYXNoIGluIHhEUy4gQW4gaW50ZWdlciBkaXN0cmlidXRlZCBhcHByb3hpbWF0ZWx5IHVuaWZvcm1seSBiZXR3ZWVuXHJcbiAgICAgICAgICogMCBhbmQgTUFYX1NBRkVfSU5URUdFUi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhbmRvbUNoYW5uZWxJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCB0YXJnZXQgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgY3JlZGVudGlhbHMgbXVzdCBiZSBhIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyID0gbmV3IENoYW5uZWx6SW5mb1RyYWNrZXIodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFRhcmdldFVyaSA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0VXJpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBzY2hlbWUgdGhhdCBpcyByZWdpc3RlcmVkIHdpdGggdGhlXHJcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cclxuICAgICAgICBjb25zdCBkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID0gKDAsIHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZSkob3JpZ2luYWxUYXJnZXRVcmkpO1xyXG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgdGFyZ2V0IG5hbWUgXCIke3RhcmdldH1cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCkodGFyZ2V0LCB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuZ2V0Q2hhbm5lbHpJbmZvQ2FsbGJhY2soKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIudHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ2hhbm5lbCBjcmVhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBdXRob3JpdHkgPSB0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm94eU1hcFJlc3VsdCA9ICgwLCBodHRwX3Byb3h5XzEubWFwUHJveHlOYW1lKShkZWZhdWx0U2NoZW1lTWFwUmVzdWx0LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHByb3h5TWFwUmVzdWx0LnRhcmdldDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHByb3h5TWFwUmVzdWx0LmV4dHJhT3B0aW9ucyk7XHJcbiAgICAgICAgLyogVGhlIGdsb2JhbCBib29sZWFuIHBhcmFtZXRlciB0byBnZXRTdWJjaGFubmVsUG9vbCBoYXMgdGhlIGludmVyc2UgbWVhbmluZyB0byB3aGF0XHJcbiAgICAgICAgICogdGhlIGdycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCBjaGFubmVsIG9wdGlvbiBtZWFucy4gKi9cclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sID0gKDAsIHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKSgoKF9hID0gdGhpcy5vcHRpb25zWydncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgPT09IDApO1xyXG4gICAgICAgIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyID0gbmV3IHJldHJ5aW5nX2NhbGxfMS5NZXNzYWdlQnVmZmVyVHJhY2tlcigoX2IgPSB0aGlzLm9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9jID0gdGhpcy5vcHRpb25zWydncnBjLnBlcl9ycGNfcmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTKTtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSAoX2QgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogLTE7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZW91dE1zID0gTWF0aC5tYXgoKF9lID0gdGhpcy5vcHRpb25zWydncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogREVGQVVMVF9JRExFX1RJTUVPVVRfTVMsIE1JTl9JRExFX1RJTUVPVVRfTVMpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xyXG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFN1YmNoYW5uZWxBcmdzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdWJjaGFubmVsQXJncykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleS5zdGFydHNXaXRoKGV4cG9ydHMuU1VCQ0hBTk5FTF9BUkdTX0VYQ0xVREVfS0VZX1BSRUZJWCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxTdWJjaGFubmVsQXJnc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbFBvb2wuZ2V0T3JDcmVhdGVTdWJjaGFubmVsKHRoaXMudGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgZmluYWxTdWJjaGFubmVsQXJncywgdGhpcy5jcmVkZW50aWFscyk7XHJcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIudHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ3JlYXRlZCBzdWJjaGFubmVsIG9yIHVzZWQgZXhpc3Rpbmcgc3ViY2hhbm5lbCcsIHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVkU3ViY2hhbm5lbCA9IG5ldyBDaGFubmVsU3ViY2hhbm5lbFdyYXBwZXIoc3ViY2hhbm5lbCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZFN1YmNoYW5uZWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gcGlja2VyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVDb3B5ID0gdGhpcy5waWNrUXVldWUuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVDb3B5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgcXVldWVDb3B5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSBuZXcgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMS5SZXNvbHZpbmdMb2FkQmFsYW5jZXIodGhpcy50YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCB0aGlzLm9wdGlvbnMsIChzZXJ2aWNlQ29uZmlnLCBjb25maWdTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xyXG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5zZXQodGhpcy5nZXRUYXJnZXQoKSwgbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeVRocm90dGxlcihzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy5tYXhUb2tlbnMsIHNlcnZpY2VDb25maWcucmV0cnlUaHJvdHRsaW5nLnRva2VuUmF0aW8sIFJFVFJZX1RIUk9UVExFUl9NQVAuZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBSRVRSWV9USFJPVFRMRVJfTUFQLmRlbGV0ZSh0aGlzLmdldFRhcmdldCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci50cmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdBZGRyZXNzIHJlc29sdXRpb24gc3VjY2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9hID0gdGhpcy5jb25maWdTZWxlY3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVucmVmKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBjb25maWdTZWxlY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgLyogV2UgcHJvY2VzcyB0aGUgcXVldWUgYXN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICAgICAgICAgICAgICogbG9hZCBiYWxhbmNlciB1cGRhdGUgaGFzIGNvbXBsZXRlZC4gKi9cclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbFF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwuZ2V0Q29uZmlnKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLnRyYWNlLmFkZFRyYWNlKCdDVF9XQVJOSU5HJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjb2RlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5jb2RlICtcclxuICAgICAgICAgICAgICAgICAgICAnIGFuZCBkZXRhaWxzIFwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xyXG4gICAgICAgICAgICAgICAgICAgICdcIicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05hbWUgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjYWxscyBxdWV1ZWQgZm9yIGNvbmZpZyBzZWxlY3Rpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3RvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscykpLCB7IG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBsb2NhbFF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLnJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXHJcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdDaGFubmVsIGNvbnN0cnVjdGVkIHdpdGggb3B0aW9ucyAnICtcclxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICBpZiAoKDAsIGxvZ2dpbmdfMS5pc1RyYWNlckVuYWJsZWQpKCdjaGFubmVsX3N0YWNrdHJhY2UnKSkge1xyXG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsX3N0YWNrdHJhY2UnLCAnKCcgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXHJcbiAgICAgICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgICAgICdDaGFubmVsIGNvbnN0cnVjdGVkIFxcbicgK1xyXG4gICAgICAgICAgICAgICAgKChfZiA9IGVycm9yLnN0YWNrKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3Vic3RyaW5nKGVycm9yLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgdHJhY2UodGV4dCwgdmVyYm9zaXR5T3ZlcnJpZGUpIHtcclxuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKSh2ZXJib3NpdHlPdmVycmlkZSAhPT0gbnVsbCAmJiB2ZXJib3NpdHlPdmVycmlkZSAhPT0gdm9pZCAwID8gdmVyYm9zaXR5T3ZlcnJpZGUgOiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgKyAnICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIGNhbGxSZWZUaW1lclJlZigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxSZWZUaW1lcikge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgTUFYX1RJTUVPVVRfVElNRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBoYXNSZWYgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QsIGFsd2F5cyBydW4gdGhlIGNvZGVcclxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLmNhbGxSZWZUaW1lcikucmVmKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FsbFJlZlRpbWVyVW5yZWYoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgLy8gSWYgdGhlIHRpbWVyIG9yIHRoZSBoYXNSZWYgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QsIGFsd2F5cyBydW4gdGhlIGNvZGVcclxuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc1JlZikgfHwgdGhpcy5jYWxsUmVmVGltZXIuaGFzUmVmKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgJyBwaWNrUXVldWUubGVuZ3RoPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgKF9jID0gKF9iID0gdGhpcy5jYWxsUmVmVGltZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3Qgd2F0Y2hlckluZGV4ID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA9PT0gd2F0Y2hlck9iamVjdCk7XHJcbiAgICAgICAgaWYgKHdhdGNoZXJJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xyXG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2Nvbm5lY3Rpdml0eV9zdGF0ZScsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6SW5mb1RyYWNrZXIudHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZSB0byAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgIGNvbnN0IHdhdGNoZXJzQ29weSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlck9iamVjdCBvZiB3YXRjaGVyc0NvcHkpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoZXJPYmplY3QudGltZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2F0Y2hlck9iamVjdC50aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHdhdGNoZXJPYmplY3QuY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xyXG4gICAgICAgIGlmIChuZXdLZWVwYWxpdmVUaW1lID4gdGhpcy5rZWVwYWxpdmVUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgb2YgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMpIHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRTdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkV3JhcHBlZFN1YmNoYW5uZWwod3JhcHBlZFN1YmNoYW5uZWwpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5hZGQod3JhcHBlZFN1YmNoYW5uZWwpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwod3JhcHBlZFN1YmNoYW5uZWwpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5kZWxldGUod3JhcHBlZFN1YmNoYW5uZWwpO1xyXG4gICAgfVxyXG4gICAgZG9QaWNrKG1ldGFkYXRhLCBleHRyYVBpY2tJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxyXG4gICAgICAgICAgICBleHRyYVBpY2tJbmZvOiBleHRyYVBpY2tJbmZvLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcXVldWVDYWxsRm9yUGljayhjYWxsKSB7XHJcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaChjYWxsKTtcclxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29uZmlnKG1ldGhvZCwgbWV0YWRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTVUNDRVNTJyxcclxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdTZWxlY3Rvci5pbnZva2UobWV0aG9kLCBtZXRhZGF0YSwgdGhpcy5yYW5kb21DaGFubmVsSWQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRVJST1InLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTk9ORScsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWVDYWxsRm9yQ29uZmlnKGNhbGwpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLnB1c2goY2FsbCk7XHJcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcclxuICAgIH1cclxuICAgIGVudGVySWRsZSgpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNhbGxSZWZUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0SWRsZVRpbWVvdXQodGltZW91dE1zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBjYWxsLCB0aGUgY2hhbm5lbCB3aWxsIG5vdCBnbyBpZGxlIGZvciBhXHJcbiAgICAgICAgICAgICAgICAgKiBwZXJpb2Qgb2YgYXQgbGVhc3QgaWRsZVRpbWVvdXRNcywgc28gY2hlY2sgYWdhaW4gYWZ0ZXIgdGhhdCB0aW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0QWN0aXZpdHkgPSBub3cudmFsdWVPZigpIC0gdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdEFjdGl2aXR5ID49IHRoaXMuaWRsZVRpbWVvdXRNcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnSWRsZSB0aW1lciB0cmlnZ2VyZWQgYWZ0ZXIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGxlVGltZW91dE1zICtcclxuICAgICAgICAgICAgICAgICAgICAnbXMgb2YgaW5hY3Rpdml0eScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcklkbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qIFdoZW5ldmVyIHRoZSB0aW1lciBmaXJlcyB3aXRoIHRoZSBsYXRlc3QgYWN0aXZpdHkgYmVpbmcgdG9vIHJlY2VudCxcclxuICAgICAgICAgICAgICAgICAqIHNldCB0aGUgdGltZXIgYWdhaW4gZm9yIHRoZSB0aW1lIHdoZW4gdGhlIHRpbWUgc2luY2UgdGhlIGxhc3RcclxuICAgICAgICAgICAgICAgICAqIGFjdGl2aXR5IGlzIGVxdWFsIHRvIHRoZSB0aW1lb3V0LiBUaGlzIHNob3VsZCByZXN1bHQgaW4gdGhlIHRpbWVyXHJcbiAgICAgICAgICAgICAgICAgKiBmaXJpbmcgbm8gbW9yZSB0aGFuIG9uY2UgZXZlcnkgaWRsZVRpbWVvdXRNcy8yIG9uIGF2ZXJhZ2UuICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zIC0gdGltZVNpbmNlTGFzdEFjdGl2aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XHJcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5pZGxlVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICBtYXliZVN0YXJ0SWRsZVRpbWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTiAmJlxyXG4gICAgICAgICAgICAhdGhpcy5pZGxlVGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DYWxsU3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDb3VudCArPSAxO1xyXG4gICAgfVxyXG4gICAgb25DYWxsRW5kKHN0YXR1cykge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekluZm9UcmFja2VyLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpJbmZvVHJhY2tlci5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ291bnQgLT0gMTtcclxuICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xyXG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCBbJyArIGNhbGxOdW1iZXIgKyAnXSBtZXRob2Q9XCInICsgbWV0aG9kICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBsb2FkX2JhbGFuY2luZ19jYWxsXzEuTG9hZEJhbGFuY2luZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmV0cnlpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJldHJ5aW5nQ2FsbCBbJyArIGNhbGxOdW1iZXIgKyAnXSBtZXRob2Q9XCInICsgbWV0aG9kICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlpbmdDYWxsKHRoaXMsIGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyLCB0aGlzLnJldHJ5QnVmZmVyVHJhY2tlciwgUkVUUllfVEhST1RUTEVSX01BUC5nZXQodGhpcy5nZXRUYXJnZXQoKSkpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xyXG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXNvbHZpbmdDYWxsIFsnICtcclxuICAgICAgICAgICAgY2FsbE51bWJlciArXHJcbiAgICAgICAgICAgICddIG1ldGhvZD1cIicgK1xyXG4gICAgICAgICAgICBtZXRob2QgK1xyXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xyXG4gICAgICAgICAgICAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKShkZWFkbGluZSkpO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxyXG4gICAgICAgICAgICBmbGFnczogcHJvcGFnYXRlRmxhZ3MgIT09IG51bGwgJiYgcHJvcGFnYXRlRmxhZ3MgIT09IHZvaWQgMCA/IHByb3BhZ2F0ZUZsYWdzIDogY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFRkFVTFRTLFxyXG4gICAgICAgICAgICBob3N0OiBob3N0ICE9PSBudWxsICYmIGhvc3QgIT09IHZvaWQgMCA/IGhvc3QgOiB0aGlzLmRlZmF1bHRBdXRob3JpdHksXHJcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHJlc29sdmluZ19jYWxsXzEuUmVzb2x2aW5nQ2FsbCh0aGlzLCBtZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY2xvbmUoKSwgY2FsbE51bWJlcik7XHJcbiAgICAgICAgdGhpcy5vbkNhbGxTdGFydCgpO1xyXG4gICAgICAgIGNhbGwuYWRkU3RhdHVzV2F0Y2hlcihzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZChzdGF0dXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgU2h1dGRvd25QaWNrZXIoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSkge1xyXG4gICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCAnQ2hhbm5lbCBjbG9zZWQgYmVmb3JlIGNhbGwgc3RhcnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMucGlja1F1ZXVlKSB7XHJcbiAgICAgICAgICAgIGNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsICdDaGFubmVsIGNsb3NlZCBiZWZvcmUgY2FsbCBzdGFydGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZlRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYWxsUmVmVGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFBvb2wudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY29uZmlnU2VsZWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnJlZigpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcclxuICAgICAgICBjb25zdCBjb25uZWN0aXZpdHlTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XHJcbiAgICAgICAgaWYgKHRyeVRvQ29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5U3RhdGU7XHJcbiAgICB9XHJcbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcclxuICAgICAgICBpZiAoZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVhZGxpbmUgPT09IC1JbmZpbml0eSB8fCBkZWFkbGluZURhdGUgPD0gbm93KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdEZWFkbGluZSBwYXNzZWQgd2l0aG91dCBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlJykpO1xyXG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdhdGNoZXJPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcclxuICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHRpbWVyLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnB1c2god2F0Y2hlck9iamVjdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcclxuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5uZWx6UmVmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwtY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2020 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChildLoadBalancerHandler = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst TYPE_NAME = 'child_load_balancer_helper';\r\nclass ChildLoadBalancerHandler {\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.currentChild = null;\r\n        this.pendingChild = null;\r\n        this.latestConfig = null;\r\n        this.ChildPolicyHelper = class {\r\n            constructor(parent) {\r\n                this.parent = parent;\r\n                this.child = null;\r\n            }\r\n            createSubchannel(subchannelAddress, subchannelArgs) {\r\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\r\n            }\r\n            updateState(connectivityState, picker, errorMessage) {\r\n                var _a;\r\n                if (this.calledByPendingChild()) {\r\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\r\n                        return;\r\n                    }\r\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\r\n                    this.parent.currentChild = this.parent.pendingChild;\r\n                    this.parent.pendingChild = null;\r\n                }\r\n                else if (!this.calledByCurrentChild()) {\r\n                    return;\r\n                }\r\n                this.parent.channelControlHelper.updateState(connectivityState, picker, errorMessage);\r\n            }\r\n            requestReresolution() {\r\n                var _a;\r\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\r\n                if (this.child === latestChild) {\r\n                    this.parent.channelControlHelper.requestReresolution();\r\n                }\r\n            }\r\n            setChild(newChild) {\r\n                this.child = newChild;\r\n            }\r\n            addChannelzChild(child) {\r\n                this.parent.channelControlHelper.addChannelzChild(child);\r\n            }\r\n            removeChannelzChild(child) {\r\n                this.parent.channelControlHelper.removeChannelzChild(child);\r\n            }\r\n            calledByPendingChild() {\r\n                return this.child === this.parent.pendingChild;\r\n            }\r\n            calledByCurrentChild() {\r\n                return this.child === this.parent.currentChild;\r\n            }\r\n        };\r\n    }\r\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\r\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\r\n    }\r\n    /**\r\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\r\n     * @param endpointList\r\n     * @param lbConfig\r\n     * @param attributes\r\n     */\r\n    updateAddressList(endpointList, lbConfig, options) {\r\n        let childToUpdate;\r\n        if (this.currentChild === null ||\r\n            this.latestConfig === null ||\r\n            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\r\n            const newHelper = new this.ChildPolicyHelper(this);\r\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\r\n            newHelper.setChild(newChild);\r\n            if (this.currentChild === null) {\r\n                this.currentChild = newChild;\r\n                childToUpdate = this.currentChild;\r\n            }\r\n            else {\r\n                if (this.pendingChild) {\r\n                    this.pendingChild.destroy();\r\n                }\r\n                this.pendingChild = newChild;\r\n                childToUpdate = this.pendingChild;\r\n            }\r\n        }\r\n        else {\r\n            if (this.pendingChild === null) {\r\n                childToUpdate = this.currentChild;\r\n            }\r\n            else {\r\n                childToUpdate = this.pendingChild;\r\n            }\r\n        }\r\n        this.latestConfig = lbConfig;\r\n        childToUpdate.updateAddressList(endpointList, lbConfig, options);\r\n    }\r\n    exitIdle() {\r\n        if (this.currentChild) {\r\n            this.currentChild.exitIdle();\r\n            if (this.pendingChild) {\r\n                this.pendingChild.exitIdle();\r\n            }\r\n        }\r\n    }\r\n    resetBackoff() {\r\n        if (this.currentChild) {\r\n            this.currentChild.resetBackoff();\r\n            if (this.pendingChild) {\r\n                this.pendingChild.resetBackoff();\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        /* Note: state updates are only propagated from the child balancer if that\r\n         * object is equal to this.currentChild or this.pendingChild. Since this\r\n         * function sets both of those to null, no further state updates will\r\n         * occur after this function returns. */\r\n        if (this.currentChild) {\r\n            this.currentChild.destroy();\r\n            this.currentChild = null;\r\n        }\r\n        if (this.pendingChild) {\r\n            this.pendingChild.destroy();\r\n            this.pendingChild = null;\r\n        }\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\r\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanM/MjQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBUWVBFX05BTUUgPSAnY2hpbGRfbG9hZF9iYWxhbmNlcl9oZWxwZXInO1xyXG5jbGFzcyBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5DaGlsZFBvbGljeUhlbHBlciA9IGNsYXNzIHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RDaGlsZCA9IChfYSA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoaWxkKG5ld0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbmV3Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxlZEJ5Q3VycmVudENoaWxkKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZENvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgIT09IG5ld0NvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXJlcXVpc2l0ZXM6IGxiQ29uZmlnICE9PSBudWxsIGFuZCBsYkNvbmZpZy5uYW1lIGlzIHJlZ2lzdGVyZWRcclxuICAgICAqIEBwYXJhbSBlbmRwb2ludExpc3RcclxuICAgICAqIEBwYXJhbSBsYkNvbmZpZ1xyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsYkNvbmZpZywgb3B0aW9ucykge1xyXG4gICAgICAgIGxldCBjaGlsZFRvVXBkYXRlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1VwZGF0ZVJlcXVpcmVzTmV3UG9saWN5SW5zdGFuY2UodGhpcy5sYXRlc3RDb25maWcsIGxiQ29uZmlnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdIZWxwZXIgPSBuZXcgdGhpcy5DaGlsZFBvbGljeUhlbHBlcih0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUxvYWRCYWxhbmNlcikobGJDb25maWcsIG5ld0hlbHBlcik7XHJcbiAgICAgICAgICAgIG5ld0hlbHBlci5zZXRDaGlsZChuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBuZXdDaGlsZDtcclxuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbmV3Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbGJDb25maWc7XHJcbiAgICAgICAgY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmV4aXRJZGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLnJlc2V0QmFja29mZigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLnJlc2V0QmFja29mZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxyXG4gICAgICAgICAqIG9iamVjdCBpcyBlcXVhbCB0byB0aGlzLmN1cnJlbnRDaGlsZCBvciB0aGlzLnBlbmRpbmdDaGlsZC4gU2luY2UgdGhpc1xyXG4gICAgICAgICAqIGZ1bmN0aW9uIHNldHMgYm90aCBvZiB0aG9zZSB0byBudWxsLCBubyBmdXJ0aGVyIHN0YXRlIHVwZGF0ZXMgd2lsbFxyXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\r\nexports.setup = setup;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\r\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'outlier_detection';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'outlier_detection';\r\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\r\nconst defaultSuccessRateEjectionConfig = {\r\n    stdev_factor: 1900,\r\n    enforcement_percentage: 100,\r\n    minimum_hosts: 5,\r\n    request_volume: 100,\r\n};\r\nconst defaultFailurePercentageEjectionConfig = {\r\n    threshold: 85,\r\n    enforcement_percentage: 100,\r\n    minimum_hosts: 5,\r\n    request_volume: 50,\r\n};\r\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\r\n    if (fieldName in obj &&\r\n        obj[fieldName] !== undefined &&\r\n        typeof obj[fieldName] !== expectedType) {\r\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\r\n    }\r\n}\r\nfunction validatePositiveDuration(obj, fieldName, objectName) {\r\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n    if (fieldName in obj && obj[fieldName] !== undefined) {\r\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\r\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\r\n        }\r\n        if (!(obj[fieldName].seconds >= 0 &&\r\n            obj[fieldName].seconds <= 315576000000 &&\r\n            obj[fieldName].nanos >= 0 &&\r\n            obj[fieldName].nanos <= 999999999)) {\r\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\r\n        }\r\n    }\r\n}\r\nfunction validatePercentage(obj, fieldName, objectName) {\r\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n    validateFieldType(obj, fieldName, 'number', objectName);\r\n    if (fieldName in obj &&\r\n        obj[fieldName] !== undefined &&\r\n        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\r\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\r\n    }\r\n}\r\nclass OutlierDetectionLoadBalancingConfig {\r\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\r\n        this.childPolicy = childPolicy;\r\n        if (childPolicy.getLoadBalancerName() === 'pick_first') {\r\n            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');\r\n        }\r\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\r\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\r\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\r\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\r\n        this.successRateEjection = successRateEjection\r\n            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\r\n        this.failurePercentageEjection = failurePercentageEjection\r\n            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\r\n    }\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    toJsonObject() {\r\n        var _a, _b;\r\n        return {\r\n            outlier_detection: {\r\n                interval: (0, duration_1.msToDuration)(this.intervalMs),\r\n                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\r\n                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\r\n                max_ejection_percent: this.maxEjectionPercent,\r\n                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== void 0 ? _a : undefined,\r\n                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== void 0 ? _b : undefined,\r\n                child_policy: [this.childPolicy.toJsonObject()],\r\n            },\r\n        };\r\n    }\r\n    getIntervalMs() {\r\n        return this.intervalMs;\r\n    }\r\n    getBaseEjectionTimeMs() {\r\n        return this.baseEjectionTimeMs;\r\n    }\r\n    getMaxEjectionTimeMs() {\r\n        return this.maxEjectionTimeMs;\r\n    }\r\n    getMaxEjectionPercent() {\r\n        return this.maxEjectionPercent;\r\n    }\r\n    getSuccessRateEjectionConfig() {\r\n        return this.successRateEjection;\r\n    }\r\n    getFailurePercentageEjectionConfig() {\r\n        return this.failurePercentageEjection;\r\n    }\r\n    getChildPolicy() {\r\n        return this.childPolicy;\r\n    }\r\n    static createFromJson(obj) {\r\n        var _a;\r\n        validatePositiveDuration(obj, 'interval');\r\n        validatePositiveDuration(obj, 'base_ejection_time');\r\n        validatePositiveDuration(obj, 'max_ejection_time');\r\n        validatePercentage(obj, 'max_ejection_percent');\r\n        if ('success_rate_ejection' in obj &&\r\n            obj.success_rate_ejection !== undefined) {\r\n            if (typeof obj.success_rate_ejection !== 'object') {\r\n                throw new Error('outlier detection config success_rate_ejection must be an object');\r\n            }\r\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\r\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\r\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\r\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\r\n        }\r\n        if ('failure_percentage_ejection' in obj &&\r\n            obj.failure_percentage_ejection !== undefined) {\r\n            if (typeof obj.failure_percentage_ejection !== 'object') {\r\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\r\n            }\r\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\r\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\r\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\r\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\r\n        }\r\n        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {\r\n            throw new Error('outlier detection config child_policy must be an array');\r\n        }\r\n        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);\r\n        if (!childPolicy) {\r\n            throw new Error('outlier detection config child_policy: no valid recognized policy found');\r\n        }\r\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);\r\n    }\r\n}\r\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\r\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\r\n    constructor(childSubchannel, mapEntry) {\r\n        super(childSubchannel);\r\n        this.mapEntry = mapEntry;\r\n        this.refCount = 0;\r\n    }\r\n    ref() {\r\n        this.child.ref();\r\n        this.refCount += 1;\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n        this.refCount -= 1;\r\n        if (this.refCount <= 0) {\r\n            if (this.mapEntry) {\r\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\r\n                if (index >= 0) {\r\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    eject() {\r\n        this.setHealthy(false);\r\n    }\r\n    uneject() {\r\n        this.setHealthy(true);\r\n    }\r\n    getMapEntry() {\r\n        return this.mapEntry;\r\n    }\r\n    getWrappedSubchannel() {\r\n        return this.child;\r\n    }\r\n}\r\nfunction createEmptyBucket() {\r\n    return {\r\n        success: 0,\r\n        failure: 0,\r\n    };\r\n}\r\nclass CallCounter {\r\n    constructor() {\r\n        this.activeBucket = createEmptyBucket();\r\n        this.inactiveBucket = createEmptyBucket();\r\n    }\r\n    addSuccess() {\r\n        this.activeBucket.success += 1;\r\n    }\r\n    addFailure() {\r\n        this.activeBucket.failure += 1;\r\n    }\r\n    switchBuckets() {\r\n        this.inactiveBucket = this.activeBucket;\r\n        this.activeBucket = createEmptyBucket();\r\n    }\r\n    getLastSuccesses() {\r\n        return this.inactiveBucket.success;\r\n    }\r\n    getLastFailures() {\r\n        return this.inactiveBucket.failure;\r\n    }\r\n}\r\nclass OutlierDetectionPicker {\r\n    constructor(wrappedPicker, countCalls) {\r\n        this.wrappedPicker = wrappedPicker;\r\n        this.countCalls = countCalls;\r\n    }\r\n    pick(pickArgs) {\r\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\r\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\r\n            const subchannelWrapper = wrappedPick.subchannel;\r\n            const mapEntry = subchannelWrapper.getMapEntry();\r\n            if (mapEntry) {\r\n                let onCallEnded = wrappedPick.onCallEnded;\r\n                if (this.countCalls) {\r\n                    onCallEnded = statusCode => {\r\n                        var _a;\r\n                        if (statusCode === constants_1.Status.OK) {\r\n                            mapEntry.counter.addSuccess();\r\n                        }\r\n                        else {\r\n                            mapEntry.counter.addFailure();\r\n                        }\r\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\r\n                    };\r\n                }\r\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });\r\n            }\r\n            else {\r\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\r\n            }\r\n        }\r\n        else {\r\n            return wrappedPick;\r\n        }\r\n    }\r\n}\r\nclass OutlierDetectionLoadBalancer {\r\n    constructor(channelControlHelper) {\r\n        this.entryMap = new subchannel_address_1.EndpointMap();\r\n        this.latestConfig = null;\r\n        this.timerStartTime = null;\r\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\r\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\r\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\r\n                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);\r\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\r\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\r\n                    // If the address is ejected, propagate that to the new subchannel wrapper\r\n                    subchannelWrapper.eject();\r\n                }\r\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\r\n                return subchannelWrapper;\r\n            },\r\n            updateState: (connectivityState, picker, errorMessage) => {\r\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\r\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()), errorMessage);\r\n                }\r\n                else {\r\n                    channelControlHelper.updateState(connectivityState, picker, errorMessage);\r\n                }\r\n            },\r\n        }));\r\n        this.ejectionTimer = setInterval(() => { }, 0);\r\n        clearInterval(this.ejectionTimer);\r\n    }\r\n    isCountingEnabled() {\r\n        return (this.latestConfig !== null &&\r\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\r\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null));\r\n    }\r\n    getCurrentEjectionPercent() {\r\n        let ejectionCount = 0;\r\n        for (const mapEntry of this.entryMap.values()) {\r\n            if (mapEntry.currentEjectionTimestamp !== null) {\r\n                ejectionCount += 1;\r\n            }\r\n        }\r\n        return (ejectionCount * 100) / this.entryMap.size;\r\n    }\r\n    runSuccessRateCheck(ejectionTimestamp) {\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\r\n        if (!successRateConfig) {\r\n            return;\r\n        }\r\n        trace('Running success rate check');\r\n        // Step 1\r\n        const targetRequestVolume = successRateConfig.request_volume;\r\n        let addresesWithTargetVolume = 0;\r\n        const successRates = [];\r\n        for (const [endpoint, mapEntry] of this.entryMap.entries()) {\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            trace('Stats for ' +\r\n                (0, subchannel_address_1.endpointToString)(endpoint) +\r\n                ': successes=' +\r\n                successes +\r\n                ' failures=' +\r\n                failures +\r\n                ' targetRequestVolume=' +\r\n                targetRequestVolume);\r\n            if (successes + failures >= targetRequestVolume) {\r\n                addresesWithTargetVolume += 1;\r\n                successRates.push(successes / (successes + failures));\r\n            }\r\n        }\r\n        trace('Found ' +\r\n            addresesWithTargetVolume +\r\n            ' success rate candidates; currentEjectionPercent=' +\r\n            this.getCurrentEjectionPercent() +\r\n            ' successRates=[' +\r\n            successRates +\r\n            ']');\r\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\r\n            return;\r\n        }\r\n        // Step 2\r\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\r\n        let successRateDeviationSum = 0;\r\n        for (const rate of successRates) {\r\n            const deviation = rate - successRateMean;\r\n            successRateDeviationSum += deviation * deviation;\r\n        }\r\n        const successRateVariance = successRateDeviationSum / successRates.length;\r\n        const successRateStdev = Math.sqrt(successRateVariance);\r\n        const ejectionThreshold = successRateMean -\r\n            successRateStdev * (successRateConfig.stdev_factor / 1000);\r\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\r\n        // Step 3\r\n        for (const [address, mapEntry] of this.entryMap.entries()) {\r\n            // Step 3.i\r\n            if (this.getCurrentEjectionPercent() >=\r\n                this.latestConfig.getMaxEjectionPercent()) {\r\n                break;\r\n            }\r\n            // Step 3.ii\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            if (successes + failures < targetRequestVolume) {\r\n                continue;\r\n            }\r\n            // Step 3.iii\r\n            const successRate = successes / (successes + failures);\r\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\r\n            if (successRate < ejectionThreshold) {\r\n                const randomNumber = Math.random() * 100;\r\n                trace('Candidate ' +\r\n                    address +\r\n                    ' randomNumber=' +\r\n                    randomNumber +\r\n                    ' enforcement_percentage=' +\r\n                    successRateConfig.enforcement_percentage);\r\n                if (randomNumber < successRateConfig.enforcement_percentage) {\r\n                    trace('Ejecting candidate ' + address);\r\n                    this.eject(mapEntry, ejectionTimestamp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    runFailurePercentageCheck(ejectionTimestamp) {\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\r\n        if (!failurePercentageConfig) {\r\n            return;\r\n        }\r\n        trace('Running failure percentage check. threshold=' +\r\n            failurePercentageConfig.threshold +\r\n            ' request volume threshold=' +\r\n            failurePercentageConfig.request_volume);\r\n        // Step 1\r\n        let addressesWithTargetVolume = 0;\r\n        for (const mapEntry of this.entryMap.values()) {\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            if (successes + failures >= failurePercentageConfig.request_volume) {\r\n                addressesWithTargetVolume += 1;\r\n            }\r\n        }\r\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\r\n            return;\r\n        }\r\n        // Step 2\r\n        for (const [address, mapEntry] of this.entryMap.entries()) {\r\n            // Step 2.i\r\n            if (this.getCurrentEjectionPercent() >=\r\n                this.latestConfig.getMaxEjectionPercent()) {\r\n                break;\r\n            }\r\n            // Step 2.ii\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            trace('Candidate successes=' + successes + ' failures=' + failures);\r\n            if (successes + failures < failurePercentageConfig.request_volume) {\r\n                continue;\r\n            }\r\n            // Step 2.iii\r\n            const failurePercentage = (failures * 100) / (failures + successes);\r\n            if (failurePercentage > failurePercentageConfig.threshold) {\r\n                const randomNumber = Math.random() * 100;\r\n                trace('Candidate ' +\r\n                    address +\r\n                    ' randomNumber=' +\r\n                    randomNumber +\r\n                    ' enforcement_percentage=' +\r\n                    failurePercentageConfig.enforcement_percentage);\r\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\r\n                    trace('Ejecting candidate ' + address);\r\n                    this.eject(mapEntry, ejectionTimestamp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    eject(mapEntry, ejectionTimestamp) {\r\n        mapEntry.currentEjectionTimestamp = new Date();\r\n        mapEntry.ejectionTimeMultiplier += 1;\r\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\r\n            subchannelWrapper.eject();\r\n        }\r\n    }\r\n    uneject(mapEntry) {\r\n        mapEntry.currentEjectionTimestamp = null;\r\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\r\n            subchannelWrapper.uneject();\r\n        }\r\n    }\r\n    switchAllBuckets() {\r\n        for (const mapEntry of this.entryMap.values()) {\r\n            mapEntry.counter.switchBuckets();\r\n        }\r\n    }\r\n    startTimer(delayMs) {\r\n        var _a, _b;\r\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\r\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    runChecks() {\r\n        const ejectionTimestamp = new Date();\r\n        trace('Ejection timer running');\r\n        this.switchAllBuckets();\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        this.timerStartTime = ejectionTimestamp;\r\n        this.startTimer(this.latestConfig.getIntervalMs());\r\n        this.runSuccessRateCheck(ejectionTimestamp);\r\n        this.runFailurePercentageCheck(ejectionTimestamp);\r\n        for (const [address, mapEntry] of this.entryMap.entries()) {\r\n            if (mapEntry.currentEjectionTimestamp === null) {\r\n                if (mapEntry.ejectionTimeMultiplier > 0) {\r\n                    mapEntry.ejectionTimeMultiplier -= 1;\r\n                }\r\n            }\r\n            else {\r\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\r\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\r\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\r\n                returnTime.setMilliseconds(returnTime.getMilliseconds() +\r\n                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\r\n                if (returnTime < new Date()) {\r\n                    trace('Unejecting ' + address);\r\n                    this.uneject(mapEntry);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    updateAddressList(endpointList, lbConfig, options) {\r\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\r\n            return;\r\n        }\r\n        trace('Received update with config: ' + JSON.stringify(lbConfig.toJsonObject(), undefined, 2));\r\n        for (const endpoint of endpointList) {\r\n            if (!this.entryMap.has(endpoint)) {\r\n                trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));\r\n                this.entryMap.set(endpoint, {\r\n                    counter: new CallCounter(),\r\n                    currentEjectionTimestamp: null,\r\n                    ejectionTimeMultiplier: 0,\r\n                    subchannelWrappers: [],\r\n                });\r\n            }\r\n        }\r\n        this.entryMap.deleteMissing(endpointList);\r\n        const childPolicy = lbConfig.getChildPolicy();\r\n        this.childBalancer.updateAddressList(endpointList, childPolicy, options);\r\n        if (lbConfig.getSuccessRateEjectionConfig() ||\r\n            lbConfig.getFailurePercentageEjectionConfig()) {\r\n            if (this.timerStartTime) {\r\n                trace('Previous timer existed. Replacing timer');\r\n                clearTimeout(this.ejectionTimer);\r\n                const remainingDelay = lbConfig.getIntervalMs() -\r\n                    (new Date().getTime() - this.timerStartTime.getTime());\r\n                this.startTimer(remainingDelay);\r\n            }\r\n            else {\r\n                trace('Starting new timer');\r\n                this.timerStartTime = new Date();\r\n                this.startTimer(lbConfig.getIntervalMs());\r\n                this.switchAllBuckets();\r\n            }\r\n        }\r\n        else {\r\n            trace('Counting disabled. Cancelling timer.');\r\n            this.timerStartTime = null;\r\n            clearTimeout(this.ejectionTimer);\r\n            for (const mapEntry of this.entryMap.values()) {\r\n                this.uneject(mapEntry);\r\n                mapEntry.ejectionTimeMultiplier = 0;\r\n            }\r\n        }\r\n        this.latestConfig = lbConfig;\r\n    }\r\n    exitIdle() {\r\n        this.childBalancer.exitIdle();\r\n    }\r\n    resetBackoff() {\r\n        this.childBalancer.resetBackoff();\r\n    }\r\n    destroy() {\r\n        clearTimeout(this.ejectionTimer);\r\n        this.childBalancer.destroy();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\r\nfunction setup() {\r\n    if (OUTLIER_DETECTION_ENABLED) {\r\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\r\n    }\r\n}\r\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcsMkNBQTJDO0FBQ2xGLGFBQWE7QUFDYiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCxzQ0FBc0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDN0UsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLEdBQUcsVUFBVTtBQUN0RSxvREFBb0QsZUFBZSx3QkFBd0IsYUFBYSxRQUFRLHNCQUFzQjtBQUN0STtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxHQUFHLFVBQVU7QUFDbEU7QUFDQTtBQUNBLHdEQUF3RCxlQUFlLHNDQUFzQyxzQkFBc0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVcsR0FBRyxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQixnRkFBZ0Y7QUFDdko7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0Isc0RBQXNEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcz8zYTJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxudmFyIF9hO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XHJcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuY29uc3QgVFlQRV9OQU1FID0gJ291dGxpZXJfZGV0ZWN0aW9uJztcclxuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcclxuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XHJcbiAgICBzdGRldl9mYWN0b3I6IDE5MDAsXHJcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXHJcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxyXG4gICAgcmVxdWVzdF92b2x1bWU6IDEwMCxcclxufTtcclxuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XHJcbiAgICB0aHJlc2hvbGQ6IDg1LFxyXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxyXG4gICAgbWluaW11bV9ob3N0czogNSxcclxuICAgIHJlcXVlc3Rfdm9sdW1lOiA1MCxcclxufTtcclxuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xyXG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiZcclxuICAgICAgICBvYmpbZmllbGROYW1lXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgdHlwZW9mIG9ialtmaWVsZE5hbWVdICE9PSBleHBlY3RlZFR5cGUpIHtcclxuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgZmllbGROYW1lLCBvYmplY3ROYW1lKSB7XHJcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XHJcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiBvYmpbZmllbGROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKCEoMCwgZHVyYXRpb25fMS5pc0R1cmF0aW9uKShvYmpbZmllbGROYW1lXSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEob2JqW2ZpZWxkTmFtZV0uc2Vjb25kcyA+PSAwICYmXHJcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXHJcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLm5hbm9zID49IDAgJiZcclxuICAgICAgICAgICAgb2JqW2ZpZWxkTmFtZV0ubmFub3MgPD0gOTk5OTk5OTk5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUGVyY2VudGFnZShvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xyXG4gICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xyXG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcclxuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmXHJcbiAgICAgICAgb2JqW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICEob2JqW2ZpZWxkTmFtZV0gPj0gMCAmJiBvYmpbZmllbGROYW1lXSA8PSAxMDApKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogdmFsdWUgb3V0IG9mIHJhbmdlIGZvciBwZXJjZW50YWdlICgwLTEwMClgKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbE1zLCBiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblBlcmNlbnQsIHN1Y2Nlc3NSYXRlRWplY3Rpb24sIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZFBvbGljeSA9IGNoaWxkUG9saWN5O1xyXG4gICAgICAgIGlmIChjaGlsZFBvbGljeS5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgPT09ICdwaWNrX2ZpcnN0Jykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXJfZGV0ZWN0aW9uIExCIHBvbGljeSBjYW5ub3QgaGF2ZSBhIHBpY2tfZmlyc3QgY2hpbGQgcG9saWN5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNcyA9IGludGVydmFsTXMgIT09IG51bGwgJiYgaW50ZXJ2YWxNcyAhPT0gdm9pZCAwID8gaW50ZXJ2YWxNcyA6IDEwMDAwO1xyXG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XHJcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcclxuICAgICAgICB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCA9IG1heEVqZWN0aW9uUGVyY2VudCAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblBlcmNlbnQgIT09IHZvaWQgMCA/IG1heEVqZWN0aW9uUGVyY2VudCA6IDEwO1xyXG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb25cclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiA9IGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25cclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgdG9Kc29uT2JqZWN0KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3V0bGllcl9kZXRlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuaW50ZXJ2YWxNcyksXHJcbiAgICAgICAgICAgICAgICBiYXNlX2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5iYXNlRWplY3Rpb25UaW1lTXMpLFxyXG4gICAgICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5tYXhFamVjdGlvblRpbWVNcyksXHJcbiAgICAgICAgICAgICAgICBtYXhfZWplY3Rpb25fcGVyY2VudDogdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzX3JhdGVfZWplY3Rpb246IChfYSA9IHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uOiAoX2IgPSB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGNoaWxkX3BvbGljeTogW3RoaXMuY2hpbGRQb2xpY3kudG9Kc29uT2JqZWN0KCldLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXRJbnRlcnZhbE1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsTXM7XHJcbiAgICB9XHJcbiAgICBnZXRCYXNlRWplY3Rpb25UaW1lTXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zO1xyXG4gICAgfVxyXG4gICAgZ2V0TWF4RWplY3Rpb25UaW1lTXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25UaW1lTXM7XHJcbiAgICB9XHJcbiAgICBnZXRNYXhFamVjdGlvblBlcmNlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25QZXJjZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRQb2xpY3koKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQb2xpY3k7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xyXG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcclxuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnbWF4X2VqZWN0aW9uX3RpbWUnKTtcclxuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcclxuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqICYmXHJcbiAgICAgICAgICAgIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24gIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBzdWNjZXNzX3JhdGVfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnc3RkZXZfZmFjdG9yJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcclxuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdyZXF1ZXN0X3ZvbHVtZScsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyBpbiBvYmogJiZcclxuICAgICAgICAgICAgb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdtaW5pbXVtX2hvc3RzJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcclxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoJ2NoaWxkX3BvbGljeScgaW4gb2JqKSB8fCAhQXJyYXkuaXNBcnJheShvYmouY2hpbGRfcG9saWN5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBjaGlsZF9wb2xpY3kgbXVzdCBiZSBhbiBhcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZFBvbGljeSA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuc2VsZWN0TGJDb25maWdGcm9tTGlzdCkob2JqLmNoaWxkX3BvbGljeSk7XHJcbiAgICAgICAgaWYgKCFjaGlsZFBvbGljeSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBjaGlsZF9wb2xpY3k6IG5vIHZhbGlkIHJlY29nbml6ZWQgcG9saWN5IGZvdW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIGNoaWxkUG9saWN5KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XHJcbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25TdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcclxuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xyXG4gICAgICAgIHRoaXMubWFwRW50cnkgPSBtYXBFbnRyeTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIHJlZigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcclxuICAgIH1cclxuICAgIHVucmVmKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWplY3QoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KGZhbHNlKTtcclxuICAgIH1cclxuICAgIHVuZWplY3QoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRIZWFsdGh5KHRydWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWFwRW50cnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRW50cnk7XHJcbiAgICB9XHJcbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFbXB0eUJ1Y2tldCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3VjY2VzczogMCxcclxuICAgICAgICBmYWlsdXJlOiAwLFxyXG4gICAgfTtcclxufVxyXG5jbGFzcyBDYWxsQ291bnRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XHJcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XHJcbiAgICB9XHJcbiAgICBhZGRTdWNjZXNzKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LnN1Y2Nlc3MgKz0gMTtcclxuICAgIH1cclxuICAgIGFkZEZhaWx1cmUoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuZmFpbHVyZSArPSAxO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoQnVja2V0cygpIHtcclxuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gdGhpcy5hY3RpdmVCdWNrZXQ7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGFzdFN1Y2Nlc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5zdWNjZXNzO1xyXG4gICAgfVxyXG4gICAgZ2V0TGFzdEZhaWx1cmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LmZhaWx1cmU7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgT3V0bGllckRldGVjdGlvblBpY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkUGlja2VyLCBjb3VudENhbGxzKSB7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkUGlja2VyID0gd3JhcHBlZFBpY2tlcjtcclxuICAgICAgICB0aGlzLmNvdW50Q2FsbHMgPSBjb3VudENhbGxzO1xyXG4gICAgfVxyXG4gICAgcGljayhwaWNrQXJncykge1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRQaWNrID0gdGhpcy53cmFwcGVkUGlja2VyLnBpY2socGlja0FyZ3MpO1xyXG4gICAgICAgIGlmICh3cmFwcGVkUGljay5waWNrUmVzdWx0VHlwZSA9PT0gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSB3cmFwcGVkUGljay5zdWJjaGFubmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHN1YmNoYW5uZWxXcmFwcGVyLmdldE1hcEVudHJ5KCk7XHJcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9uQ2FsbEVuZGVkID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudENhbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25DYWxsRW5kZWQgPSBzdGF0dXNDb2RlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLmFkZFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkRmFpbHVyZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHdyYXBwZWRQaWNrLm9uQ2FsbEVuZGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3cmFwcGVkUGljaywgc3RhdHVzQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpLCBvbkNhbGxFbmRlZDogb25DYWxsRW5kZWQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5lbnRyeU1hcCA9IG5ldyBzdWJjaGFubmVsX2FkZHJlc3NfMS5FbmRwb2ludE1hcCgpO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKCgwLCBleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xyXG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN1YmNoYW5uZWwgPSBjaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuZW50cnlNYXAuZ2V0Rm9yU3ViY2hhbm5lbEFkZHJlc3Moc3ViY2hhbm5lbEFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhZGRyZXNzIGlzIGVqZWN0ZWQsIHByb3BhZ2F0ZSB0aGF0IHRvIHRoZSBuZXcgc3ViY2hhbm5lbCB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMucHVzaChzdWJjaGFubmVsV3JhcHBlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlciwgZXJyb3JNZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIG5ldyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyKHBpY2tlciwgdGhpcy5pc0NvdW50aW5nRW5hYmxlZCgpKSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMCk7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xyXG4gICAgfVxyXG4gICAgaXNDb3VudGluZ0VuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAodGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwpKTtcclxuICAgIH1cclxuICAgIGdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSB7XHJcbiAgICAgICAgbGV0IGVqZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5lbnRyeU1hcC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlamVjdGlvbkNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChlamVjdGlvbkNvdW50ICogMTAwKSAvIHRoaXMuZW50cnlNYXAuc2l6ZTtcclxuICAgIH1cclxuICAgIHJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApIHtcclxuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzUmF0ZUNvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIHN1Y2Nlc3MgcmF0ZSBjaGVjaycpO1xyXG4gICAgICAgIC8vIFN0ZXAgMVxyXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcclxuICAgICAgICBsZXQgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcclxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludCwgbWFwRW50cnldIG9mIHRoaXMuZW50cnlNYXAuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xyXG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XHJcbiAgICAgICAgICAgIHRyYWNlKCdTdGF0cyBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykoZW5kcG9pbnQpICtcclxuICAgICAgICAgICAgICAgICc6IHN1Y2Nlc3Nlcz0nICtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArXHJcbiAgICAgICAgICAgICAgICAnIGZhaWx1cmVzPScgK1xyXG4gICAgICAgICAgICAgICAgZmFpbHVyZXMgK1xyXG4gICAgICAgICAgICAgICAgJyB0YXJnZXRSZXF1ZXN0Vm9sdW1lPScgK1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVxdWVzdFZvbHVtZSk7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcy5wdXNoKHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlKCdGb3VuZCAnICtcclxuICAgICAgICAgICAgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lICtcclxuICAgICAgICAgICAgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICtcclxuICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgK1xyXG4gICAgICAgICAgICAnIHN1Y2Nlc3NSYXRlcz1bJyArXHJcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcyArXHJcbiAgICAgICAgICAgICddJyk7XHJcbiAgICAgICAgaWYgKGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA8IHN1Y2Nlc3NSYXRlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGVwIDJcclxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCByYXRlIG9mIHN1Y2Nlc3NSYXRlcykge1xyXG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xyXG4gICAgICAgICAgICBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSArPSBkZXZpYXRpb24gKiBkZXZpYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVTdGRldiA9IE1hdGguc3FydChzdWNjZXNzUmF0ZVZhcmlhbmNlKTtcclxuICAgICAgICBjb25zdCBlamVjdGlvblRocmVzaG9sZCA9IHN1Y2Nlc3NSYXRlTWVhbiAtXHJcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XHJcbiAgICAgICAgdHJhY2UoJ3N0ZGV2PScgKyBzdWNjZXNzUmF0ZVN0ZGV2ICsgJyBlamVjdGlvblRocmVzaG9sZD0nICsgZWplY3Rpb25UaHJlc2hvbGQpO1xyXG4gICAgICAgIC8vIFN0ZXAgM1xyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmVudHJ5TWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj1cclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uUGVyY2VudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcclxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpaVxyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XHJcbiAgICAgICAgICAgIHRyYWNlKCdDaGVja2luZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHN1Y2Nlc3NSYXRlPScgKyBzdWNjZXNzUmF0ZSk7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzUmF0ZSA8IGVqZWN0aW9uVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzICtcclxuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcclxuICAgICAgICAgICAgICAgICAgICByYW5kb21OdW1iZXIgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgZW5mb3JjZW1lbnRfcGVyY2VudGFnZT0nICtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0VqZWN0aW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcclxuICAgICAgICBpZiAoIWZhaWx1cmVQZXJjZW50YWdlQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2UoJ1J1bm5pbmcgZmFpbHVyZSBwZXJjZW50YWdlIGNoZWNrLiB0aHJlc2hvbGQ9JyArXHJcbiAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCArXHJcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xyXG4gICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSk7XHJcbiAgICAgICAgLy8gU3RlcCAxXHJcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5lbnRyeU1hcC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGVwIDJcclxuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5lbnRyeU1hcC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gU3RlcCAyLmlcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpXHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xyXG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XHJcbiAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgc3VjY2Vzc2VzPScgKyBzdWNjZXNzZXMgKyAnIGZhaWx1cmVzPScgKyBmYWlsdXJlcyk7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGVwIDIuaWlpXHJcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XHJcbiAgICAgICAgICAgIGlmIChmYWlsdXJlUGVyY2VudGFnZSA+IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcclxuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyByYW5kb21OdW1iZXI9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcclxuICAgICAgICAgICAgICAgICAgICAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWplY3QobWFwRW50cnksIGVqZWN0aW9uVGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCkge1xyXG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLmVqZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdW5lamVjdChtYXBFbnRyeSkge1xyXG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsV3JhcHBlciBvZiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMpIHtcclxuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIudW5lamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN3aXRjaEFsbEJ1Y2tldHMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmVudHJ5TWFwLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bkNoZWNrcygpLCBkZWxheU1zKTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICBydW5DaGVja3MoKSB7XHJcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRyYWNlKCdFamVjdGlvbiB0aW1lciBydW5uaW5nJyk7XHJcbiAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZXIodGhpcy5sYXRlc3RDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcclxuICAgICAgICB0aGlzLnJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuZW50cnlNYXAuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgLT0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEJhc2VFamVjdGlvblRpbWVNcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4RWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblRpbWVNcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVGltZSA9IG5ldyBEYXRlKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcC5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVGltZS5zZXRNaWxsaXNlY29uZHMocmV0dXJuVGltZS5nZXRNaWxsaXNlY29uZHMoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oYmFzZUVqZWN0aW9uVGltZU1zICogbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciwgTWF0aC5tYXgoYmFzZUVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblRpbWVNcykpKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UaW1lIDwgbmV3IERhdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdVbmVqZWN0aW5nICcgKyBhZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBsYkNvbmZpZywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIHVwZGF0ZSB3aXRoIGNvbmZpZzogJyArIEpTT04uc3RyaW5naWZ5KGxiQ29uZmlnLnRvSnNvbk9iamVjdCgpLCB1bmRlZmluZWQsIDIpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50TGlzdCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW50cnlNYXAuaGFzKGVuZHBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRUb1N0cmluZykoZW5kcG9pbnQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW50cnlNYXAuc2V0KGVuZHBvaW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogbmV3IENhbGxDb3VudGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVqZWN0aW9uVGltZXN0YW1wOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGVqZWN0aW9uVGltZU11bHRpcGxpZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW50cnlNYXAuZGVsZXRlTWlzc2luZyhlbmRwb2ludExpc3QpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUG9saWN5ID0gbGJDb25maWcuZ2V0Q2hpbGRQb2xpY3koKTtcclxuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoZW5kcG9pbnRMaXN0LCBjaGlsZFBvbGljeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB8fFxyXG4gICAgICAgICAgICBsYkNvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlKCdQcmV2aW91cyB0aW1lciBleGlzdGVkLiBSZXBsYWNpbmcgdGltZXInKTtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVqZWN0aW9uVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLVxyXG4gICAgICAgICAgICAgICAgICAgIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMudGltZXJTdGFydFRpbWUuZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihyZW1haW5pbmdEZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZSgnU3RhcnRpbmcgbmV3IHRpbWVyJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVqZWN0aW9uVGltZXIpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuZW50cnlNYXAudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgZXhpdElkbGUoKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmV4aXRJZGxlKCk7XHJcbiAgICB9XHJcbiAgICByZXNldEJhY2tvZmYoKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcclxuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0VHlwZU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyO1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgIGlmIChPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEKSB7XHJcbiAgICAgICAgKDAsIGV4cGVyaW1lbnRhbF8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyLCBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\r\nexports.shuffled = shuffled;\r\nexports.setup = setup;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst subchannel_address_2 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst TRACER_NAME = 'pick_first';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'pick_first';\r\n/**\r\n * Delay after starting a connection on a subchannel before starting a\r\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\r\n */\r\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\r\nclass PickFirstLoadBalancingConfig {\r\n    constructor(shuffleAddressList) {\r\n        this.shuffleAddressList = shuffleAddressList;\r\n    }\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    toJsonObject() {\r\n        return {\r\n            [TYPE_NAME]: {\r\n                shuffleAddressList: this.shuffleAddressList,\r\n            },\r\n        };\r\n    }\r\n    getShuffleAddressList() {\r\n        return this.shuffleAddressList;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static createFromJson(obj) {\r\n        if ('shuffleAddressList' in obj &&\r\n            !(typeof obj.shuffleAddressList === 'boolean')) {\r\n            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\r\n        }\r\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\r\n    }\r\n}\r\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\r\n/**\r\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\r\n * picked subchannel.\r\n */\r\nclass PickFirstPicker {\r\n    constructor(subchannel) {\r\n        this.subchannel = subchannel;\r\n    }\r\n    pick(pickArgs) {\r\n        return {\r\n            pickResultType: picker_1.PickResultType.COMPLETE,\r\n            subchannel: this.subchannel,\r\n            status: null,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n}\r\n/**\r\n * Return a new array with the elements of the input array in a random order\r\n * @param list The input array\r\n * @returns A shuffled array of the elements of list\r\n */\r\nfunction shuffled(list) {\r\n    const result = list.slice();\r\n    for (let i = result.length - 1; i > 1; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        const temp = result[i];\r\n        result[i] = result[j];\r\n        result[j] = temp;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Interleave addresses in addressList by family in accordance with RFC-8304 section 4\r\n * @param addressList\r\n * @returns\r\n */\r\nfunction interleaveAddressFamilies(addressList) {\r\n    if (addressList.length === 0) {\r\n        return [];\r\n    }\r\n    const result = [];\r\n    const ipv6Addresses = [];\r\n    const ipv4Addresses = [];\r\n    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);\r\n    for (const address of addressList) {\r\n        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {\r\n            ipv6Addresses.push(address);\r\n        }\r\n        else {\r\n            ipv4Addresses.push(address);\r\n        }\r\n    }\r\n    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;\r\n    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;\r\n    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {\r\n        if (i < firstList.length) {\r\n            result.push(firstList[i]);\r\n        }\r\n        if (i < secondList.length) {\r\n            result.push(secondList[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nconst REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';\r\nclass PickFirstLoadBalancer {\r\n    /**\r\n     * Load balancer that attempts to connect to each backend in the address list\r\n     * in order, and picks the first one that connects, using it for every\r\n     * request.\r\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\r\n     *     this load balancer's owner.\r\n     */\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        /**\r\n         * The list of subchannels this load balancer is currently attempting to\r\n         * connect to.\r\n         */\r\n        this.children = [];\r\n        /**\r\n         * The current connectivity state of the load balancer.\r\n         */\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The index within the `subchannels` array of the subchannel with the most\r\n         * recently started connection attempt.\r\n         */\r\n        this.currentSubchannelIndex = 0;\r\n        /**\r\n         * The currently picked subchannel used for making calls. Populated if\r\n         * and only if the load balancer's current state is READY. In that case,\r\n         * the subchannel's current state is also READY.\r\n         */\r\n        this.currentPick = null;\r\n        /**\r\n         * Listener callback attached to each subchannel in the `subchannels` list\r\n         * while establishing a connection.\r\n         */\r\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\r\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\r\n        };\r\n        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();\r\n        /**\r\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\r\n         * subchannels have failed to connect at least once, and it stays in that\r\n         * mode until a connection attempt is successful. While in sticky TF mode,\r\n         * the LB policy continuously attempts to connect to all of its subchannels.\r\n         */\r\n        this.stickyTransientFailureMode = false;\r\n        this.reportHealthStatus = false;\r\n        /**\r\n         * The most recent error reported by any subchannel as it transitioned to\r\n         * TRANSIENT_FAILURE.\r\n         */\r\n        this.lastError = null;\r\n        this.latestAddressList = null;\r\n        this.latestOptions = {};\r\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\r\n        clearTimeout(this.connectionDelayTimeout);\r\n    }\r\n    allChildrenHaveReportedTF() {\r\n        return this.children.every(child => child.hasReportedTransientFailure);\r\n    }\r\n    resetChildrenReportedTF() {\r\n        this.children.every(child => child.hasReportedTransientFailure = false);\r\n    }\r\n    calculateAndReportNewState() {\r\n        var _a;\r\n        if (this.currentPick) {\r\n            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {\r\n                const errorMessage = `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`;\r\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\r\n                    details: errorMessage,\r\n                }), errorMessage);\r\n            }\r\n            else {\r\n                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick), null);\r\n            }\r\n        }\r\n        else if (((_a = this.latestAddressList) === null || _a === void 0 ? void 0 : _a.length) === 0) {\r\n            const errorMessage = `No connection established. Last error: ${this.lastError}`;\r\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\r\n                details: errorMessage,\r\n            }), errorMessage);\r\n        }\r\n        else if (this.children.length === 0) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\r\n        }\r\n        else {\r\n            if (this.stickyTransientFailureMode) {\r\n                const errorMessage = `No connection established. Last error: ${this.lastError}`;\r\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\r\n                    details: errorMessage,\r\n                }), errorMessage);\r\n            }\r\n            else {\r\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\r\n            }\r\n        }\r\n    }\r\n    requestReresolution() {\r\n        this.channelControlHelper.requestReresolution();\r\n    }\r\n    maybeEnterStickyTransientFailureMode() {\r\n        if (!this.allChildrenHaveReportedTF()) {\r\n            return;\r\n        }\r\n        this.requestReresolution();\r\n        this.resetChildrenReportedTF();\r\n        if (this.stickyTransientFailureMode) {\r\n            this.calculateAndReportNewState();\r\n            return;\r\n        }\r\n        this.stickyTransientFailureMode = true;\r\n        for (const { subchannel } of this.children) {\r\n            subchannel.startConnecting();\r\n        }\r\n        this.calculateAndReportNewState();\r\n    }\r\n    removeCurrentPick() {\r\n        if (this.currentPick !== null) {\r\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\r\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\r\n            this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);\r\n            // Unref last, to avoid triggering listeners\r\n            this.currentPick.unref();\r\n            this.currentPick = null;\r\n        }\r\n    }\r\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\r\n        var _a;\r\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\r\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\r\n                this.removeCurrentPick();\r\n                this.calculateAndReportNewState();\r\n            }\r\n            return;\r\n        }\r\n        for (const [index, child] of this.children.entries()) {\r\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\r\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n                    this.pickSubchannel(child.subchannel);\r\n                }\r\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                    child.hasReportedTransientFailure = true;\r\n                    if (errorMessage) {\r\n                        this.lastError = errorMessage;\r\n                    }\r\n                    this.maybeEnterStickyTransientFailureMode();\r\n                    if (index === this.currentSubchannelIndex) {\r\n                        this.startNextSubchannelConnecting(index + 1);\r\n                    }\r\n                }\r\n                child.subchannel.startConnecting();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    startNextSubchannelConnecting(startIndex) {\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        for (const [index, child] of this.children.entries()) {\r\n            if (index >= startIndex) {\r\n                const subchannelState = child.subchannel.getConnectivityState();\r\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\r\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\r\n                    this.startConnecting(index);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.maybeEnterStickyTransientFailureMode();\r\n    }\r\n    /**\r\n     * Have a single subchannel in the `subchannels` list start connecting.\r\n     * @param subchannelIndex The index into the `subchannels` list.\r\n     */\r\n    startConnecting(subchannelIndex) {\r\n        var _a, _b;\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        this.currentSubchannelIndex = subchannelIndex;\r\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===\r\n            connectivity_state_1.ConnectivityState.IDLE) {\r\n            trace('Start connecting to subchannel with address ' +\r\n                this.children[subchannelIndex].subchannel.getAddress());\r\n            process.nextTick(() => {\r\n                var _a;\r\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\r\n            });\r\n        }\r\n        this.connectionDelayTimeout = setTimeout(() => {\r\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\r\n        }, CONNECTION_DELAY_INTERVAL_MS);\r\n        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    /**\r\n     * Declare that the specified subchannel should be used to make requests.\r\n     * This functions the same independent of whether subchannel is a member of\r\n     * this.children and whether it is equal to this.currentPick.\r\n     * Prerequisite: subchannel.getConnectivityState() === READY.\r\n     * @param subchannel\r\n     */\r\n    pickSubchannel(subchannel) {\r\n        trace('Pick subchannel with address ' + subchannel.getAddress());\r\n        this.stickyTransientFailureMode = false;\r\n        /* Ref before removeCurrentPick and resetSubchannelList to avoid the\r\n         * refcount dropping to 0 during this process. */\r\n        subchannel.ref();\r\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\r\n        this.removeCurrentPick();\r\n        this.resetSubchannelList();\r\n        subchannel.addConnectivityStateListener(this.subchannelStateListener);\r\n        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);\r\n        this.currentPick = subchannel;\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        this.calculateAndReportNewState();\r\n    }\r\n    updateState(newState, picker, errorMessage) {\r\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        this.currentState = newState;\r\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\r\n    }\r\n    resetSubchannelList() {\r\n        for (const child of this.children) {\r\n            /* Always remoev the connectivity state listener. If the subchannel is\r\n               getting picked, it will be re-added then. */\r\n            child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\r\n            /* Refs are counted independently for the children list and the\r\n             * currentPick, so we call unref whether or not the child is the\r\n             * currentPick. Channelz child references are also refcounted, so\r\n             * removeChannelzChild can be handled the same way. */\r\n            child.subchannel.unref();\r\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\r\n        }\r\n        this.currentSubchannelIndex = 0;\r\n        this.children = [];\r\n    }\r\n    connectToAddressList(addressList, options) {\r\n        trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\r\n        const newChildrenList = addressList.map(address => ({\r\n            subchannel: this.channelControlHelper.createSubchannel(address, options),\r\n            hasReportedTransientFailure: false,\r\n        }));\r\n        for (const { subchannel } of newChildrenList) {\r\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\r\n                this.pickSubchannel(subchannel);\r\n                return;\r\n            }\r\n        }\r\n        /* Ref each subchannel before resetting the list, to ensure that\r\n         * subchannels shared between the list don't drop to 0 refs during the\r\n         * transition. */\r\n        for (const { subchannel } of newChildrenList) {\r\n            subchannel.ref();\r\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\r\n        }\r\n        this.resetSubchannelList();\r\n        this.children = newChildrenList;\r\n        for (const { subchannel } of this.children) {\r\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\r\n        }\r\n        for (const child of this.children) {\r\n            if (child.subchannel.getConnectivityState() ===\r\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                child.hasReportedTransientFailure = true;\r\n            }\r\n        }\r\n        this.startNextSubchannelConnecting(0);\r\n        this.calculateAndReportNewState();\r\n    }\r\n    updateAddressList(endpointList, lbConfig, options) {\r\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\r\n            return;\r\n        }\r\n        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];\r\n        /* Previously, an update would be discarded if it was identical to the\r\n         * previous update, to minimize churn. Now the DNS resolver is\r\n         * rate-limited, so that is less of a concern. */\r\n        if (lbConfig.getShuffleAddressList()) {\r\n            endpointList = shuffled(endpointList);\r\n        }\r\n        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\r\n        trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');\r\n        if (rawAddressList.length === 0) {\r\n            this.lastError = 'No addresses resolved';\r\n        }\r\n        const addressList = interleaveAddressFamilies(rawAddressList);\r\n        this.latestAddressList = addressList;\r\n        this.latestOptions = options;\r\n        this.connectToAddressList(addressList, options);\r\n    }\r\n    exitIdle() {\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&\r\n            this.latestAddressList) {\r\n            this.connectToAddressList(this.latestAddressList, this.latestOptions);\r\n        }\r\n    }\r\n    resetBackoff() {\r\n        /* The pick first load balancer does not have a connection backoff, so this\r\n         * does nothing */\r\n    }\r\n    destroy() {\r\n        this.resetSubchannelList();\r\n        this.removeCurrentPick();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\r\nconst LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);\r\n/**\r\n * This class handles the leaf load balancing operations for a single endpoint.\r\n * It is a thin wrapper around a PickFirstLoadBalancer with a different API\r\n * that more closely reflects how it will be used as a leaf balancer.\r\n */\r\nclass LeafLoadBalancer {\r\n    constructor(endpoint, channelControlHelper, options) {\r\n        this.endpoint = endpoint;\r\n        this.options = options;\r\n        this.latestState = connectivity_state_1.ConnectivityState.IDLE;\r\n        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\r\n            updateState: (connectivityState, picker, errorMessage) => {\r\n                this.latestState = connectivityState;\r\n                this.latestPicker = picker;\r\n                channelControlHelper.updateState(connectivityState, picker, errorMessage);\r\n            },\r\n        });\r\n        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper);\r\n        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);\r\n    }\r\n    startConnecting() {\r\n        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG, Object.assign(Object.assign({}, this.options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));\r\n    }\r\n    /**\r\n     * Update the endpoint associated with this LeafLoadBalancer to a new\r\n     * endpoint. Does not trigger connection establishment if a connection\r\n     * attempt is not already in progress.\r\n     * @param newEndpoint\r\n     */\r\n    updateEndpoint(newEndpoint, newOptions) {\r\n        this.options = newOptions;\r\n        this.endpoint = newEndpoint;\r\n        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {\r\n            this.startConnecting();\r\n        }\r\n    }\r\n    getConnectivityState() {\r\n        return this.latestState;\r\n    }\r\n    getPicker() {\r\n        return this.latestPicker;\r\n    }\r\n    getEndpoint() {\r\n        return this.endpoint;\r\n    }\r\n    exitIdle() {\r\n        this.pickFirstBalancer.exitIdle();\r\n    }\r\n    destroy() {\r\n        this.pickFirstBalancer.destroy();\r\n    }\r\n}\r\nexports.LeafLoadBalancer = LeafLoadBalancer;\r\nfunction setup() {\r\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\r\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\r\n}\r\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsNkJBQTZCLEdBQUcsb0NBQW9DO0FBQy9GLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsbUJBQW1CLDBDQUEwQztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanM/ZjFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5MZWFmTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XHJcbmV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcclxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18yID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3BpY2tfZmlyc3QnO1xyXG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XHJcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xyXG59XHJcbmNvbnN0IFRZUEVfTkFNRSA9ICdwaWNrX2ZpcnN0JztcclxuLyoqXHJcbiAqIERlbGF5IGFmdGVyIHN0YXJ0aW5nIGEgY29ubmVjdGlvbiBvbiBhIHN1YmNoYW5uZWwgYmVmb3JlIHN0YXJ0aW5nIGFcclxuICogY29ubmVjdGlvbiBvbiB0aGUgbmV4dCBzdWJjaGFubmVsIGluIHRoZSBsaXN0LCBmb3IgSGFwcHkgRXllYmFsbHMgYWxnb3JpdGhtLlxyXG4gKi9cclxuY29uc3QgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyA9IDI1MDtcclxuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaHVmZmxlQWRkcmVzc0xpc3QpIHtcclxuICAgICAgICB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCA9IHNodWZmbGVBZGRyZXNzTGlzdDtcclxuICAgIH1cclxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcclxuICAgIH1cclxuICAgIHRvSnNvbk9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge1xyXG4gICAgICAgICAgICAgICAgc2h1ZmZsZUFkZHJlc3NMaXN0OiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdDtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XHJcbiAgICAgICAgaWYgKCdzaHVmZmxlQWRkcmVzc0xpc3QnIGluIG9iaiAmJlxyXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmouc2h1ZmZsZUFkZHJlc3NMaXN0ID09PSAnYm9vbGVhbicpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlja19maXJzdCBjb25maWcgZmllbGQgc2h1ZmZsZUFkZHJlc3NMaXN0IG11c3QgYmUgYSBib29sZWFuIGlmIHByb3ZpZGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyhvYmouc2h1ZmZsZUFkZHJlc3NMaXN0ID09PSB0cnVlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnO1xyXG4vKipcclxuICogUGlja2VyIGZvciBhIGBQaWNrRmlyc3RMb2FkQmFsYW5jZXJgIGluIHRoZSBSRUFEWSBzdGF0ZS4gQWx3YXlzIHJldHVybnMgdGhlXHJcbiAqIHBpY2tlZCBzdWJjaGFubmVsLlxyXG4gKi9cclxuY2xhc3MgUGlja0ZpcnN0UGlja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWwpIHtcclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xyXG4gICAgfVxyXG4gICAgcGljayhwaWNrQXJncykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcclxuICAgICAgICAgICAgc3ViY2hhbm5lbDogdGhpcy5zdWJjaGFubmVsLFxyXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBvZiB0aGUgaW5wdXQgYXJyYXkgaW4gYSByYW5kb20gb3JkZXJcclxuICogQHBhcmFtIGxpc3QgVGhlIGlucHV0IGFycmF5XHJcbiAqIEByZXR1cm5zIEEgc2h1ZmZsZWQgYXJyYXkgb2YgdGhlIGVsZW1lbnRzIG9mIGxpc3RcclxuICovXHJcbmZ1bmN0aW9uIHNodWZmbGVkKGxpc3QpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGxpc3Quc2xpY2UoKTtcclxuICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+IDE7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcclxuICAgICAgICBjb25zdCB0ZW1wID0gcmVzdWx0W2ldO1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcclxuICAgICAgICByZXN1bHRbal0gPSB0ZW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogSW50ZXJsZWF2ZSBhZGRyZXNzZXMgaW4gYWRkcmVzc0xpc3QgYnkgZmFtaWx5IGluIGFjY29yZGFuY2Ugd2l0aCBSRkMtODMwNCBzZWN0aW9uIDRcclxuICogQHBhcmFtIGFkZHJlc3NMaXN0XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcmxlYXZlQWRkcmVzc0ZhbWlsaWVzKGFkZHJlc3NMaXN0KSB7XHJcbiAgICBpZiAoYWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBpcHY2QWRkcmVzc2VzID0gW107XHJcbiAgICBjb25zdCBpcHY0QWRkcmVzc2VzID0gW107XHJcbiAgICBjb25zdCBpcHY2Rmlyc3QgPSAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzIuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzc0xpc3RbMF0pICYmICgwLCBuZXRfMS5pc0lQdjYpKGFkZHJlc3NMaXN0WzBdLmhvc3QpO1xyXG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NMaXN0KSB7XHJcbiAgICAgICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMi5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzKSAmJiAoMCwgbmV0XzEuaXNJUHY2KShhZGRyZXNzLmhvc3QpKSB7XHJcbiAgICAgICAgICAgIGlwdjZBZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlwdjRBZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaXJzdExpc3QgPSBpcHY2Rmlyc3QgPyBpcHY2QWRkcmVzc2VzIDogaXB2NEFkZHJlc3NlcztcclxuICAgIGNvbnN0IHNlY29uZExpc3QgPSBpcHY2Rmlyc3QgPyBpcHY0QWRkcmVzc2VzIDogaXB2NkFkZHJlc3NlcztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgoZmlyc3RMaXN0Lmxlbmd0aCwgc2Vjb25kTGlzdC5sZW5ndGgpOyBpKyspIHtcclxuICAgICAgICBpZiAoaSA8IGZpcnN0TGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZmlyc3RMaXN0W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCBzZWNvbmRMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChzZWNvbmRMaXN0W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IFJFUE9SVF9IRUFMVEhfU1RBVFVTX09QVElPTl9OQU1FID0gJ2dycGMtbm9kZS5pbnRlcm5hbC5waWNrLWZpcnN0LnJlcG9ydF9oZWFsdGhfc3RhdHVzJztcclxuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcclxuICAgICAqIGluIG9yZGVyLCBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGNvbm5lY3RzLCB1c2luZyBpdCBmb3IgZXZlcnlcclxuICAgICAqIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxyXG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cclxuICAgICAgICAgKiBjb25uZWN0IHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgb2YgdGhlIGxvYWQgYmFsYW5jZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxyXG4gICAgICAgICAqIHJlY2VudGx5IHN0YXJ0ZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBwaWNrZWQgc3ViY2hhbm5lbCB1c2VkIGZvciBtYWtpbmcgY2FsbHMuIFBvcHVsYXRlZCBpZlxyXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxyXG4gICAgICAgICAqIHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBzdGF0ZSBpcyBhbHNvIFJFQURZLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGNhbGxiYWNrIGF0dGFjaGVkIHRvIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0XHJcbiAgICAgICAgICogd2hpbGUgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGlja2VkU3ViY2hhbm5lbEhlYWx0aExpc3RlbmVyID0gKCkgPT4gdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBMQiBwb2xpY3kgZW50ZXJzIHN0aWNreSBUUkFOU0lFTlRfRkFJTFVSRSBtb2RlIHdoZW4gYWxsXHJcbiAgICAgICAgICogc3ViY2hhbm5lbHMgaGF2ZSBmYWlsZWQgdG8gY29ubmVjdCBhdCBsZWFzdCBvbmNlLCBhbmQgaXQgc3RheXMgaW4gdGhhdFxyXG4gICAgICAgICAqIG1vZGUgdW50aWwgYSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgc3VjY2Vzc2Z1bC4gV2hpbGUgaW4gc3RpY2t5IFRGIG1vZGUsXHJcbiAgICAgICAgICogdGhlIExCIHBvbGljeSBjb250aW51b3VzbHkgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBhbGwgb2YgaXRzIHN1YmNoYW5uZWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlcG9ydEhlYWx0aFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBlcnJvciByZXBvcnRlZCBieSBhbnkgc3ViY2hhbm5lbCBhcyBpdCB0cmFuc2l0aW9uZWQgdG9cclxuICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RPcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRDaGlsZHJlblJlcG9ydGVkVEYoKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2spIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb3J0SGVhbHRoU3RhdHVzICYmICF0aGlzLmN1cnJlbnRQaWNrLmlzSGVhbHRoeSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgUGlja2VkIHN1YmNoYW5uZWwgJHt0aGlzLmN1cnJlbnRQaWNrLmdldEFkZHJlc3MoKX0gaXMgdW5oZWFsdGh5YDtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JNZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgfSksIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgUGlja0ZpcnN0UGlja2VyKHRoaXMuY3VycmVudFBpY2spLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoKF9hID0gdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yTWVzc2FnZSxcclxuICAgICAgICAgICAgfSksIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHtcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xyXG4gICAgICAgIHRoaXMucmVzZXRDaGlsZHJlblJlcG9ydGVkVEYoKTtcclxuICAgICAgICBpZiAodGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUN1cnJlbnRQaWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHRoaXMuY3VycmVudFBpY2suZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlSGVhbHRoU3RhdGVXYXRjaGVyKHRoaXMucGlja2VkU3ViY2hhbm5lbEhlYWx0aExpc3RlbmVyKTtcclxuICAgICAgICAgICAgLy8gVW5yZWYgbGFzdCwgdG8gYXZvaWQgdHJpZ2dlcmluZyBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay51bnJlZigpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmN1cnJlbnRQaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhbFN1YmNoYW5uZWxFcXVhbHMoc3ViY2hhbm5lbCkpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkXSBvZiB0aGlzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyhjaGlsZC5zdWJjaGFubmVsKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoY2hpbGQuc3ViY2hhbm5lbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JNZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3Rpbmcoc3RhcnRJbmRleCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhdmUgYSBzaW5nbGUgc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0IHN0YXJ0IGNvbm5lY3RpbmcuXHJcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEluZGV4IFRoZSBpbmRleCBpbnRvIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0Q29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IHN1YmNoYW5uZWxJbmRleDtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cclxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICB0cmFjZSgnU3RhcnQgY29ubmVjdGluZyB0byBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XS5zdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCArIDEpO1xyXG4gICAgICAgIH0sIENPTk5FQ1RJT05fREVMQVlfSU5URVJWQUxfTVMpO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVjbGFyZSB0aGF0IHRoZSBzcGVjaWZpZWQgc3ViY2hhbm5lbCBzaG91bGQgYmUgdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbnMgdGhlIHNhbWUgaW5kZXBlbmRlbnQgb2Ygd2hldGhlciBzdWJjaGFubmVsIGlzIGEgbWVtYmVyIG9mXHJcbiAgICAgKiB0aGlzLmNoaWxkcmVuIGFuZCB3aGV0aGVyIGl0IGlzIGVxdWFsIHRvIHRoaXMuY3VycmVudFBpY2suXHJcbiAgICAgKiBQcmVyZXF1aXNpdGU6IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gUkVBRFkuXHJcbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbFxyXG4gICAgICovXHJcbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XHJcbiAgICAgICAgdHJhY2UoJ1BpY2sgc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArIHN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcclxuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgLyogUmVmIGJlZm9yZSByZW1vdmVDdXJyZW50UGljayBhbmQgcmVzZXRTdWJjaGFubmVsTGlzdCB0byBhdm9pZCB0aGVcclxuICAgICAgICAgKiByZWZjb3VudCBkcm9wcGluZyB0byAwIGR1cmluZyB0aGlzIHByb2Nlc3MuICovXHJcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XHJcbiAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHN1YmNoYW5uZWwuYWRkSGVhbHRoU3RhdGVXYXRjaGVyKHRoaXMucGlja2VkU3ViY2hhbm5lbEhlYWx0aExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gc3ViY2hhbm5lbDtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgLyogQWx3YXlzIHJlbW9ldiB0aGUgY29ubmVjdGl2aXR5IHN0YXRlIGxpc3RlbmVyLiBJZiB0aGUgc3ViY2hhbm5lbCBpc1xyXG4gICAgICAgICAgICAgICBnZXR0aW5nIHBpY2tlZCwgaXQgd2lsbCBiZSByZS1hZGRlZCB0aGVuLiAqL1xyXG4gICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIC8qIFJlZnMgYXJlIGNvdW50ZWQgaW5kZXBlbmRlbnRseSBmb3IgdGhlIGNoaWxkcmVuIGxpc3QgYW5kIHRoZVxyXG4gICAgICAgICAgICAgKiBjdXJyZW50UGljaywgc28gd2UgY2FsbCB1bnJlZiB3aGV0aGVyIG9yIG5vdCB0aGUgY2hpbGQgaXMgdGhlXHJcbiAgICAgICAgICAgICAqIGN1cnJlbnRQaWNrLiBDaGFubmVseiBjaGlsZCByZWZlcmVuY2VzIGFyZSBhbHNvIHJlZmNvdW50ZWQsIHNvXHJcbiAgICAgICAgICAgICAqIHJlbW92ZUNoYW5uZWx6Q2hpbGQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5LiAqL1xyXG4gICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnVucmVmKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZC5zdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgIH1cclxuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdHJhY2UoJ2Nvbm5lY3RUb0FkZHJlc3NMaXN0KFsnICsgYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKSArICddKScpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChhZGRyZXNzLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlOiBmYWxzZSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiBuZXdDaGlsZHJlbkxpc3QpIHtcclxuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyogUmVmIGVhY2ggc3ViY2hhbm5lbCBiZWZvcmUgcmVzZXR0aW5nIHRoZSBsaXN0LCB0byBlbnN1cmUgdGhhdFxyXG4gICAgICAgICAqIHN1YmNoYW5uZWxzIHNoYXJlZCBiZXR3ZWVuIHRoZSBsaXN0IGRvbid0IGRyb3AgdG8gMCByZWZzIGR1cmluZyB0aGVcclxuICAgICAgICAgKiB0cmFuc2l0aW9uLiAqL1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgbmV3Q2hpbGRyZW5MaXN0KSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW5MaXN0O1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PVxyXG4gICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygwKTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxiQ29uZmlnLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVwb3J0SGVhbHRoU3RhdHVzID0gb3B0aW9uc1tSRVBPUlRfSEVBTFRIX1NUQVRVU19PUFRJT05fTkFNRV07XHJcbiAgICAgICAgLyogUHJldmlvdXNseSwgYW4gdXBkYXRlIHdvdWxkIGJlIGRpc2NhcmRlZCBpZiBpdCB3YXMgaWRlbnRpY2FsIHRvIHRoZVxyXG4gICAgICAgICAqIHByZXZpb3VzIHVwZGF0ZSwgdG8gbWluaW1pemUgY2h1cm4uIE5vdyB0aGUgRE5TIHJlc29sdmVyIGlzXHJcbiAgICAgICAgICogcmF0ZS1saW1pdGVkLCBzbyB0aGF0IGlzIGxlc3Mgb2YgYSBjb25jZXJuLiAqL1xyXG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTaHVmZmxlQWRkcmVzc0xpc3QoKSkge1xyXG4gICAgICAgICAgICBlbmRwb2ludExpc3QgPSBzaHVmZmxlZChlbmRwb2ludExpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByYXdBZGRyZXNzTGlzdCA9IFtdLmNvbmNhdCguLi5lbmRwb2ludExpc3QubWFwKGVuZHBvaW50ID0+IGVuZHBvaW50LmFkZHJlc3NlcykpO1xyXG4gICAgICAgIHRyYWNlKCd1cGRhdGVBZGRyZXNzTGlzdChbJyArIHJhd0FkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkgKyAnXSknKTtcclxuICAgICAgICBpZiAocmF3QWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gJ05vIGFkZHJlc3NlcyByZXNvbHZlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NMaXN0ID0gaW50ZXJsZWF2ZUFkZHJlc3NGYW1pbGllcyhyYXdBZGRyZXNzTGlzdCk7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCA9IGFkZHJlc3NMaXN0O1xyXG4gICAgICAgIHRoaXMubGF0ZXN0T3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBleGl0SWRsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgJiZcclxuICAgICAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QsIHRoaXMubGF0ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xyXG4gICAgICAgICAqIGRvZXMgbm90aGluZyAqL1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gUGlja0ZpcnN0TG9hZEJhbGFuY2VyO1xyXG5jb25zdCBMRUFGX0NPTkZJRyA9IG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKGZhbHNlKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgbGVhZiBsb2FkIGJhbGFuY2luZyBvcGVyYXRpb25zIGZvciBhIHNpbmdsZSBlbmRwb2ludC5cclxuICogSXQgaXMgYSB0aGluIHdyYXBwZXIgYXJvdW5kIGEgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHdpdGggYSBkaWZmZXJlbnQgQVBJXHJcbiAqIHRoYXQgbW9yZSBjbG9zZWx5IHJlZmxlY3RzIGhvdyBpdCB3aWxsIGJlIHVzZWQgYXMgYSBsZWFmIGJhbGFuY2VyLlxyXG4gKi9cclxuY2xhc3MgTGVhZkxvYWRCYWxhbmNlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgY2hhbm5lbENvbnRyb2xIZWxwZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmxhdGVzdFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcclxuICAgICAgICBjb25zdCBjaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xyXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTdGF0ZSA9IGNvbm5lY3Rpdml0eVN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RQaWNrZXIgPSBwaWNrZXI7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIgPSBuZXcgUGlja0ZpcnN0TG9hZEJhbGFuY2VyKGNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0UGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMucGlja0ZpcnN0QmFsYW5jZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xyXG4gICAgICAgIHRoaXMucGlja0ZpcnN0QmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoW3RoaXMuZW5kcG9pbnRdLCBMRUFGX0NPTkZJRywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IFtSRVBPUlRfSEVBTFRIX1NUQVRVU19PUFRJT05fTkFNRV06IHRydWUgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlYWZMb2FkQmFsYW5jZXIgdG8gYSBuZXdcclxuICAgICAqIGVuZHBvaW50LiBEb2VzIG5vdCB0cmlnZ2VyIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCBpZiBhIGNvbm5lY3Rpb25cclxuICAgICAqIGF0dGVtcHQgaXMgbm90IGFscmVhZHkgaW4gcHJvZ3Jlc3MuXHJcbiAgICAgKiBAcGFyYW0gbmV3RW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRW5kcG9pbnQobmV3RW5kcG9pbnQsIG5ld09wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBuZXdFbmRwb2ludDtcclxuICAgICAgICBpZiAodGhpcy5sYXRlc3RTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0UGlja2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFBpY2tlcjtcclxuICAgIH1cclxuICAgIGdldEVuZHBvaW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50O1xyXG4gICAgfVxyXG4gICAgZXhpdElkbGUoKSB7XHJcbiAgICAgICAgdGhpcy5waWNrRmlyc3RCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnBpY2tGaXJzdEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxlYWZMb2FkQmFsYW5jZXIgPSBMZWFmTG9hZEJhbGFuY2VyO1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFBpY2tGaXJzdExvYWRCYWxhbmNlciwgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyk7XHJcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RoundRobinLoadBalancer = void 0;\r\nexports.setup = setup;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst load_balancer_pick_first_1 = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\r\nconst TRACER_NAME = 'round_robin';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'round_robin';\r\nclass RoundRobinLoadBalancingConfig {\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    constructor() { }\r\n    toJsonObject() {\r\n        return {\r\n            [TYPE_NAME]: {},\r\n        };\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static createFromJson(obj) {\r\n        return new RoundRobinLoadBalancingConfig();\r\n    }\r\n}\r\nclass RoundRobinPicker {\r\n    constructor(children, nextIndex = 0) {\r\n        this.children = children;\r\n        this.nextIndex = nextIndex;\r\n    }\r\n    pick(pickArgs) {\r\n        const childPicker = this.children[this.nextIndex].picker;\r\n        this.nextIndex = (this.nextIndex + 1) % this.children.length;\r\n        return childPicker.pick(pickArgs);\r\n    }\r\n    /**\r\n     * Check what the next subchannel returned would be. Used by the load\r\n     * balancer implementation to preserve this part of the picker state if\r\n     * possible when a subchannel connects or disconnects.\r\n     */\r\n    peekNextEndpoint() {\r\n        return this.children[this.nextIndex].endpoint;\r\n    }\r\n}\r\nclass RoundRobinLoadBalancer {\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.children = [];\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.currentReadyPicker = null;\r\n        this.updatesPaused = false;\r\n        this.lastError = null;\r\n        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {\r\n            updateState: (connectivityState, picker, errorMessage) => {\r\n                /* Ensure that name resolution is requested again after active\r\n                 * connections are dropped. This is more aggressive than necessary to\r\n                 * accomplish that, so we are counting on resolvers to have\r\n                 * reasonable rate limits. */\r\n                if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {\r\n                    this.channelControlHelper.requestReresolution();\r\n                }\r\n                if (errorMessage) {\r\n                    this.lastError = errorMessage;\r\n                }\r\n                this.calculateAndUpdateState();\r\n            },\r\n        });\r\n    }\r\n    countChildrenWithState(state) {\r\n        return this.children.filter(child => child.getConnectivityState() === state)\r\n            .length;\r\n    }\r\n    calculateAndUpdateState() {\r\n        if (this.updatesPaused) {\r\n            return;\r\n        }\r\n        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\r\n            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\r\n            let index = 0;\r\n            if (this.currentReadyPicker !== null) {\r\n                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();\r\n                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));\r\n                if (index < 0) {\r\n                    index = 0;\r\n                }\r\n            }\r\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({\r\n                endpoint: child.getEndpoint(),\r\n                picker: child.getPicker(),\r\n            })), index), null);\r\n        }\r\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this), null);\r\n        }\r\n        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\r\n            const errorMessage = `round_robin: No connection established. Last error: ${this.lastError}`;\r\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({\r\n                details: errorMessage,\r\n            }), errorMessage);\r\n        }\r\n        else {\r\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\r\n        }\r\n        /* round_robin should keep all children connected, this is how we do that.\r\n         * We can't do this more efficiently in the individual child's updateState\r\n         * callback because that doesn't have a reference to which child the state\r\n         * change is associated with. */\r\n        for (const child of this.children) {\r\n            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\r\n                child.exitIdle();\r\n            }\r\n        }\r\n    }\r\n    updateState(newState, picker, errorMessage) {\r\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n            this.currentReadyPicker = picker;\r\n        }\r\n        else {\r\n            this.currentReadyPicker = null;\r\n        }\r\n        this.currentState = newState;\r\n        this.channelControlHelper.updateState(newState, picker, errorMessage);\r\n    }\r\n    resetSubchannelList() {\r\n        for (const child of this.children) {\r\n            child.destroy();\r\n        }\r\n    }\r\n    updateAddressList(endpointList, lbConfig, options) {\r\n        this.resetSubchannelList();\r\n        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));\r\n        this.updatesPaused = true;\r\n        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, options));\r\n        for (const child of this.children) {\r\n            child.startConnecting();\r\n        }\r\n        this.updatesPaused = false;\r\n        this.calculateAndUpdateState();\r\n    }\r\n    exitIdle() {\r\n        /* The round_robin LB policy is only in the IDLE state if it has no\r\n         * addresses to try to connect to and it has no picked subchannel.\r\n         * In that case, there is no meaningful action that can be taken here. */\r\n    }\r\n    resetBackoff() {\r\n        // This LB policy has no backoff to reset\r\n    }\r\n    destroy() {\r\n        this.resetSubchannelList();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\r\nfunction setup() {\r\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\r\n}\r\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixhQUFhO0FBQ2Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUNBQW1DLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGVBQWU7QUFDdkc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzPzY5MTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcclxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdF8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0XCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuY29uc3QgVFlQRV9OQU1FID0gJ3JvdW5kX3JvYmluJztcclxuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xyXG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuICAgIHRvSnNvbk9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIG5leHRJbmRleCA9IDApIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XHJcbiAgICB9XHJcbiAgICBwaWNrKHBpY2tBcmdzKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQaWNrZXIgPSB0aGlzLmNoaWxkcmVuW3RoaXMubmV4dEluZGV4XS5waWNrZXI7XHJcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSAodGhpcy5uZXh0SW5kZXggKyAxKSAlIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBjaGlsZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hhdCB0aGUgbmV4dCBzdWJjaGFubmVsIHJldHVybmVkIHdvdWxkIGJlLiBVc2VkIGJ5IHRoZSBsb2FkXHJcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxyXG4gICAgICogcG9zc2libGUgd2hlbiBhIHN1YmNoYW5uZWwgY29ubmVjdHMgb3IgZGlzY29ubmVjdHMuXHJcbiAgICAgKi9cclxuICAgIHBlZWtOZXh0RW5kcG9pbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5uZXh0SW5kZXhdLmVuZHBvaW50O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cGRhdGVzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcikoY2hhbm5lbENvbnRyb2xIZWxwZXIsIHtcclxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIEVuc3VyZSB0aGF0IG5hbWUgcmVzb2x1dGlvbiBpcyByZXF1ZXN0ZWQgYWdhaW4gYWZ0ZXIgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9ucyBhcmUgZHJvcHBlZC4gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBuZWNlc3NhcnkgdG9cclxuICAgICAgICAgICAgICAgICAqIGFjY29tcGxpc2ggdGhhdCwgc28gd2UgYXJlIGNvdW50aW5nIG9uIHJlc29sdmVycyB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAgKiByZWFzb25hYmxlIHJhdGUgbGltaXRzLiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSAmJiBjb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvdW50Q2hpbGRyZW5XaXRoU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gc3RhdGUpXHJcbiAgICAgICAgICAgIC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy51cGRhdGVzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnRDaGlsZHJlbldpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBpY2tlZEVuZHBvaW50ID0gdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIucGVla05leHRFbmRwb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZWFkeUNoaWxkcmVuLmZpbmRJbmRleChjaGlsZCA9PiAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuZW5kcG9pbnRFcXVhbCkoY2hpbGQuZ2V0RW5kcG9pbnQoKSwgbmV4dFBpY2tlZEVuZHBvaW50KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBSb3VuZFJvYmluUGlja2VyKHJlYWR5Q2hpbGRyZW4ubWFwKGNoaWxkID0+ICh7XHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogY2hpbGQuZ2V0RW5kcG9pbnQoKSxcclxuICAgICAgICAgICAgICAgIHBpY2tlcjogY2hpbGQuZ2V0UGlja2VyKCksXHJcbiAgICAgICAgICAgIH0pKSwgaW5kZXgpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudENoaWxkcmVuV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY291bnRDaGlsZHJlbldpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGByb3VuZF9yb2JpbjogTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoe1xyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JNZXNzYWdlLFxyXG4gICAgICAgICAgICB9KSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogcm91bmRfcm9iaW4gc2hvdWxkIGtlZXAgYWxsIGNoaWxkcmVuIGNvbm5lY3RlZCwgdGhpcyBpcyBob3cgd2UgZG8gdGhhdC5cclxuICAgICAgICAgKiBXZSBjYW4ndCBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHkgaW4gdGhlIGluZGl2aWR1YWwgY2hpbGQncyB1cGRhdGVTdGF0ZVxyXG4gICAgICAgICAqIGNhbGxiYWNrIGJlY2F1c2UgdGhhdCBkb2Vzbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gd2hpY2ggY2hpbGQgdGhlIHN0YXRlXHJcbiAgICAgICAgICogY2hhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmV4aXRJZGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xyXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBwaWNrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcclxuICAgICAgICB0cmFjZSgnQ29ubmVjdCB0byBlbmRwb2ludCBsaXN0ICcgKyBlbmRwb2ludExpc3QubWFwKHN1YmNoYW5uZWxfYWRkcmVzc18xLmVuZHBvaW50VG9TdHJpbmcpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBlbmRwb2ludExpc3QubWFwKGVuZHBvaW50ID0+IG5ldyBsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3RfMS5MZWFmTG9hZEJhbGFuY2VyKGVuZHBvaW50LCB0aGlzLmNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIsIG9wdGlvbnMpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIC8qIFRoZSByb3VuZF9yb2JpbiBMQiBwb2xpY3kgaXMgb25seSBpbiB0aGUgSURMRSBzdGF0ZSBpZiBpdCBoYXMgbm9cclxuICAgICAgICAgKiBhZGRyZXNzZXMgdG8gdHJ5IHRvIGNvbm5lY3QgdG8gYW5kIGl0IGhhcyBubyBwaWNrZWQgc3ViY2hhbm5lbC5cclxuICAgICAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZXJlIGlzIG5vIG1lYW5pbmdmdWwgYWN0aW9uIHRoYXQgY2FuIGJlIHRha2VuIGhlcmUuICovXHJcbiAgICB9XHJcbiAgICByZXNldEJhY2tvZmYoKSB7XHJcbiAgICAgICAgLy8gVGhpcyBMQiBwb2xpY3kgaGFzIG5vIGJhY2tvZmYgdG8gcmVzZXRcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXI7XHJcbmZ1bmN0aW9uIHNldHVwKCkge1xyXG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcm91bmQtcm9iaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\r\nexports.registerLoadBalancerType = registerLoadBalancerType;\r\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\r\nexports.createLoadBalancer = createLoadBalancer;\r\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\r\nexports.parseLoadBalancingConfig = parseLoadBalancingConfig;\r\nexports.getDefaultConfig = getDefaultConfig;\r\nexports.selectLbConfigFromList = selectLbConfigFromList;\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\n/**\r\n * Create a child ChannelControlHelper that overrides some methods of the\r\n * parent while letting others pass through to the parent unmodified. This\r\n * allows other code to create these children without needing to know about\r\n * all of the methods to be passed through.\r\n * @param parent\r\n * @param overrides\r\n */\r\nfunction createChildChannelControlHelper(parent, overrides) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n    return {\r\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\r\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\r\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\r\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\r\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),\r\n    };\r\n}\r\nconst registeredLoadBalancerTypes = {};\r\nlet defaultLoadBalancerType = null;\r\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\r\n    registeredLoadBalancerTypes[typeName] = {\r\n        LoadBalancer: loadBalancerType,\r\n        LoadBalancingConfig: loadBalancingConfigType,\r\n    };\r\n}\r\nfunction registerDefaultLoadBalancerType(typeName) {\r\n    defaultLoadBalancerType = typeName;\r\n}\r\nfunction createLoadBalancer(config, channelControlHelper) {\r\n    const typeName = config.getLoadBalancerName();\r\n    if (typeName in registeredLoadBalancerTypes) {\r\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction isLoadBalancerNameRegistered(typeName) {\r\n    return typeName in registeredLoadBalancerTypes;\r\n}\r\nfunction parseLoadBalancingConfig(rawConfig) {\r\n    const keys = Object.keys(rawConfig);\r\n    if (keys.length !== 1) {\r\n        throw new Error('Provided load balancing config has multiple conflicting entries');\r\n    }\r\n    const typeName = keys[0];\r\n    if (typeName in registeredLoadBalancerTypes) {\r\n        try {\r\n            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);\r\n        }\r\n        catch (e) {\r\n            throw new Error(`${typeName}: ${e.message}`);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\r\n    }\r\n}\r\nfunction getDefaultConfig() {\r\n    if (!defaultLoadBalancerType) {\r\n        throw new Error('No default load balancer type registered');\r\n    }\r\n    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\r\n}\r\nfunction selectLbConfigFromList(configs, fallbackTodefault = false) {\r\n    for (const config of configs) {\r\n        try {\r\n            return parseLoadBalancingConfig(config);\r\n        }\r\n        catch (e) {\r\n            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);\r\n            continue;\r\n        }\r\n    }\r\n    if (fallbackTodefault) {\r\n        if (defaultLoadBalancerType) {\r\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVDQUF1QztBQUN2QyxnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDLDBCQUEwQjtBQUMxQixvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxJQUFJLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcz82YjkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyO1xyXG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcclxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZTtcclxuZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBjcmVhdGVMb2FkQmFsYW5jZXI7XHJcbmV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7XHJcbmV4cG9ydHMucGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnID0gcGFyc2VMb2FkQmFsYW5jaW5nQ29uZmlnO1xyXG5leHBvcnRzLmdldERlZmF1bHRDb25maWcgPSBnZXREZWZhdWx0Q29uZmlnO1xyXG5leHBvcnRzLnNlbGVjdExiQ29uZmlnRnJvbUxpc3QgPSBzZWxlY3RMYkNvbmZpZ0Zyb21MaXN0O1xyXG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNoaWxkIENoYW5uZWxDb250cm9sSGVscGVyIHRoYXQgb3ZlcnJpZGVzIHNvbWUgbWV0aG9kcyBvZiB0aGVcclxuICogcGFyZW50IHdoaWxlIGxldHRpbmcgb3RoZXJzIHBhc3MgdGhyb3VnaCB0byB0aGUgcGFyZW50IHVubW9kaWZpZWQuIFRoaXNcclxuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XHJcbiAqIGFsbCBvZiB0aGUgbWV0aG9kcyB0byBiZSBwYXNzZWQgdGhyb3VnaC5cclxuICogQHBhcmFtIHBhcmVudFxyXG4gKiBAcGFyYW0gb3ZlcnJpZGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKHBhcmVudCwgb3ZlcnJpZGVzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChfYiA9IChfYSA9IG92ZXJyaWRlcy5jcmVhdGVTdWJjaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwYXJlbnQuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKHBhcmVudCksXHJcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcclxuICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoX2YgPSAoX2UgPSBvdmVycmlkZXMucmVxdWVzdFJlcmVzb2x1dGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcGFyZW50LnJlcXVlc3RSZXJlc29sdXRpb24uYmluZChwYXJlbnQpLFxyXG4gICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChfaCA9IChfZyA9IG92ZXJyaWRlcy5hZGRDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBwYXJlbnQuYWRkQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudCksXHJcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XHJcbmxldCBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IG51bGw7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSwgbG9hZEJhbGFuY2VyVHlwZSwgbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUpIHtcclxuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XHJcbiAgICAgICAgTG9hZEJhbGFuY2VyOiBsb2FkQmFsYW5jZXJUeXBlLFxyXG4gICAgICAgIExvYWRCYWxhbmNpbmdDb25maWc6IGxvYWRCYWxhbmNpbmdDb25maWdUeXBlLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lKSB7XHJcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUxvYWRCYWxhbmNlcihjb25maWcsIGNoYW5uZWxDb250cm9sSGVscGVyKSB7XHJcbiAgICBjb25zdCB0eXBlTmFtZSA9IGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XHJcbiAgICBpZiAodHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNlcihjaGFubmVsQ29udHJvbEhlbHBlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkKHR5cGVOYW1lKSB7XHJcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTG9hZEJhbGFuY2luZ0NvbmZpZyhyYXdDb25maWcpIHtcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyYXdDb25maWcpO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBsb2FkIGJhbGFuY2luZyBjb25maWcgaGFzIG11bHRpcGxlIGNvbmZsaWN0aW5nIGVudHJpZXMnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1swXTtcclxuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jaW5nQ29uZmlnLmNyZWF0ZUZyb21Kc29uKHJhd0NvbmZpZ1t0eXBlTmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZU5hbWV9OiAke2UubWVzc2FnZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBsb2FkIGJhbGFuY2luZyBjb25maWcgbmFtZSAke3R5cGVOYW1lfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRDb25maWcoKSB7XHJcbiAgICBpZiAoIWRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkZWZhdWx0IGxvYWQgYmFsYW5jZXIgdHlwZSByZWdpc3RlcmVkJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xyXG59XHJcbmZ1bmN0aW9uIHNlbGVjdExiQ29uZmlnRnJvbUxpc3QoY29uZmlncywgZmFsbGJhY2tUb2RlZmF1bHQgPSBmYWxzZSkge1xyXG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUxvYWRCYWxhbmNpbmdDb25maWcoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ0NvbmZpZyBwYXJzaW5nIGZhaWxlZCB3aXRoIGVycm9yJywgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGZhbGxiYWNrVG9kZWZhdWx0KSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW2RlZmF1bHRMb2FkQmFsYW5jZXJUeXBlXS5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LoadBalancingCall = void 0;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst TRACER_NAME = 'load_balancing_call';\r\nclass LoadBalancingCall {\r\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\r\n        var _a, _b;\r\n        this.channel = channel;\r\n        this.callConfig = callConfig;\r\n        this.methodName = methodName;\r\n        this.host = host;\r\n        this.credentials = credentials;\r\n        this.deadline = deadline;\r\n        this.callNumber = callNumber;\r\n        this.child = null;\r\n        this.readPending = false;\r\n        this.pendingMessage = null;\r\n        this.pendingHalfClose = false;\r\n        this.ended = false;\r\n        this.metadata = null;\r\n        this.listener = null;\r\n        this.onCallEnded = null;\r\n        this.childStartTime = null;\r\n        const splitPath = this.methodName.split('/');\r\n        let serviceName = '';\r\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\r\n         * by '/', the first item should be empty and the second should be the\r\n         * service name */\r\n        if (splitPath.length >= 2) {\r\n            serviceName = splitPath[1];\r\n        }\r\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\r\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\r\n         * can assume that the scheme is \"https\" */\r\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\r\n        this.startTime = new Date();\r\n    }\r\n    getDeadlineInfo() {\r\n        var _a, _b;\r\n        const deadlineInfo = [];\r\n        if (this.childStartTime) {\r\n            if (this.childStartTime > this.startTime) {\r\n                if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\r\n                    deadlineInfo.push('wait_for_ready');\r\n                }\r\n                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);\r\n            }\r\n            deadlineInfo.push(...this.child.getDeadlineInfo());\r\n            return deadlineInfo;\r\n        }\r\n        else {\r\n            if ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.getOptions().waitForReady) {\r\n                deadlineInfo.push('wait_for_ready');\r\n            }\r\n            deadlineInfo.push('Waiting for LB pick');\r\n        }\r\n        return deadlineInfo;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    outputStatus(status, progress) {\r\n        var _a, _b;\r\n        if (!this.ended) {\r\n            this.ended = true;\r\n            this.trace('ended with status: code=' +\r\n                status.code +\r\n                ' details=\"' +\r\n                status.details +\r\n                '\" start time=' +\r\n                this.startTime.toISOString());\r\n            const finalStatus = Object.assign(Object.assign({}, status), { progress });\r\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\r\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\r\n        }\r\n    }\r\n    doPick() {\r\n        var _a, _b;\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        if (!this.metadata) {\r\n            throw new Error('doPick called before start');\r\n        }\r\n        this.trace('Pick called');\r\n        const finalMetadata = this.metadata.clone();\r\n        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);\r\n        const subchannelString = pickResult.subchannel\r\n            ? '(' +\r\n                pickResult.subchannel.getChannelzRef().id +\r\n                ') ' +\r\n                pickResult.subchannel.getAddress()\r\n            : '' + pickResult.subchannel;\r\n        this.trace('Pick result: ' +\r\n            picker_1.PickResultType[pickResult.pickResultType] +\r\n            ' subchannel: ' +\r\n            subchannelString +\r\n            ' status: ' +\r\n            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\r\n            ' ' +\r\n            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\r\n        switch (pickResult.pickResultType) {\r\n            case picker_1.PickResultType.COMPLETE:\r\n                const combinedCallCredentials = this.credentials.compose(pickResult.subchannel.getCallCredentials());\r\n                combinedCallCredentials\r\n                    .generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl })\r\n                    .then(credsMetadata => {\r\n                    var _a;\r\n                    /* If this call was cancelled (e.g. by the deadline) before\r\n                     * metadata generation finished, we shouldn't do anything with\r\n                     * it. */\r\n                    if (this.ended) {\r\n                        this.trace('Credentials metadata generation finished after call ended');\r\n                        return;\r\n                    }\r\n                    finalMetadata.merge(credsMetadata);\r\n                    if (finalMetadata.get('authorization').length > 1) {\r\n                        this.outputStatus({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: '\"authorization\" metadata cannot have multiple values',\r\n                            metadata: new metadata_1.Metadata(),\r\n                        }, 'PROCESSED');\r\n                    }\r\n                    if (pickResult.subchannel.getConnectivityState() !==\r\n                        connectivity_state_1.ConnectivityState.READY) {\r\n                        this.trace('Picked subchannel ' +\r\n                            subchannelString +\r\n                            ' has state ' +\r\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +\r\n                            ' after getting credentials metadata. Retrying pick');\r\n                        this.doPick();\r\n                        return;\r\n                    }\r\n                    if (this.deadline !== Infinity) {\r\n                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\r\n                    }\r\n                    try {\r\n                        this.child = pickResult\r\n                            .subchannel.getRealSubchannel()\r\n                            .createCall(finalMetadata, this.host, this.methodName, {\r\n                            onReceiveMetadata: metadata => {\r\n                                this.trace('Received metadata');\r\n                                this.listener.onReceiveMetadata(metadata);\r\n                            },\r\n                            onReceiveMessage: message => {\r\n                                this.trace('Received message');\r\n                                this.listener.onReceiveMessage(message);\r\n                            },\r\n                            onReceiveStatus: status => {\r\n                                this.trace('Received status');\r\n                                if (status.rstCode ===\r\n                                    http2.constants.NGHTTP2_REFUSED_STREAM) {\r\n                                    this.outputStatus(status, 'REFUSED');\r\n                                }\r\n                                else {\r\n                                    this.outputStatus(status, 'PROCESSED');\r\n                                }\r\n                            },\r\n                        });\r\n                        this.childStartTime = new Date();\r\n                    }\r\n                    catch (error) {\r\n                        this.trace('Failed to start call on picked subchannel ' +\r\n                            subchannelString +\r\n                            ' with error ' +\r\n                            error.message);\r\n                        this.outputStatus({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: 'Failed to start HTTP/2 stream with error ' +\r\n                                error.message,\r\n                            metadata: new metadata_1.Metadata(),\r\n                        }, 'NOT_STARTED');\r\n                        return;\r\n                    }\r\n                    (_a = pickResult.onCallStarted) === null || _a === void 0 ? void 0 : _a.call(pickResult);\r\n                    this.onCallEnded = pickResult.onCallEnded;\r\n                    this.trace('Created child call [' + this.child.getCallNumber() + ']');\r\n                    if (this.readPending) {\r\n                        this.child.startRead();\r\n                    }\r\n                    if (this.pendingMessage) {\r\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\r\n                    }\r\n                    if (this.pendingHalfClose) {\r\n                        this.child.halfClose();\r\n                    }\r\n                }, (error) => {\r\n                    // We assume the error code isn't 0 (Status.OK)\r\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\r\n                    this.outputStatus({\r\n                        code: code,\r\n                        details: details,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    }, 'PROCESSED');\r\n                });\r\n                break;\r\n            case picker_1.PickResultType.DROP:\r\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\r\n                setImmediate(() => {\r\n                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');\r\n                });\r\n                break;\r\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\r\n                if (this.metadata.getOptions().waitForReady) {\r\n                    this.channel.queueCallForPick(this);\r\n                }\r\n                else {\r\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\r\n                    setImmediate(() => {\r\n                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');\r\n                    });\r\n                }\r\n                break;\r\n            case picker_1.PickResultType.QUEUE:\r\n                this.channel.queueCallForPick(this);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        var _a;\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\r\n        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.listener = listener;\r\n        this.metadata = metadata;\r\n        this.doPick();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        if (this.child) {\r\n            this.child.sendMessageWithContext(context, message);\r\n        }\r\n        else {\r\n            this.pendingMessage = { context, message };\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        if (this.child) {\r\n            this.child.startRead();\r\n        }\r\n        else {\r\n            this.readPending = true;\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        if (this.child) {\r\n            this.child.halfClose();\r\n        }\r\n        else {\r\n            this.pendingHalfClose = true;\r\n        }\r\n    }\r\n    setCredentials(credentials) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n}\r\nexports.LoadBalancingCall = LoadBalancingCall;\r\n//# sourceMappingURL=load-balancing-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9ELGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZLEVBQUUsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsR0FBRyxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBFQUEwRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDREQUE0RDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLGdCQUFnQiwwTEFBMEwsY0FBYztBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQSx3Q0FBd0MscURBQXFEO0FBQzdGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsNENBQTRDLHFEQUFxRDtBQUNqRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQXFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jaW5nLWNhbGwuanM/MDNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Mb2FkQmFsYW5jaW5nQ2FsbCA9IHZvaWQgMDtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XHJcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdsb2FkX2JhbGFuY2luZ19jYWxsJztcclxuY2xhc3MgTG9hZEJhbGFuY2luZ0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xyXG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XHJcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcclxuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmRlYWRsaW5lID0gZGVhZGxpbmU7XHJcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcclxuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25DYWxsRW5kZWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRTdGFydFRpbWUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IHRoaXMubWV0aG9kTmFtZS5zcGxpdCgnLycpO1xyXG4gICAgICAgIGxldCBzZXJ2aWNlTmFtZSA9ICcnO1xyXG4gICAgICAgIC8qIFRoZSBzdGFuZGFyZCBwYXRoIGZvcm1hdCBpcyBcIi97c2VydmljZU5hbWV9L3ttZXRob2ROYW1lfVwiLCBzbyBpZiB3ZSBzcGxpdFxyXG4gICAgICAgICAqIGJ5ICcvJywgdGhlIGZpcnN0IGl0ZW0gc2hvdWxkIGJlIGVtcHR5IGFuZCB0aGUgc2Vjb25kIHNob3VsZCBiZSB0aGVcclxuICAgICAgICAgKiBzZXJ2aWNlIG5hbWUgKi9cclxuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgIHNlcnZpY2VOYW1lID0gc3BsaXRQYXRoWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0bmFtZSA9IChfYiA9IChfYSA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGhpcy5ob3N0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdsb2NhbGhvc3QnO1xyXG4gICAgICAgIC8qIEN1cnJlbnRseSwgY2FsbCBjcmVkZW50aWFscyBhcmUgb25seSBhbGxvd2VkIG9uIEhUVFBTIGNvbm5lY3Rpb25zLCBzbyB3ZVxyXG4gICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xyXG4gICAgICAgIHRoaXMuc2VydmljZVVybCA9IGBodHRwczovLyR7aG9zdG5hbWV9LyR7c2VydmljZU5hbWV9YDtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICBnZXREZWFkbGluZUluZm8oKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBkZWFkbGluZUluZm8gPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSA+IHRoaXMuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnd2FpdF9mb3JfcmVhZHknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKGBMQiBwaWNrOiAkeygwLCBkZWFkbGluZV8xLmZvcm1hdERhdGVEaWZmZXJlbmNlKSh0aGlzLnN0YXJ0VGltZSwgdGhpcy5jaGlsZFN0YXJ0VGltZSl9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goLi4udGhpcy5jaGlsZC5nZXREZWFkbGluZUluZm8oKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWFkbGluZUluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKF9iID0gdGhpcy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0X2Zvcl9yZWFkeScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCdXYWl0aW5nIGZvciBMQiBwaWNrJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWFkbGluZUluZm87XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRTdGF0dXMoc3RhdHVzLCBwcm9ncmVzcykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5jb2RlICtcclxuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xyXG4gICAgICAgICAgICAgICAgJ1wiIHN0YXJ0IHRpbWU9JyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZS50b0lTT1N0cmluZygpKTtcclxuICAgICAgICAgICAgY29uc3QgZmluYWxTdGF0dXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXR1cyksIHsgcHJvZ3Jlc3MgfSk7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoZmluYWxTdGF0dXMpO1xyXG4gICAgICAgICAgICAoX2IgPSB0aGlzLm9uQ2FsbEVuZGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBmaW5hbFN0YXR1cy5jb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb1BpY2soKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvUGljayBjYWxsZWQgYmVmb3JlIHN0YXJ0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgY2FsbGVkJyk7XHJcbiAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCBwaWNrUmVzdWx0ID0gdGhpcy5jaGFubmVsLmRvUGljayhmaW5hbE1ldGFkYXRhLCB0aGlzLmNhbGxDb25maWcucGlja0luZm9ybWF0aW9uKTtcclxuICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RyaW5nID0gcGlja1Jlc3VsdC5zdWJjaGFubmVsXHJcbiAgICAgICAgICAgID8gJygnICtcclxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICtcclxuICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKVxyXG4gICAgICAgICAgICA6ICcnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgcmVzdWx0OiAnICtcclxuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xyXG4gICAgICAgICAgICAnIHN1YmNoYW5uZWw6ICcgK1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcclxuICAgICAgICAgICAgJyBzdGF0dXM6ICcgK1xyXG4gICAgICAgICAgICAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICgoX2IgPSBwaWNrUmVzdWx0LnN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldGFpbHMpKTtcclxuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURTpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscy5jb21wb3NlKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDYWxsQ3JlZGVudGlhbHMoKSk7XHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZENhbGxDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5nZW5lcmF0ZU1ldGFkYXRhKHsgbWV0aG9kX25hbWU6IHRoaXMubWV0aG9kTmFtZSwgc2VydmljZV91cmw6IHRoaXMuc2VydmljZVVybCB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNyZWRzTWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgd2FzIGNhbmNlbGxlZCAoZS5nLiBieSB0aGUgZGVhZGxpbmUpIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZyB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICogaXQuICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlZGVudGlhbHMgbWV0YWRhdGEgZ2VuZXJhdGlvbiBmaW5pc2hlZCBhZnRlciBjYWxsIGVuZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5tZXJnZShjcmVkc01ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxNZXRhZGF0YS5nZXQoJ2F1dGhvcml6YXRpb24nKS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdcImF1dGhvcml6YXRpb25cIiBtZXRhZGF0YSBjYW5ub3QgaGF2ZSBtdWx0aXBsZSB2YWx1ZXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQaWNrZWQgc3ViY2hhbm5lbCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBnZXR0aW5nIGNyZWRlbnRpYWxzIG1ldGFkYXRhLiBSZXRyeWluZyBwaWNrJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsTWV0YWRhdGEuc2V0KCdncnBjLXRpbWVvdXQnLCAoMCwgZGVhZGxpbmVfMS5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcpKHRoaXMuZGVhZGxpbmUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IHBpY2tSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJjaGFubmVsLmdldFJlYWxTdWJjaGFubmVsKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVDYWxsKGZpbmFsTWV0YWRhdGEsIHRoaXMuaG9zdCwgdGhpcy5tZXRob2ROYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5yc3RDb2RlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMsICdSRUZVU0VEJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMsICdQUk9DRVNTRUQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZFN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGYWlsZWQgdG8gc3RhcnQgY2FsbCBvbiBwaWNrZWQgc3ViY2hhbm5lbCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdGYWlsZWQgdG8gc3RhcnQgSFRUUC8yIHN0cmVhbSB3aXRoIGVycm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ05PVF9TVEFSVEVEJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gcGlja1Jlc3VsdC5vbkNhbGxTdGFydGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwaWNrUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gcGlja1Jlc3VsdC5vbkNhbGxFbmRlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIGNhbGwgWycgKyB0aGlzLmNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgZXJyb3IgY29kZSBpc24ndCAwIChTdGF0dXMuT0spXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyA/IGVycm9yLmNvZGUgOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTiwgYEdldHRpbmcgbWV0YWRhdGEgZnJvbSBwbHVnaW4gZmFpbGVkIHdpdGggZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuRFJPUDpcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShwaWNrUmVzdWx0LnN0YXR1cy5jb2RlLCBwaWNrUmVzdWx0LnN0YXR1cy5kZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogcGlja1Jlc3VsdC5zdGF0dXMubWV0YWRhdGEgfSwgJ0RST1AnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkU6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogcGlja1Jlc3VsdC5zdGF0dXMubWV0YWRhdGEgfSwgJ1BST0NFU1NFRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuUVVFVUU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzOiBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9LCAnUFJPQ0VTU0VEJyk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5kb1BpY2soKTtcclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRSZWFkKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxuICAgIH1cclxuICAgIGdldENhbGxOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gTG9hZEJhbGFuY2luZ0NhbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jaW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar _a, _b, _c, _d;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\r\nexports.trace = trace;\r\nexports.isTracerEnabled = isTracerEnabled;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst process_1 = __webpack_require__(/*! process */ \"process\");\r\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\r\nconst DEFAULT_LOGGER = {\r\n    error: (message, ...optionalParams) => {\r\n        console.error('E ' + message, ...optionalParams);\r\n    },\r\n    info: (message, ...optionalParams) => {\r\n        console.error('I ' + message, ...optionalParams);\r\n    },\r\n    debug: (message, ...optionalParams) => {\r\n        console.error('D ' + message, ...optionalParams);\r\n    },\r\n};\r\nlet _logger = DEFAULT_LOGGER;\r\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\r\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\r\nswitch (verbosityString.toUpperCase()) {\r\n    case 'DEBUG':\r\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\r\n        break;\r\n    case 'INFO':\r\n        _logVerbosity = constants_1.LogVerbosity.INFO;\r\n        break;\r\n    case 'ERROR':\r\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\r\n        break;\r\n    case 'NONE':\r\n        _logVerbosity = constants_1.LogVerbosity.NONE;\r\n        break;\r\n    default:\r\n    // Ignore any other values\r\n}\r\nconst getLogger = () => {\r\n    return _logger;\r\n};\r\nexports.getLogger = getLogger;\r\nconst setLogger = (logger) => {\r\n    _logger = logger;\r\n};\r\nexports.setLogger = setLogger;\r\nconst setLoggerVerbosity = (verbosity) => {\r\n    _logVerbosity = verbosity;\r\n};\r\nexports.setLoggerVerbosity = setLoggerVerbosity;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst log = (severity, ...args) => {\r\n    let logFunction;\r\n    if (severity >= _logVerbosity) {\r\n        switch (severity) {\r\n            case constants_1.LogVerbosity.DEBUG:\r\n                logFunction = _logger.debug;\r\n                break;\r\n            case constants_1.LogVerbosity.INFO:\r\n                logFunction = _logger.info;\r\n                break;\r\n            case constants_1.LogVerbosity.ERROR:\r\n                logFunction = _logger.error;\r\n                break;\r\n        }\r\n        /* Fall back to _logger.error when other methods are not available for\r\n         * compatiblity with older behavior that always logged to _logger.error */\r\n        if (!logFunction) {\r\n            logFunction = _logger.error;\r\n        }\r\n        if (logFunction) {\r\n            logFunction.bind(_logger)(...args);\r\n        }\r\n    }\r\n};\r\nexports.log = log;\r\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\r\nconst enabledTracers = new Set();\r\nconst disabledTracers = new Set();\r\nfor (const tracerName of tracersString.split(',')) {\r\n    if (tracerName.startsWith('-')) {\r\n        disabledTracers.add(tracerName.substring(1));\r\n    }\r\n    else {\r\n        enabledTracers.add(tracerName);\r\n    }\r\n}\r\nconst allEnabled = enabledTracers.has('all');\r\nfunction trace(severity, tracer, text) {\r\n    if (isTracerEnabled(tracer)) {\r\n        (0, exports.log)(severity, new Date().toISOString() +\r\n            ' | v' +\r\n            clientVersion +\r\n            ' ' +\r\n            process_1.pid +\r\n            ' | ' +\r\n            tracer +\r\n            ' | ' +\r\n            text);\r\n    }\r\n}\r\nfunction isTracerEnabled(tracer) {\r\n    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));\r\n}\r\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUNoRixhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLHdCQUFTO0FBQ25DLHNCQUFzQiwwR0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzPzY2ZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG52YXIgX2EsIF9iLCBfYywgX2Q7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5sb2cgPSBleHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5nZXRMb2dnZXIgPSB2b2lkIDA7XHJcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcclxuZXhwb3J0cy5pc1RyYWNlckVuYWJsZWQgPSBpc1RyYWNlckVuYWJsZWQ7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBwcm9jZXNzXzEgPSByZXF1aXJlKFwicHJvY2Vzc1wiKTtcclxuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XHJcbmNvbnN0IERFRkFVTFRfTE9HR0VSID0ge1xyXG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0UgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcclxuICAgIH0sXHJcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XHJcbiAgICB9LFxyXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0QgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcclxuICAgIH0sXHJcbn07XHJcbmxldCBfbG9nZ2VyID0gREVGQVVMVF9MT0dHRVI7XHJcbmxldCBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xyXG5jb25zdCB2ZXJib3NpdHlTdHJpbmcgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5HUlBDX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XHJcbnN3aXRjaCAodmVyYm9zaXR5U3RyaW5nLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgIGNhc2UgJ0RFQlVHJzpcclxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnSU5GTyc6XHJcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnRVJST1InOlxyXG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdOT05FJzpcclxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5Lk5PTkU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgLy8gSWdub3JlIGFueSBvdGhlciB2YWx1ZXNcclxufVxyXG5jb25zdCBnZXRMb2dnZXIgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gX2xvZ2dlcjtcclxufTtcclxuZXhwb3J0cy5nZXRMb2dnZXIgPSBnZXRMb2dnZXI7XHJcbmNvbnN0IHNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcclxuICAgIF9sb2dnZXIgPSBsb2dnZXI7XHJcbn07XHJcbmV4cG9ydHMuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xyXG5jb25zdCBzZXRMb2dnZXJWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XHJcbiAgICBfbG9nVmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xyXG59O1xyXG5leHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IHNldExvZ2dlclZlcmJvc2l0eTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgbG9nID0gKHNldmVyaXR5LCAuLi5hcmdzKSA9PiB7XHJcbiAgICBsZXQgbG9nRnVuY3Rpb247XHJcbiAgICBpZiAoc2V2ZXJpdHkgPj0gX2xvZ1ZlcmJvc2l0eSkge1xyXG4gICAgICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcclxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc6XHJcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZGVidWc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTzpcclxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5pbmZvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIEZhbGwgYmFjayB0byBfbG9nZ2VyLmVycm9yIHdoZW4gb3RoZXIgbWV0aG9kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3JcclxuICAgICAgICAgKiBjb21wYXRpYmxpdHkgd2l0aCBvbGRlciBiZWhhdmlvciB0aGF0IGFsd2F5cyBsb2dnZWQgdG8gX2xvZ2dlci5lcnJvciAqL1xyXG4gICAgICAgIGlmICghbG9nRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgbG9nRnVuY3Rpb24uYmluZChfbG9nZ2VyKSguLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMubG9nID0gbG9nO1xyXG5jb25zdCB0cmFjZXJzU3RyaW5nID0gKF9kID0gKF9jID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1RSQUNFKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBwcm9jZXNzLmVudi5HUlBDX1RSQUNFKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJztcclxuY29uc3QgZW5hYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IGRpc2FibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcclxuZm9yIChjb25zdCB0cmFjZXJOYW1lIG9mIHRyYWNlcnNTdHJpbmcuc3BsaXQoJywnKSkge1xyXG4gICAgaWYgKHRyYWNlck5hbWUuc3RhcnRzV2l0aCgnLScpKSB7XHJcbiAgICAgICAgZGlzYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lLnN1YnN0cmluZygxKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbmFibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgYWxsRW5hYmxlZCA9IGVuYWJsZWRUcmFjZXJzLmhhcygnYWxsJyk7XHJcbmZ1bmN0aW9uIHRyYWNlKHNldmVyaXR5LCB0cmFjZXIsIHRleHQpIHtcclxuICAgIGlmIChpc1RyYWNlckVuYWJsZWQodHJhY2VyKSkge1xyXG4gICAgICAgICgwLCBleHBvcnRzLmxvZykoc2V2ZXJpdHksIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgfCB2JyArXHJcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb24gK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICBwcm9jZXNzXzEucGlkICtcclxuICAgICAgICAgICAgJyB8ICcgK1xyXG4gICAgICAgICAgICB0cmFjZXIgK1xyXG4gICAgICAgICAgICAnIHwgJyArXHJcbiAgICAgICAgICAgIHRleHQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcclxuICAgIHJldHVybiAoIWRpc2FibGVkVHJhY2Vycy5oYXModHJhY2VyKSAmJiAoYWxsRW5hYmxlZCB8fCBlbmFibGVkVHJhY2Vycy5oYXModHJhY2VyKSkpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.makeClientConstructor = makeClientConstructor;\r\nexports.loadPackageDefinition = loadPackageDefinition;\r\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\r\n/**\r\n * Map with short names for each of the requester maker functions. Used in\r\n * makeClientConstructor\r\n * @private\r\n */\r\nconst requesterFuncs = {\r\n    unary: client_1.Client.prototype.makeUnaryRequest,\r\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\r\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\r\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\r\n};\r\n/**\r\n * Returns true, if given key is included in the blacklisted\r\n * keys.\r\n * @param key key for check, string.\r\n */\r\nfunction isPrototypePolluted(key) {\r\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\r\n}\r\n/**\r\n * Creates a constructor for a client with the given methods, as specified in\r\n * the methods argument. The resulting class will have an instance method for\r\n * each method in the service, which is a partial application of one of the\r\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\r\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\r\n * arguments predefined.\r\n * @param methods An object mapping method names to\r\n *     method attributes\r\n * @param serviceName The fully qualified name of the service\r\n * @param classOptions An options object.\r\n * @return New client constructor, which is a subclass of\r\n *     {@link grpc.Client}, and has the same arguments as that constructor.\r\n */\r\nfunction makeClientConstructor(methods, serviceName, classOptions) {\r\n    if (!classOptions) {\r\n        classOptions = {};\r\n    }\r\n    class ServiceClientImpl extends client_1.Client {\r\n    }\r\n    Object.keys(methods).forEach(name => {\r\n        if (isPrototypePolluted(name)) {\r\n            return;\r\n        }\r\n        const attrs = methods[name];\r\n        let methodType;\r\n        // TODO(murgatroid99): Verify that we don't need this anymore\r\n        if (typeof name === 'string' && name.charAt(0) === '$') {\r\n            throw new Error('Method names cannot start with $');\r\n        }\r\n        if (attrs.requestStream) {\r\n            if (attrs.responseStream) {\r\n                methodType = 'bidi';\r\n            }\r\n            else {\r\n                methodType = 'client_stream';\r\n            }\r\n        }\r\n        else {\r\n            if (attrs.responseStream) {\r\n                methodType = 'server_stream';\r\n            }\r\n            else {\r\n                methodType = 'unary';\r\n            }\r\n        }\r\n        const serialize = attrs.requestSerialize;\r\n        const deserialize = attrs.responseDeserialize;\r\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\r\n        ServiceClientImpl.prototype[name] = methodFunc;\r\n        // Associate all provided attributes with the method\r\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\r\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\r\n            ServiceClientImpl.prototype[attrs.originalName] =\r\n                ServiceClientImpl.prototype[name];\r\n        }\r\n    });\r\n    ServiceClientImpl.service = methods;\r\n    ServiceClientImpl.serviceName = serviceName;\r\n    return ServiceClientImpl;\r\n}\r\nfunction partial(fn, path, serialize, deserialize) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return function (...args) {\r\n        return fn.call(this, path, serialize, deserialize, ...args);\r\n    };\r\n}\r\nfunction isProtobufTypeDefinition(obj) {\r\n    return 'format' in obj;\r\n}\r\n/**\r\n * Load a gRPC package definition as a gRPC object hierarchy.\r\n * @param packageDef The package definition object.\r\n * @return The resulting gRPC object.\r\n */\r\nfunction loadPackageDefinition(packageDef) {\r\n    const result = {};\r\n    for (const serviceFqn in packageDef) {\r\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\r\n            const service = packageDef[serviceFqn];\r\n            const nameComponents = serviceFqn.split('.');\r\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\r\n                continue;\r\n            }\r\n            const serviceName = nameComponents[nameComponents.length - 1];\r\n            let current = result;\r\n            for (const packageName of nameComponents.slice(0, -1)) {\r\n                if (!current[packageName]) {\r\n                    current[packageName] = {};\r\n                }\r\n                current = current[packageName];\r\n            }\r\n            if (isProtobufTypeDefinition(service)) {\r\n                current[serviceName] = service;\r\n            }\r\n            else {\r\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanM/NTMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBtYWtlQ2xpZW50Q29uc3RydWN0b3I7XHJcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xyXG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcclxuLyoqXHJcbiAqIE1hcCB3aXRoIHNob3J0IG5hbWVzIGZvciBlYWNoIG9mIHRoZSByZXF1ZXN0ZXIgbWFrZXIgZnVuY3Rpb25zLiBVc2VkIGluXHJcbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XHJcbiAgICB1bmFyeTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlVW5hcnlSZXF1ZXN0LFxyXG4gICAgc2VydmVyX3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlU2VydmVyU3RyZWFtUmVxdWVzdCxcclxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXHJcbiAgICBiaWRpOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VCaWRpU3RyZWFtUmVxdWVzdCxcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSwgaWYgZ2l2ZW4ga2V5IGlzIGluY2x1ZGVkIGluIHRoZSBibGFja2xpc3RlZFxyXG4gKiBrZXlzLlxyXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoa2V5KSB7XHJcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cclxuICogdGhlIG1ldGhvZHMgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgY2xhc3Mgd2lsbCBoYXZlIGFuIGluc3RhbmNlIG1ldGhvZCBmb3JcclxuICogZWFjaCBtZXRob2QgaW4gdGhlIHNlcnZpY2UsIHdoaWNoIGlzIGEgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBvbmUgb2YgdGhlXHJcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcclxuICogYW5kIGByZXNwb25zZVNlcmlhbGl6ZWAsIHdpdGggdGhlIGBtZXRob2RgLCBgc2VyaWFsaXplYCwgYW5kIGBkZXNlcmlhbGl6ZWBcclxuICogYXJndW1lbnRzIHByZWRlZmluZWQuXHJcbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xyXG4gKiAgICAgbWV0aG9kIGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc2VydmljZVxyXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gKiBAcmV0dXJuIE5ldyBjbGllbnQgY29uc3RydWN0b3IsIHdoaWNoIGlzIGEgc3ViY2xhc3Mgb2ZcclxuICogICAgIHtAbGluayBncnBjLkNsaWVudH0sIGFuZCBoYXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoYXQgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlQ2xpZW50Q29uc3RydWN0b3IobWV0aG9kcywgc2VydmljZU5hbWUsIGNsYXNzT3B0aW9ucykge1xyXG4gICAgaWYgKCFjbGFzc09wdGlvbnMpIHtcclxuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIGV4dGVuZHMgY2xpZW50XzEuQ2xpZW50IHtcclxuICAgIH1cclxuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgaWYgKGlzUHJvdG90eXBlUG9sbHV0ZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRycyA9IG1ldGhvZHNbbmFtZV07XHJcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XHJcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBWZXJpZnkgdGhhdCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50X3N0cmVhbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XHJcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemUgPSBhdHRycy5yZXNwb25zZURlc2VyaWFsaXplO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZEZ1bmMgPSBwYXJ0aWFsKHJlcXVlc3RlckZ1bmNzW21ldGhvZFR5cGVdLCBhdHRycy5wYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKTtcclxuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xyXG4gICAgICAgIC8vIEFzc29jaWF0ZSBhbGwgcHJvdmlkZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBtZXRob2RcclxuICAgICAgICBPYmplY3QuYXNzaWduKFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSwgYXR0cnMpO1xyXG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xyXG4gICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbYXR0cnMub3JpZ2luYWxOYW1lXSA9XHJcbiAgICAgICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlID0gbWV0aG9kcztcclxuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICByZXR1cm4gU2VydmljZUNsaWVudEltcGw7XHJcbn1cclxuZnVuY3Rpb24gcGFydGlhbChmbiwgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIC4uLmFyZ3MpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3RvYnVmVHlwZURlZmluaXRpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gJ2Zvcm1hdCcgaW4gb2JqO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkIGEgZ1JQQyBwYWNrYWdlIGRlZmluaXRpb24gYXMgYSBnUlBDIG9iamVjdCBoaWVyYXJjaHkuXHJcbiAqIEBwYXJhbSBwYWNrYWdlRGVmIFRoZSBwYWNrYWdlIGRlZmluaXRpb24gb2JqZWN0LlxyXG4gKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgZ1JQQyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IHNlcnZpY2VGcW4gaW4gcGFja2FnZURlZikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZURlZiwgc2VydmljZUZxbikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHBhY2thZ2VEZWZbc2VydmljZUZxbl07XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVDb21wb25lbnRzID0gc2VydmljZUZxbi5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICBpZiAobmFtZUNvbXBvbmVudHMuc29tZSgoY29tcCkgPT4gaXNQcm90b3R5cGVQb2xsdXRlZChjb21wKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gbmFtZUNvbXBvbmVudHNbbmFtZUNvbXBvbmVudHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhY2thZ2VOYW1lIG9mIG5hbWVDb21wb25lbnRzLnNsaWNlKDAsIC0xKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhY2thZ2VOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGFja2FnZU5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYWNrYWdlTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUHJvdG9idWZUeXBlRGVmaW5pdGlvbihzZXJ2aWNlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBtYWtlQ2xpZW50Q29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Metadata = void 0;\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\r\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\r\nfunction isLegalKey(key) {\r\n    return LEGAL_KEY_REGEX.test(key);\r\n}\r\nfunction isLegalNonBinaryValue(value) {\r\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\r\n}\r\nfunction isBinaryKey(key) {\r\n    return key.endsWith('-bin');\r\n}\r\nfunction isCustomMetadata(key) {\r\n    return !key.startsWith('grpc-');\r\n}\r\nfunction normalizeKey(key) {\r\n    return key.toLowerCase();\r\n}\r\nfunction validate(key, value) {\r\n    if (!isLegalKey(key)) {\r\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\r\n    }\r\n    if (value !== null && value !== undefined) {\r\n        if (isBinaryKey(key)) {\r\n            if (!Buffer.isBuffer(value)) {\r\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\r\n            }\r\n        }\r\n        else {\r\n            if (Buffer.isBuffer(value)) {\r\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\r\n            }\r\n            if (!isLegalNonBinaryValue(value)) {\r\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\r\n */\r\nclass Metadata {\r\n    constructor(options = {}) {\r\n        this.internalRepr = new Map();\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Sets the given value for the given key by replacing any other values\r\n     * associated with that key. Normalizes the key.\r\n     * @param key The key to whose value should be set.\r\n     * @param value The value to set. Must be a buffer if and only\r\n     *   if the normalized key ends with '-bin'.\r\n     */\r\n    set(key, value) {\r\n        key = normalizeKey(key);\r\n        validate(key, value);\r\n        this.internalRepr.set(key, [value]);\r\n    }\r\n    /**\r\n     * Adds the given value for the given key by appending to a list of previous\r\n     * values associated with that key. Normalizes the key.\r\n     * @param key The key for which a new value should be appended.\r\n     * @param value The value to add. Must be a buffer if and only\r\n     *   if the normalized key ends with '-bin'.\r\n     */\r\n    add(key, value) {\r\n        key = normalizeKey(key);\r\n        validate(key, value);\r\n        const existingValue = this.internalRepr.get(key);\r\n        if (existingValue === undefined) {\r\n            this.internalRepr.set(key, [value]);\r\n        }\r\n        else {\r\n            existingValue.push(value);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the given key and any associated values. Normalizes the key.\r\n     * @param key The key whose values should be removed.\r\n     */\r\n    remove(key) {\r\n        key = normalizeKey(key);\r\n        // validate(key);\r\n        this.internalRepr.delete(key);\r\n    }\r\n    /**\r\n     * Gets a list of all values associated with the key. Normalizes the key.\r\n     * @param key The key whose value should be retrieved.\r\n     * @return A list of values associated with the given key.\r\n     */\r\n    get(key) {\r\n        key = normalizeKey(key);\r\n        // validate(key);\r\n        return this.internalRepr.get(key) || [];\r\n    }\r\n    /**\r\n     * Gets a plain object mapping each key to the first value associated with it.\r\n     * This reflects the most common way that people will want to see metadata.\r\n     * @return A key/value mapping of the metadata.\r\n     */\r\n    getMap() {\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            if (values.length > 0) {\r\n                const v = values[0];\r\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Clones the metadata object.\r\n     * @return The newly cloned object.\r\n     */\r\n    clone() {\r\n        const newMetadata = new Metadata(this.options);\r\n        const newInternalRepr = newMetadata.internalRepr;\r\n        for (const [key, value] of this.internalRepr) {\r\n            const clonedValue = value.map(v => {\r\n                if (Buffer.isBuffer(v)) {\r\n                    return Buffer.from(v);\r\n                }\r\n                else {\r\n                    return v;\r\n                }\r\n            });\r\n            newInternalRepr.set(key, clonedValue);\r\n        }\r\n        return newMetadata;\r\n    }\r\n    /**\r\n     * Merges all key-value pairs from a given Metadata object into this one.\r\n     * If both this object and the given object have values in the same key,\r\n     * values from the other Metadata object will be appended to this object's\r\n     * values.\r\n     * @param other A Metadata object.\r\n     */\r\n    merge(other) {\r\n        for (const [key, values] of other.internalRepr) {\r\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\r\n            this.internalRepr.set(key, mergedValue);\r\n        }\r\n    }\r\n    setOptions(options) {\r\n        this.options = options;\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n    /**\r\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\r\n     */\r\n    toHttp2Headers() {\r\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            // We assume that the user's interaction with this object is limited to\r\n            // through its public API (i.e. keys and values are already validated).\r\n            result[key] = values.map(bufToString);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * This modifies the behavior of JSON.stringify to show an object\r\n     * representation of the metadata map.\r\n     */\r\n    toJSON() {\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            result[key] = values;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\r\n     * object.\r\n     * @param headers An IncomingHttpHeaders object.\r\n     */\r\n    static fromHttp2Headers(headers) {\r\n        const result = new Metadata();\r\n        for (const key of Object.keys(headers)) {\r\n            // Reserved headers (beginning with `:`) are not valid keys.\r\n            if (key.charAt(0) === ':') {\r\n                continue;\r\n            }\r\n            const values = headers[key];\r\n            try {\r\n                if (isBinaryKey(key)) {\r\n                    if (Array.isArray(values)) {\r\n                        values.forEach(value => {\r\n                            result.add(key, Buffer.from(value, 'base64'));\r\n                        });\r\n                    }\r\n                    else if (values !== undefined) {\r\n                        if (isCustomMetadata(key)) {\r\n                            values.split(',').forEach(v => {\r\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\r\n                            });\r\n                        }\r\n                        else {\r\n                            result.add(key, Buffer.from(values, 'base64'));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (Array.isArray(values)) {\r\n                        values.forEach(value => {\r\n                            result.add(key, value);\r\n                        });\r\n                    }\r\n                    else if (values !== undefined) {\r\n                        result.add(key, values);\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\r\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.Metadata = Metadata;\r\nconst bufToString = (val) => {\r\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\r\n};\r\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxJQUFJLE9BQU8sSUFBSSxvQ0FBb0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ldGFkYXRhLmpzPzQwODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XHJcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XHJcbmNvbnN0IExFR0FMX0tFWV9SRUdFWCA9IC9eWzAtOWEtel8uLV0rJC87XHJcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xyXG5mdW5jdGlvbiBpc0xlZ2FsS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIExFR0FMX0tFWV9SRUdFWC50ZXN0KGtleSk7XHJcbn1cclxuZnVuY3Rpb24gaXNMZWdhbE5vbkJpbmFyeVZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWC50ZXN0KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBpc0JpbmFyeUtleShrZXkpIHtcclxuICAgIHJldHVybiBrZXkuZW5kc1dpdGgoJy1iaW4nKTtcclxufVxyXG5mdW5jdGlvbiBpc0N1c3RvbU1ldGFkYXRhKGtleSkge1xyXG4gICAgcmV0dXJuICFrZXkuc3RhcnRzV2l0aCgnZ3JwYy0nKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFpc0xlZ2FsS2V5KGtleSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5cyB0aGF0IGVuZCB3aXRoICctYmluJyBtdXN0IGhhdmUgQnVmZmVyIHZhbHVlc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBkb24ndCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIFN0cmluZyB2YWx1ZXNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIHN0cmluZyB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBjbGFzcyBmb3Igc3RvcmluZyBtZXRhZGF0YS4gS2V5cyBhcmUgbm9ybWFsaXplZCB0byBsb3dlcmNhc2UgQVNDSUkuXHJcbiAqL1xyXG5jbGFzcyBNZXRhZGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgICAgICB0aGlzLmludGVybmFsUmVwciA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gd2hvc2UgdmFsdWUgc2hvdWxkIGJlIHNldC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XHJcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXHJcbiAgICAgKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgZm9yIHdoaWNoIGEgbmV3IHZhbHVlIHNob3VsZCBiZSBhcHBlbmRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XHJcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxyXG4gICAgICovXHJcbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XHJcbiAgICAgICAgLy8gdmFsaWRhdGUoa2V5KTtcclxuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXHJcbiAgICAgKiBAcmV0dXJuIEEgbGlzdCBvZiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcclxuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHBsYWluIG9iamVjdCBtYXBwaW5nIGVhY2gga2V5IHRvIHRoZSBmaXJzdCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXQuXHJcbiAgICAgKiBUaGlzIHJlZmxlY3RzIHRoZSBtb3N0IGNvbW1vbiB3YXkgdGhhdCBwZW9wbGUgd2lsbCB3YW50IHRvIHNlZSBtZXRhZGF0YS5cclxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldE1hcCgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodikgPyBCdWZmZXIuZnJvbSh2KSA6IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmVzIHRoZSBtZXRhZGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBuZXdseSBjbG9uZWQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBuZXdNZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xyXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRWYWx1ZSA9IHZhbHVlLm1hcCh2ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5ld0ludGVybmFsUmVwci5zZXQoa2V5LCBjbG9uZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdNZXRhZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSBhIGdpdmVuIE1ldGFkYXRhIG9iamVjdCBpbnRvIHRoaXMgb25lLlxyXG4gICAgICogSWYgYm90aCB0aGlzIG9iamVjdCBhbmQgdGhlIGdpdmVuIG9iamVjdCBoYXZlIHZhbHVlcyBpbiB0aGUgc2FtZSBrZXksXHJcbiAgICAgKiB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgTWV0YWRhdGEgb2JqZWN0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBvYmplY3Qnc1xyXG4gICAgICogdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIG90aGVyIEEgTWV0YWRhdGEgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBtZXJnZShvdGhlcikge1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBvdGhlci5pbnRlcm5hbFJlcHIpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVmFsdWUgPSAodGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW10pLmNvbmNhdCh2YWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBtZXJnZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBPdXRnb2luZ0h0dHBIZWFkZXJzIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGh0dHAyIEFQSS5cclxuICAgICAqL1xyXG4gICAgdG9IdHRwMkhlYWRlcnMoKSB7XHJcbiAgICAgICAgLy8gTk9URTogTm9kZSA8OC45IGZvcm1hdHMgaHR0cDIgaGVhZGVycyBpbmNvcnJlY3RseS5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcclxuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIHVzZXIncyBpbnRlcmFjdGlvbiB3aXRoIHRoaXMgb2JqZWN0IGlzIGxpbWl0ZWQgdG9cclxuICAgICAgICAgICAgLy8gdGhyb3VnaCBpdHMgcHVibGljIEFQSSAoaS5lLiBrZXlzIGFuZCB2YWx1ZXMgYXJlIGFscmVhZHkgdmFsaWRhdGVkKS5cclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtb2RpZmllcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkgdG8gc2hvdyBhbiBvYmplY3RcclxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIGZpZWxkcyBpbiBhIGdpdmVuIEluY29taW5nSHR0cEhlYWRlcnNcclxuICAgICAqIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXJ2ZWQgaGVhZGVycyAoYmVnaW5uaW5nIHdpdGggYDpgKSBhcmUgbm90IHZhbGlkIGtleXMuXHJcbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21NZXRhZGF0YShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc3BsaXQoJywnKS5mb3JFYWNoKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2LnRyaW0oKSwgJ2Jhc2U2NCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIGFkZCBtZXRhZGF0YSBlbnRyeSAke2tleX06ICR7dmFsdWVzfS4gJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKX0uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvaXNzdWVzLzExNzNgO1xyXG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XHJcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsLnRvU3RyaW5nKCdiYXNlNjQnKSA6IHZhbDtcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nvar PickResultType;\r\n(function (PickResultType) {\r\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\r\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\r\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\r\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\r\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\r\n/**\r\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\r\n * state. Always responds to every pick request with an UNAVAILABLE status.\r\n */\r\nclass UnavailablePicker {\r\n    constructor(status) {\r\n        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);\r\n    }\r\n    pick(pickArgs) {\r\n        return {\r\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\r\n            subchannel: null,\r\n            status: this.status,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n}\r\nexports.UnavailablePicker = UnavailablePicker;\r\n/**\r\n * A standard picker representing a load balancer in the IDLE or CONNECTING\r\n * state. Always responds to every pick request with a QUEUE pick result\r\n * indicating that the pick should be tried again with the next `Picker`. Also\r\n * reports back to the load balancer that a connection should be established\r\n * once any pick is attempted.\r\n * If the childPicker is provided, delegate to it instead of returning the\r\n * hardcoded QUEUE pick result, but still calls exitIdle.\r\n */\r\nclass QueuePicker {\r\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\r\n    constructor(loadBalancer, childPicker) {\r\n        this.loadBalancer = loadBalancer;\r\n        this.childPicker = childPicker;\r\n        this.calledExitIdle = false;\r\n    }\r\n    pick(pickArgs) {\r\n        if (!this.calledExitIdle) {\r\n            process.nextTick(() => {\r\n                this.loadBalancer.exitIdle();\r\n            });\r\n            this.calledExitIdle = true;\r\n        }\r\n        if (this.childPicker) {\r\n            return this.childPicker.pick(pickArgs);\r\n        }\r\n        else {\r\n            return {\r\n                pickResultType: PickResultType.QUEUE,\r\n                subchannel: null,\r\n                status: null,\r\n                onCallStarted: null,\r\n                onCallEnded: null,\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.QueuePicker = QueuePicker;\r\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlIQUFpSDtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzPzg2NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxudmFyIFBpY2tSZXN1bHRUeXBlO1xyXG4oZnVuY3Rpb24gKFBpY2tSZXN1bHRUeXBlKSB7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gMl0gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xyXG59KShQaWNrUmVzdWx0VHlwZSB8fCAoZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IFBpY2tSZXN1bHRUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIFRSQU5TSUVOVF9GQUlMVVJFXHJcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYW4gVU5BVkFJTEFCTEUgc3RhdHVzLlxyXG4gKi9cclxuY2xhc3MgVW5hdmFpbGFibGVQaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBPYmplY3QuYXNzaWduKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCBkZXRhaWxzOiAnTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sIHN0YXR1cyk7XHJcbiAgICB9XHJcbiAgICBwaWNrKHBpY2tBcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFLFxyXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxyXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBVbmF2YWlsYWJsZVBpY2tlcjtcclxuLyoqXHJcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xyXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGEgUVVFVUUgcGljayByZXN1bHRcclxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXHJcbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcclxuICogb25jZSBhbnkgcGljayBpcyBhdHRlbXB0ZWQuXHJcbiAqIElmIHRoZSBjaGlsZFBpY2tlciBpcyBwcm92aWRlZCwgZGVsZWdhdGUgdG8gaXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlXHJcbiAqIGhhcmRjb2RlZCBRVUVVRSBwaWNrIHJlc3VsdCwgYnV0IHN0aWxsIGNhbGxzIGV4aXRJZGxlLlxyXG4gKi9cclxuY2xhc3MgUXVldWVQaWNrZXIge1xyXG4gICAgLy8gQ29uc3RydWN0ZWQgd2l0aCBhIGxvYWQgYmFsYW5jZXIuIENhbGxzIGV4aXRJZGxlIG9uIGl0IHRoZSBmaXJzdCB0aW1lIHBpY2sgaXMgY2FsbGVkXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkQmFsYW5jZXIsIGNoaWxkUGlja2VyKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkQmFsYW5jZXIgPSBsb2FkQmFsYW5jZXI7XHJcbiAgICAgICAgdGhpcy5jaGlsZFBpY2tlciA9IGNoaWxkUGlja2VyO1xyXG4gICAgICAgIHRoaXMuY2FsbGVkRXhpdElkbGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHBpY2socGlja0FyZ3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FsbGVkRXhpdElkbGUpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkUGlja2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkUGlja2VyLnBpY2socGlja0FyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcclxuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBRdWV1ZVBpY2tlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DEFAULT_PORT = void 0;\r\nexports.setup = setup;\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\r\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst environment_1 = __webpack_require__(/*! ./environment */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/environment.js\");\r\nconst TRACER_NAME = 'dns_resolver';\r\nfunction trace(text) {\r\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\n/**\r\n * The default TCP port to connect to if not explicitly specified in the target.\r\n */\r\nexports.DEFAULT_PORT = 443;\r\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\r\n/**\r\n * Resolver implementation that handles DNS names and IP addresses.\r\n */\r\nclass DnsResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        var _a, _b, _c;\r\n        this.target = target;\r\n        this.listener = listener;\r\n        this.pendingLookupPromise = null;\r\n        this.pendingTxtPromise = null;\r\n        this.latestLookupResult = null;\r\n        this.latestServiceConfig = null;\r\n        this.latestServiceConfigError = null;\r\n        this.continueResolving = false;\r\n        this.isNextResolutionTimerRunning = false;\r\n        this.isServiceConfigEnabled = true;\r\n        this.returnedIpResult = false;\r\n        this.alternativeResolver = new dns_1.promises.Resolver();\r\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\r\n        if (target.authority) {\r\n            this.alternativeResolver.setServers([target.authority]);\r\n        }\r\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\r\n        if (hostPort === null) {\r\n            this.ipResult = null;\r\n            this.dnsHostname = null;\r\n            this.port = null;\r\n        }\r\n        else {\r\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\r\n                this.ipResult = [\r\n                    {\r\n                        addresses: [\r\n                            {\r\n                                host: hostPort.host,\r\n                                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,\r\n                            },\r\n                        ],\r\n                    },\r\n                ];\r\n                this.dnsHostname = null;\r\n                this.port = null;\r\n            }\r\n            else {\r\n                this.ipResult = null;\r\n                this.dnsHostname = hostPort.host;\r\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\r\n            }\r\n        }\r\n        this.percentage = Math.random() * 100;\r\n        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\r\n            this.isServiceConfigEnabled = false;\r\n        }\r\n        this.defaultResolutionError = {\r\n            code: constants_1.Status.UNAVAILABLE,\r\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\r\n            metadata: new metadata_1.Metadata(),\r\n        };\r\n        const backoffOptions = {\r\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\r\n            if (this.continueResolving) {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }, backoffOptions);\r\n        this.backoff.unref();\r\n        this.minTimeBetweenResolutionsMs =\r\n            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\r\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\r\n        clearTimeout(this.nextResolutionTimer);\r\n    }\r\n    /**\r\n     * If the target is an IP address, just provide that address as a result.\r\n     * Otherwise, initiate A, AAAA, and TXT lookups\r\n     */\r\n    startResolution() {\r\n        if (this.ipResult !== null) {\r\n            if (!this.returnedIpResult) {\r\n                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\r\n                setImmediate(() => {\r\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\r\n                });\r\n                this.returnedIpResult = true;\r\n            }\r\n            this.backoff.stop();\r\n            this.backoff.reset();\r\n            this.stopNextResolutionTimer();\r\n            return;\r\n        }\r\n        if (this.dnsHostname === null) {\r\n            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\r\n            setImmediate(() => {\r\n                this.listener.onError({\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                });\r\n            });\r\n            this.stopNextResolutionTimer();\r\n        }\r\n        else {\r\n            if (this.pendingLookupPromise !== null) {\r\n                return;\r\n            }\r\n            trace('Looking up DNS hostname ' + this.dnsHostname);\r\n            /* We clear out latestLookupResult here to ensure that it contains the\r\n             * latest result since the last time we started resolving. That way, the\r\n             * TXT resolution handler can use it, but only if it finishes second. We\r\n             * don't clear out any previous service config results because it's\r\n             * better to use a service config that's slightly out of date than to\r\n             * revert to an effectively blank one. */\r\n            this.latestLookupResult = null;\r\n            const hostname = this.dnsHostname;\r\n            this.pendingLookupPromise = this.lookup(hostname);\r\n            this.pendingLookupPromise.then(addressList => {\r\n                if (this.pendingLookupPromise === null) {\r\n                    return;\r\n                }\r\n                this.pendingLookupPromise = null;\r\n                this.backoff.reset();\r\n                this.backoff.stop();\r\n                this.latestLookupResult = addressList.map(address => ({\r\n                    addresses: [address],\r\n                }));\r\n                const allAddressesString = '[' +\r\n                    addressList.map(addr => addr.host + ':' + addr.port).join(',') +\r\n                    ']';\r\n                trace('Resolved addresses for target ' +\r\n                    (0, uri_parser_1.uriToString)(this.target) +\r\n                    ': ' +\r\n                    allAddressesString);\r\n                if (this.latestLookupResult.length === 0) {\r\n                    this.listener.onError(this.defaultResolutionError);\r\n                    return;\r\n                }\r\n                /* If the TXT lookup has not yet finished, both of the last two\r\n                 * arguments will be null, which is the equivalent of getting an\r\n                 * empty TXT response. When the TXT lookup does finish, its handler\r\n                 * can update the service config by using the same address list */\r\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\r\n            }, err => {\r\n                if (this.pendingLookupPromise === null) {\r\n                    return;\r\n                }\r\n                trace('Resolution error for target ' +\r\n                    (0, uri_parser_1.uriToString)(this.target) +\r\n                    ': ' +\r\n                    err.message);\r\n                this.pendingLookupPromise = null;\r\n                this.stopNextResolutionTimer();\r\n                this.listener.onError(this.defaultResolutionError);\r\n            });\r\n            /* If there already is a still-pending TXT resolution, we can just use\r\n             * that result when it comes in */\r\n            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\r\n                /* We handle the TXT query promise differently than the others because\r\n                 * the name resolution attempt as a whole is a success even if the TXT\r\n                 * lookup fails */\r\n                this.pendingTxtPromise = this.resolveTxt(hostname);\r\n                this.pendingTxtPromise.then(txtRecord => {\r\n                    if (this.pendingTxtPromise === null) {\r\n                        return;\r\n                    }\r\n                    this.pendingTxtPromise = null;\r\n                    try {\r\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\r\n                    }\r\n                    catch (err) {\r\n                        this.latestServiceConfigError = {\r\n                            code: constants_1.Status.UNAVAILABLE,\r\n                            details: `Parsing service config failed with error ${err.message}`,\r\n                            metadata: new metadata_1.Metadata(),\r\n                        };\r\n                    }\r\n                    if (this.latestLookupResult !== null) {\r\n                        /* We rely here on the assumption that calling this function with\r\n                         * identical parameters will be essentialy idempotent, and calling\r\n                         * it with the same address list and a different service config\r\n                         * should result in a fast and seamless switchover. */\r\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\r\n                    }\r\n                }, err => {\r\n                    /* If TXT lookup fails we should do nothing, which means that we\r\n                     * continue to use the result of the most recent successful lookup,\r\n                     * or the default null config object if there has never been a\r\n                     * successful lookup. We do not set the latestServiceConfigError\r\n                     * here because that is specifically used for response validation\r\n                     * errors. We still need to handle this error so that it does not\r\n                     * bubble up as an unhandled promise rejection. */\r\n                });\r\n            }\r\n        }\r\n    }\r\n    async lookup(hostname) {\r\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\r\n            trace('Using alternative DNS resolver.');\r\n            const records = await Promise.allSettled([\r\n                this.alternativeResolver.resolve4(hostname),\r\n                this.alternativeResolver.resolve6(hostname),\r\n            ]);\r\n            if (records.every(result => result.status === 'rejected')) {\r\n                throw new Error(records[0].reason);\r\n            }\r\n            return records\r\n                .reduce((acc, result) => {\r\n                return result.status === 'fulfilled'\r\n                    ? [...acc, ...result.value]\r\n                    : acc;\r\n            }, [])\r\n                .map(addr => ({\r\n                host: addr,\r\n                port: +this.port,\r\n            }));\r\n        }\r\n        /* We lookup both address families here and then split them up later\r\n         * because when looking up a single family, dns.lookup outputs an error\r\n         * if the name exists but there are no records for that family, and that\r\n         * error is indistinguishable from other kinds of errors */\r\n        const addressList = await dns_1.promises.lookup(hostname, { all: true });\r\n        return addressList.map(addr => ({ host: addr.address, port: +this.port }));\r\n    }\r\n    async resolveTxt(hostname) {\r\n        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {\r\n            trace('Using alternative DNS resolver.');\r\n            return this.alternativeResolver.resolveTxt(hostname);\r\n        }\r\n        return dns_1.promises.resolveTxt(hostname);\r\n    }\r\n    startNextResolutionTimer() {\r\n        var _a, _b;\r\n        clearTimeout(this.nextResolutionTimer);\r\n        this.nextResolutionTimer = setTimeout(() => {\r\n            this.stopNextResolutionTimer();\r\n            if (this.continueResolving) {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }, this.minTimeBetweenResolutionsMs);\r\n        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        this.isNextResolutionTimerRunning = true;\r\n    }\r\n    stopNextResolutionTimer() {\r\n        clearTimeout(this.nextResolutionTimer);\r\n        this.isNextResolutionTimerRunning = false;\r\n    }\r\n    startResolutionWithBackoff() {\r\n        if (this.pendingLookupPromise === null) {\r\n            this.continueResolving = false;\r\n            this.backoff.runOnce();\r\n            this.startNextResolutionTimer();\r\n            this.startResolution();\r\n        }\r\n    }\r\n    updateResolution() {\r\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\r\n         * nextResolutionTimer or backoff timer is running, set the\r\n         * continueResolving flag to resolve when whichever of those timers\r\n         * fires. Otherwise, start resolving immediately. */\r\n        if (this.pendingLookupPromise === null) {\r\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\r\n                if (this.isNextResolutionTimerRunning) {\r\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\r\n                }\r\n                else {\r\n                    trace('resolution update delayed by backoff timer until ' +\r\n                        this.backoff.getEndTime().toISOString());\r\n                }\r\n                this.continueResolving = true;\r\n            }\r\n            else {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Reset the resolver to the same state it had when it was created. In-flight\r\n     * DNS requests cannot be cancelled, but they are discarded and their results\r\n     * will be ignored.\r\n     */\r\n    destroy() {\r\n        this.continueResolving = false;\r\n        this.backoff.reset();\r\n        this.backoff.stop();\r\n        this.stopNextResolutionTimer();\r\n        this.pendingLookupPromise = null;\r\n        this.pendingTxtPromise = null;\r\n        this.latestLookupResult = null;\r\n        this.latestServiceConfig = null;\r\n        this.latestServiceConfigError = null;\r\n        this.returnedIpResult = false;\r\n    }\r\n    /**\r\n     * Get the default authority for the given target. For IP targets, that is\r\n     * the IP address. For DNS targets, it is the hostname.\r\n     * @param target\r\n     */\r\n    static getDefaultAuthority(target) {\r\n        return target.path;\r\n    }\r\n}\r\n/**\r\n * Set up the DNS resolver class by registering it as the handler for the\r\n * \"dns:\" prefix and as the default resolver.\r\n */\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)('dns', DnsResolver);\r\n    (0, resolver_1.registerDefaultScheme)('dns');\r\n}\r\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixhQUFhO0FBQ2IsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDJDQUEyQztBQUN2RztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJO0FBQy9JLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsWUFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1kbnMuanM/ZDk2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ERUZBVUxUX1BPUlQgPSB2b2lkIDA7XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xyXG5jb25zdCBkbnNfMSA9IHJlcXVpcmUoXCJkbnNcIik7XHJcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xyXG5jb25zdCBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2Ruc19yZXNvbHZlcic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXHJcbiAqL1xyXG5leHBvcnRzLkRFRkFVTFRfUE9SVCA9IDQ0MztcclxuY29uc3QgREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TID0gMzAwMDA7XHJcbi8qKlxyXG4gKiBSZXNvbHZlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhbmRsZXMgRE5TIG5hbWVzIGFuZCBJUCBhZGRyZXNzZXMuXHJcbiAqL1xyXG5jbGFzcyBEbnNSZXNvbHZlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZVJlc29sdmVyID0gbmV3IGRuc18xLnByb21pc2VzLlJlc29sdmVyKCk7XHJcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xyXG4gICAgICAgIGlmICh0YXJnZXQuYXV0aG9yaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlci5zZXRTZXJ2ZXJzKFt0YXJnZXQuYXV0aG9yaXR5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XHJcbiAgICAgICAgaWYgKGhvc3RQb3J0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShob3N0UG9ydC5ob3N0KSB8fCAoMCwgbmV0XzEuaXNJUHY2KShob3N0UG9ydC5ob3N0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3RQb3J0Lmhvc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gaG9zdFBvcnQuaG9zdDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IChfYiA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV4cG9ydHMuREVGQVVMVF9QT1JUO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XHJcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbiddID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgZGV0YWlsczogYE5hbWUgcmVzb2x1dGlvbiBmYWlsZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KX1gLFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcclxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmYudW5yZWYoKTtcclxuICAgICAgICB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyA9XHJcbiAgICAgICAgICAgIChfYyA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRuc19taW5fdGltZV9iZXR3ZWVuX3Jlc29sdXRpb25zX21zJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUztcclxuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cclxuICAgICAqIE90aGVyd2lzZSwgaW5pdGlhdGUgQSwgQUFBQSwgYW5kIFRYVCBsb29rdXBzXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pcFJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmV0dXJuZWRJcFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JldHVybmluZyBJUCBhZGRyZXNzIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmlwUmVzdWx0LCBudWxsLCBudWxsLCBudWxsLCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kbnNIb3N0bmFtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xyXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSBETlMgYWRkcmVzcyAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNlKCdMb29raW5nIHVwIEROUyBob3N0bmFtZSAnICsgdGhpcy5kbnNIb3N0bmFtZSk7XHJcbiAgICAgICAgICAgIC8qIFdlIGNsZWFyIG91dCBsYXRlc3RMb29rdXBSZXN1bHQgaGVyZSB0byBlbnN1cmUgdGhhdCBpdCBjb250YWlucyB0aGVcclxuICAgICAgICAgICAgICogbGF0ZXN0IHJlc3VsdCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHN0YXJ0ZWQgcmVzb2x2aW5nLiBUaGF0IHdheSwgdGhlXHJcbiAgICAgICAgICAgICAqIFRYVCByZXNvbHV0aW9uIGhhbmRsZXIgY2FuIHVzZSBpdCwgYnV0IG9ubHkgaWYgaXQgZmluaXNoZXMgc2Vjb25kLiBXZVxyXG4gICAgICAgICAgICAgKiBkb24ndCBjbGVhciBvdXQgYW55IHByZXZpb3VzIHNlcnZpY2UgY29uZmlnIHJlc3VsdHMgYmVjYXVzZSBpdCdzXHJcbiAgICAgICAgICAgICAqIGJldHRlciB0byB1c2UgYSBzZXJ2aWNlIGNvbmZpZyB0aGF0J3Mgc2xpZ2h0bHkgb3V0IG9mIGRhdGUgdGhhbiB0b1xyXG4gICAgICAgICAgICAgKiByZXZlcnQgdG8gYW4gZWZmZWN0aXZlbHkgYmxhbmsgb25lLiAqL1xyXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gdGhpcy5kbnNIb3N0bmFtZTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IHRoaXMubG9va3VwKGhvc3RuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZS50aGVuKGFkZHJlc3NMaXN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbYWRkcmVzc10sXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBZGRyZXNzZXNTdHJpbmcgPSAnWycgK1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydCkuam9pbignLCcpICtcclxuICAgICAgICAgICAgICAgICAgICAnXSc7XHJcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVzb2x2ZWQgYWRkcmVzc2VzIGZvciB0YXJnZXQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcclxuICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBhbGxBZGRyZXNzZXNTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBUWFQgbG9va3VwIGhhcyBub3QgeWV0IGZpbmlzaGVkLCBib3RoIG9mIHRoZSBsYXN0IHR3b1xyXG4gICAgICAgICAgICAgICAgICogYXJndW1lbnRzIHdpbGwgYmUgbnVsbCwgd2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgZ2V0dGluZyBhblxyXG4gICAgICAgICAgICAgICAgICogZW1wdHkgVFhUIHJlc3BvbnNlLiBXaGVuIHRoZSBUWFQgbG9va3VwIGRvZXMgZmluaXNoLCBpdHMgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICogY2FuIHVwZGF0ZSB0aGUgc2VydmljZSBjb25maWcgYnkgdXNpbmcgdGhlIHNhbWUgYWRkcmVzcyBsaXN0ICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcclxuICAgICAgICAgICAgfSwgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdXRpb24gZXJyb3IgZm9yIHRhcmdldCAnICtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvKiBJZiB0aGVyZSBhbHJlYWR5IGlzIGEgc3RpbGwtcGVuZGluZyBUWFQgcmVzb2x1dGlvbiwgd2UgY2FuIGp1c3QgdXNlXHJcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCAmJiB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBXZSBoYW5kbGUgdGhlIFRYVCBxdWVyeSBwcm9taXNlIGRpZmZlcmVudGx5IHRoYW4gdGhlIG90aGVycyBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgbmFtZSByZXNvbHV0aW9uIGF0dGVtcHQgYXMgYSB3aG9sZSBpcyBhIHN1Y2Nlc3MgZXZlbiBpZiB0aGUgVFhUXHJcbiAgICAgICAgICAgICAgICAgKiBsb29rdXAgZmFpbHMgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSB0aGlzLnJlc29sdmVUeHQoaG9zdG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZS50aGVuKHR4dFJlY29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZykodHh0UmVjb3JkLCB0aGlzLnBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFBhcnNpbmcgc2VydmljZSBjb25maWcgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpZGVudGljYWwgcGFyYW1ldGVycyB3aWxsIGJlIGVzc2VudGlhbHkgaWRlbXBvdGVudCwgYW5kIGNhbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIFRYVCBsb29rdXAgZmFpbHMgd2Ugc2hvdWxkIGRvIG5vdGhpbmcsIHdoaWNoIG1lYW5zIHRoYXQgd2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBjb250aW51ZSB0byB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBsb29rdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcclxuICAgICAgICAgICAgICAgICAgICAgKiBzdWNjZXNzZnVsIGxvb2t1cC4gV2UgZG8gbm90IHNldCB0aGUgbGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICogaGVyZSBiZWNhdXNlIHRoYXQgaXMgc3BlY2lmaWNhbGx5IHVzZWQgZm9yIHJlc3BvbnNlIHZhbGlkYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1YmJsZSB1cCBhcyBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uICovXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGxvb2t1cChob3N0bmFtZSkge1xyXG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIpIHtcclxuICAgICAgICAgICAgdHJhY2UoJ1VzaW5nIGFsdGVybmF0aXZlIEROUyByZXNvbHZlci4nKTtcclxuICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlUmVzb2x2ZXIucmVzb2x2ZTQoaG9zdG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZVJlc29sdmVyLnJlc29sdmU2KGhvc3RuYW1lKSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIGlmIChyZWNvcmRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlY29yZHNbMF0ucmVhc29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVjb3Jkc1xyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gWy4uLmFjYywgLi4ucmVzdWx0LnZhbHVlXVxyXG4gICAgICAgICAgICAgICAgICAgIDogYWNjO1xyXG4gICAgICAgICAgICB9LCBbXSlcclxuICAgICAgICAgICAgICAgIC5tYXAoYWRkciA9PiAoe1xyXG4gICAgICAgICAgICAgICAgaG9zdDogYWRkcixcclxuICAgICAgICAgICAgICAgIHBvcnQ6ICt0aGlzLnBvcnQsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogV2UgbG9va3VwIGJvdGggYWRkcmVzcyBmYW1pbGllcyBoZXJlIGFuZCB0aGVuIHNwbGl0IHRoZW0gdXAgbGF0ZXJcclxuICAgICAgICAgKiBiZWNhdXNlIHdoZW4gbG9va2luZyB1cCBhIHNpbmdsZSBmYW1pbHksIGRucy5sb29rdXAgb3V0cHV0cyBhbiBlcnJvclxyXG4gICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxyXG4gICAgICAgICAqIGVycm9yIGlzIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gb3RoZXIga2luZHMgb2YgZXJyb3JzICovXHJcbiAgICAgICAgY29uc3QgYWRkcmVzc0xpc3QgPSBhd2FpdCBkbnNfMS5wcm9taXNlcy5sb29rdXAoaG9zdG5hbWUsIHsgYWxsOiB0cnVlIH0pO1xyXG4gICAgICAgIHJldHVybiBhZGRyZXNzTGlzdC5tYXAoYWRkciA9PiAoeyBob3N0OiBhZGRyLmFkZHJlc3MsIHBvcnQ6ICt0aGlzLnBvcnQgfSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVzb2x2ZVR4dChob3N0bmFtZSkge1xyXG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkdSUENfTk9ERV9VU0VfQUxURVJOQVRJVkVfUkVTT0xWRVIpIHtcclxuICAgICAgICAgICAgdHJhY2UoJ1VzaW5nIGFsdGVybmF0aXZlIEROUyByZXNvbHZlci4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmVSZXNvbHZlci5yZXNvbHZlVHh0KGhvc3RuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRuc18xLnByb21pc2VzLnJlc29sdmVUeHQoaG9zdG5hbWUpO1xyXG4gICAgfVxyXG4gICAgc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XHJcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xyXG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxyXG4gICAgICAgICAqIG5leHRSZXNvbHV0aW9uVGltZXIgb3IgYmFja29mZiB0aW1lciBpcyBydW5uaW5nLCBzZXQgdGhlXHJcbiAgICAgICAgICogY29udGludWVSZXNvbHZpbmcgZmxhZyB0byByZXNvbHZlIHdoZW4gd2hpY2hldmVyIG9mIHRob3NlIHRpbWVyc1xyXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIHx8IHRoaXMuYmFja29mZi5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IFwibWluIHRpbWUgYmV0d2VlbiByZXNvbHV0aW9uc1wiIHJhdGUgbGltaXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZi5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHJlc29sdmVyIHRvIHRoZSBzYW1lIHN0YXRlIGl0IGhhZCB3aGVuIGl0IHdhcyBjcmVhdGVkLiBJbi1mbGlnaHRcclxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXHJcbiAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IGF1dGhvcml0eSBmb3IgdGhlIGdpdmVuIHRhcmdldC4gRm9yIElQIHRhcmdldHMsIHRoYXQgaXNcclxuICAgICAqIHRoZSBJUCBhZGRyZXNzLiBGb3IgRE5TIHRhcmdldHMsIGl0IGlzIHRoZSBob3N0bmFtZS5cclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZXQgdXAgdGhlIEROUyByZXNvbHZlciBjbGFzcyBieSByZWdpc3RlcmluZyBpdCBhcyB0aGUgaGFuZGxlciBmb3IgdGhlXHJcbiAqIFwiZG5zOlwiIHByZWZpeCBhbmQgYXMgdGhlIGRlZmF1bHQgcmVzb2x2ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCdkbnMnLCBEbnNSZXNvbHZlcik7XHJcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1kbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = setup;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'ip_resolver';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst IPV4_SCHEME = 'ipv4';\r\nconst IPV6_SCHEME = 'ipv6';\r\n/**\r\n * The default TCP port to connect to if not explicitly specified in the target.\r\n */\r\nconst DEFAULT_PORT = 443;\r\nclass IpResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        var _a;\r\n        this.listener = listener;\r\n        this.endpoints = [];\r\n        this.error = null;\r\n        this.hasReturnedResult = false;\r\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\r\n        const addresses = [];\r\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\r\n            this.error = {\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\r\n                metadata: new metadata_1.Metadata(),\r\n            };\r\n            return;\r\n        }\r\n        const pathList = target.path.split(',');\r\n        for (const path of pathList) {\r\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\r\n            if (hostPort === null) {\r\n                this.error = {\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse ${target.scheme} address ${path}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                };\r\n                return;\r\n            }\r\n            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||\r\n                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {\r\n                this.error = {\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse ${target.scheme} address ${path}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                };\r\n                return;\r\n            }\r\n            addresses.push({\r\n                host: hostPort.host,\r\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\r\n            });\r\n        }\r\n        this.endpoints = addresses.map(address => ({ addresses: [address] }));\r\n        trace('Parsed ' + target.scheme + ' address list ' + addresses);\r\n    }\r\n    updateResolution() {\r\n        if (!this.hasReturnedResult) {\r\n            this.hasReturnedResult = true;\r\n            process.nextTick(() => {\r\n                if (this.error) {\r\n                    this.listener.onError(this.error);\r\n                }\r\n                else {\r\n                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});\r\n                }\r\n            });\r\n        }\r\n    }\r\n    destroy() {\r\n        this.hasReturnedResult = false;\r\n    }\r\n    static getDefaultAuthority(target) {\r\n        return target.path.split(',')[0];\r\n    }\r\n}\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\r\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\r\n}\r\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsVUFBVSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxVQUFVLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanM/NzdiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2lwX3Jlc29sdmVyJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcclxuY29uc3QgSVBWNl9TQ0hFTUUgPSAnaXB2Nic7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xyXG5jbGFzcyBJcFJlc29sdmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhdGhMaXN0ID0gdGFyZ2V0LnBhdGguc3BsaXQoJywnKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHRhcmdldC5zY2hlbWUgPT09IElQVjRfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY0KShob3N0UG9ydC5ob3N0KSkgfHxcclxuICAgICAgICAgICAgICAgICh0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlICR7dGFyZ2V0LnNjaGVtZX0gYWRkcmVzcyAke3BhdGh9YCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaG9zdDogaG9zdFBvcnQuaG9zdCxcclxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW5kcG9pbnRzID0gYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+ICh7IGFkZHJlc3NlczogW2FkZHJlc3NdIH0pKTtcclxuICAgICAgICB0cmFjZSgnUGFyc2VkICcgKyB0YXJnZXQuc2NoZW1lICsgJyBhZGRyZXNzIGxpc3QgJyArIGFkZHJlc3Nlcyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmVuZHBvaW50cywgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aC5zcGxpdCgnLCcpWzBdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldHVwKCkge1xyXG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoSVBWNF9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xyXG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoSVBWNl9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWlwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = setup;\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nclass UdsResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        this.listener = listener;\r\n        this.hasReturnedResult = false;\r\n        this.endpoints = [];\r\n        let path;\r\n        if (target.authority === '') {\r\n            path = '/' + target.path;\r\n        }\r\n        else {\r\n            path = target.path;\r\n        }\r\n        this.endpoints = [{ addresses: [{ path }] }];\r\n    }\r\n    updateResolution() {\r\n        if (!this.hasReturnedResult) {\r\n            this.hasReturnedResult = true;\r\n            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});\r\n        }\r\n    }\r\n    destroy() {\r\n        this.hasReturnedResult = false;\r\n    }\r\n    static getDefaultAuthority(target) {\r\n        return 'localhost';\r\n    }\r\n}\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)('unix', UdsResolver);\r\n}\r\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYyxNQUFNLEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzPzZjNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xyXG5jbGFzcyBVZHNSZXNvbHZlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcclxuICAgICAgICBsZXQgcGF0aDtcclxuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcclxuICAgICAgICAgICAgcGF0aCA9ICcvJyArIHRhcmdldC5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0aCA9IHRhcmdldC5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IFt7IGFkZHJlc3NlczogW3sgcGF0aCB9XSB9XTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5lbmRwb2ludHMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiAnbG9jYWxob3N0JztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCd1bml4JywgVWRzUmVzb2x2ZXIpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLXVkcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.registerResolver = registerResolver;\r\nexports.registerDefaultScheme = registerDefaultScheme;\r\nexports.createResolver = createResolver;\r\nexports.getDefaultAuthority = getDefaultAuthority;\r\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst registeredResolvers = {};\r\nlet defaultScheme = null;\r\n/**\r\n * Register a resolver class to handle target names prefixed with the `prefix`\r\n * string. This prefix should correspond to a URI scheme name listed in the\r\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\r\n * @param prefix\r\n * @param resolverClass\r\n */\r\nfunction registerResolver(scheme, resolverClass) {\r\n    registeredResolvers[scheme] = resolverClass;\r\n}\r\n/**\r\n * Register a default resolver to handle target names that do not start with\r\n * any registered prefix.\r\n * @param resolverClass\r\n */\r\nfunction registerDefaultScheme(scheme) {\r\n    defaultScheme = scheme;\r\n}\r\n/**\r\n * Create a name resolver for the specified target, if possible. Throws an\r\n * error if no such name resolver can be created.\r\n * @param target\r\n * @param listener\r\n */\r\nfunction createResolver(target, listener, options) {\r\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\r\n        return new registeredResolvers[target.scheme](target, listener, options);\r\n    }\r\n    else {\r\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\r\n    }\r\n}\r\n/**\r\n * Get the default authority for the specified target, if possible. Throws an\r\n * error if no registered name resolver can parse that target string.\r\n * @param target\r\n */\r\nfunction getDefaultAuthority(target) {\r\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\r\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\r\n    }\r\n    else {\r\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\r\n    }\r\n}\r\nfunction mapUriDefaultScheme(target) {\r\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\r\n        if (defaultScheme !== null) {\r\n            return {\r\n                scheme: defaultScheme,\r\n                authority: undefined,\r\n                path: (0, uri_parser_1.uriToString)(target),\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    return target;\r\n}\r\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0NBQXNDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci5qcz9kNjlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSByZWdpc3RlclJlc29sdmVyO1xyXG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IHJlZ2lzdGVyRGVmYXVsdFNjaGVtZTtcclxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xyXG5leHBvcnRzLmdldERlZmF1bHRBdXRob3JpdHkgPSBnZXREZWZhdWx0QXV0aG9yaXR5O1xyXG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBtYXBVcmlEZWZhdWx0U2NoZW1lO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCByZWdpc3RlcmVkUmVzb2x2ZXJzID0ge307XHJcbmxldCBkZWZhdWx0U2NoZW1lID0gbnVsbDtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgcmVzb2x2ZXIgY2xhc3MgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyBwcmVmaXhlZCB3aXRoIHRoZSBgcHJlZml4YFxyXG4gKiBzdHJpbmcuIFRoaXMgcHJlZml4IHNob3VsZCBjb3JyZXNwb25kIHRvIGEgVVJJIHNjaGVtZSBuYW1lIGxpc3RlZCBpbiB0aGVcclxuICogW2dSUEMgTmFtZSBSZXNvbHV0aW9uIGRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9uYW1pbmcubWQpXHJcbiAqIEBwYXJhbSBwcmVmaXhcclxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzb2x2ZXIoc2NoZW1lLCByZXNvbHZlckNsYXNzKSB7XHJcbiAgICByZWdpc3RlcmVkUmVzb2x2ZXJzW3NjaGVtZV0gPSByZXNvbHZlckNsYXNzO1xyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIGRlZmF1bHQgcmVzb2x2ZXIgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoXHJcbiAqIGFueSByZWdpc3RlcmVkIHByZWZpeC5cclxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFNjaGVtZShzY2hlbWUpIHtcclxuICAgIGRlZmF1bHRTY2hlbWUgPSBzY2hlbWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5hbWUgcmVzb2x2ZXIgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXHJcbiAqIGVycm9yIGlmIG5vIHN1Y2ggbmFtZSByZXNvbHZlciBjYW4gYmUgY3JlYXRlZC5cclxuICogQHBhcmFtIHRhcmdldFxyXG4gKiBAcGFyYW0gbGlzdGVuZXJcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0YXJnZXQuc2NoZW1lICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvbHZlciBjb3VsZCBiZSBjcmVhdGVkIGZvciB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpfWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxyXG4gKiBlcnJvciBpZiBubyByZWdpc3RlcmVkIG5hbWUgcmVzb2x2ZXIgY2FuIHBhcnNlIHRoYXQgdGFyZ2V0IHN0cmluZy5cclxuICogQHBhcmFtIHRhcmdldFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQuc2NoZW1lICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFwVXJpRGVmYXVsdFNjaGVtZSh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQuc2NoZW1lID09PSB1bmRlZmluZWQgfHwgISh0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNjaGVtZTogZGVmYXVsdFNjaGVtZSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResolvingCall = void 0;\r\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst TRACER_NAME = 'resolving_call';\r\nclass ResolvingCall {\r\n    constructor(channel, method, options, filterStackFactory, callNumber) {\r\n        this.channel = channel;\r\n        this.method = method;\r\n        this.filterStackFactory = filterStackFactory;\r\n        this.callNumber = callNumber;\r\n        this.child = null;\r\n        this.readPending = false;\r\n        this.pendingMessage = null;\r\n        this.pendingHalfClose = false;\r\n        this.ended = false;\r\n        this.readFilterPending = false;\r\n        this.writeFilterPending = false;\r\n        this.pendingChildStatus = null;\r\n        this.metadata = null;\r\n        this.listener = null;\r\n        this.statusWatchers = [];\r\n        this.deadlineTimer = setTimeout(() => { }, 0);\r\n        this.filterStack = null;\r\n        this.deadlineStartTime = null;\r\n        this.configReceivedTime = null;\r\n        this.childStartTime = null;\r\n        /**\r\n         * Credentials configured for this specific call. Does not include\r\n         * call credentials associated with the channel credentials used to create\r\n         * the channel.\r\n         */\r\n        this.credentials = call_credentials_1.CallCredentials.createEmpty();\r\n        this.deadline = options.deadline;\r\n        this.host = options.host;\r\n        if (options.parentCall) {\r\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\r\n                options.parentCall.on('cancelled', () => {\r\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\r\n                });\r\n            }\r\n            if (options.flags & constants_1.Propagate.DEADLINE) {\r\n                this.trace('Propagating deadline from parent: ' +\r\n                    options.parentCall.getDeadline());\r\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\r\n            }\r\n        }\r\n        this.trace('Created');\r\n        this.runDeadlineTimer();\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    runDeadlineTimer() {\r\n        clearTimeout(this.deadlineTimer);\r\n        this.deadlineStartTime = new Date();\r\n        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\r\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\r\n        if (timeout !== Infinity) {\r\n            this.trace('Deadline will be reached in ' + timeout + 'ms');\r\n            const handleDeadline = () => {\r\n                if (!this.deadlineStartTime) {\r\n                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\r\n                    return;\r\n                }\r\n                const deadlineInfo = [];\r\n                const deadlineEndTime = new Date();\r\n                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);\r\n                if (this.configReceivedTime) {\r\n                    if (this.configReceivedTime > this.deadlineStartTime) {\r\n                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);\r\n                    }\r\n                    if (this.childStartTime) {\r\n                        if (this.childStartTime > this.configReceivedTime) {\r\n                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);\r\n                        }\r\n                    }\r\n                    else {\r\n                        deadlineInfo.push('waiting for metadata filters');\r\n                    }\r\n                }\r\n                else {\r\n                    deadlineInfo.push('waiting for name resolution');\r\n                }\r\n                if (this.child) {\r\n                    deadlineInfo.push(...this.child.getDeadlineInfo());\r\n                }\r\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));\r\n            };\r\n            if (timeout <= 0) {\r\n                process.nextTick(handleDeadline);\r\n            }\r\n            else {\r\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\r\n            }\r\n        }\r\n    }\r\n    outputStatus(status) {\r\n        if (!this.ended) {\r\n            this.ended = true;\r\n            if (!this.filterStack) {\r\n                this.filterStack = this.filterStackFactory.createFilter();\r\n            }\r\n            clearTimeout(this.deadlineTimer);\r\n            const filteredStatus = this.filterStack.receiveTrailers(status);\r\n            this.trace('ended with status: code=' +\r\n                filteredStatus.code +\r\n                ' details=\"' +\r\n                filteredStatus.details +\r\n                '\"');\r\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\r\n            process.nextTick(() => {\r\n                var _a;\r\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\r\n            });\r\n        }\r\n    }\r\n    sendMessageOnChild(context, message) {\r\n        if (!this.child) {\r\n            throw new Error('sendMessageonChild called with child not populated');\r\n        }\r\n        const child = this.child;\r\n        this.writeFilterPending = true;\r\n        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {\r\n            this.writeFilterPending = false;\r\n            child.sendMessageWithContext(context, filteredMessage.message);\r\n            if (this.pendingHalfClose) {\r\n                child.halfClose();\r\n            }\r\n        }, (status) => {\r\n            this.cancelWithStatus(status.code, status.details);\r\n        });\r\n    }\r\n    getConfig() {\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        if (!this.metadata || !this.listener) {\r\n            throw new Error('getConfig called before start');\r\n        }\r\n        const configResult = this.channel.getConfig(this.method, this.metadata);\r\n        if (configResult.type === 'NONE') {\r\n            this.channel.queueCallForConfig(this);\r\n            return;\r\n        }\r\n        else if (configResult.type === 'ERROR') {\r\n            if (this.metadata.getOptions().waitForReady) {\r\n                this.channel.queueCallForConfig(this);\r\n            }\r\n            else {\r\n                this.outputStatus(configResult.error);\r\n            }\r\n            return;\r\n        }\r\n        // configResult.type === 'SUCCESS'\r\n        this.configReceivedTime = new Date();\r\n        const config = configResult.config;\r\n        if (config.status !== constants_1.Status.OK) {\r\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\r\n            this.outputStatus({\r\n                code: code,\r\n                details: details,\r\n                metadata: new metadata_1.Metadata(),\r\n            });\r\n            return;\r\n        }\r\n        if (config.methodConfig.timeout) {\r\n            const configDeadline = new Date();\r\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\r\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +\r\n                config.methodConfig.timeout.nanos / 1000000);\r\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\r\n            this.runDeadlineTimer();\r\n        }\r\n        this.filterStackFactory.push(config.dynamicFilterFactories);\r\n        this.filterStack = this.filterStackFactory.createFilter();\r\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\r\n            this.child = this.channel.createRetryingCall(config, this.method, this.host, this.credentials, this.deadline);\r\n            this.trace('Created child [' + this.child.getCallNumber() + ']');\r\n            this.childStartTime = new Date();\r\n            this.child.start(filteredMetadata, {\r\n                onReceiveMetadata: metadata => {\r\n                    this.trace('Received metadata');\r\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\r\n                },\r\n                onReceiveMessage: message => {\r\n                    this.trace('Received message');\r\n                    this.readFilterPending = true;\r\n                    this.filterStack.receiveMessage(message).then(filteredMesssage => {\r\n                        this.trace('Finished filtering received message');\r\n                        this.readFilterPending = false;\r\n                        this.listener.onReceiveMessage(filteredMesssage);\r\n                        if (this.pendingChildStatus) {\r\n                            this.outputStatus(this.pendingChildStatus);\r\n                        }\r\n                    }, (status) => {\r\n                        this.cancelWithStatus(status.code, status.details);\r\n                    });\r\n                },\r\n                onReceiveStatus: status => {\r\n                    this.trace('Received status');\r\n                    if (this.readFilterPending) {\r\n                        this.pendingChildStatus = status;\r\n                    }\r\n                    else {\r\n                        this.outputStatus(status);\r\n                    }\r\n                },\r\n            });\r\n            if (this.readPending) {\r\n                this.child.startRead();\r\n            }\r\n            if (this.pendingMessage) {\r\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\r\n            }\r\n            else if (this.pendingHalfClose) {\r\n                this.child.halfClose();\r\n            }\r\n        }, (status) => {\r\n            this.outputStatus(status);\r\n        });\r\n    }\r\n    reportResolverError(status) {\r\n        var _a;\r\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\r\n            this.channel.queueCallForConfig(this);\r\n        }\r\n        else {\r\n            this.outputStatus(status);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        var _a;\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\r\n        this.outputStatus({\r\n            code: status,\r\n            details: details,\r\n            metadata: new metadata_1.Metadata(),\r\n        });\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.metadata = metadata.clone();\r\n        this.listener = listener;\r\n        this.getConfig();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        if (this.child) {\r\n            this.sendMessageOnChild(context, message);\r\n        }\r\n        else {\r\n            this.pendingMessage = { context, message };\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        if (this.child) {\r\n            this.child.startRead();\r\n        }\r\n        else {\r\n            this.readPending = true;\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        if (this.child && !this.writeFilterPending) {\r\n            this.child.halfClose();\r\n        }\r\n        else {\r\n            this.pendingHalfClose = true;\r\n        }\r\n    }\r\n    setCredentials(credentials) {\r\n        this.credentials = credentials;\r\n    }\r\n    addStatusWatcher(watcher) {\r\n        this.statusWatchers.push(watcher);\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n}\r\nexports.ResolvingCall = ResolvingCall;\r\n//# sourceMappingURL=resolving-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDhFQUE4RTtBQUMzSTtBQUNBO0FBQ0EsOERBQThELHNGQUFzRjtBQUNwSjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsbUZBQW1GO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdDQUF3QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanM/MDg5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gdm9pZCAwO1xyXG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Jlc29sdmluZ19jYWxsJztcclxuY2xhc3MgUmVzb2x2aW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBtZXRob2QsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY2FsbE51bWJlcikge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkgPSBmaWx0ZXJTdGFja0ZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcclxuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmVTdGFydFRpbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoaWxkU3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVkZW50aWFscyBjb25maWd1cmVkIGZvciB0aGlzIHNwZWNpZmljIGNhbGwuIERvZXMgbm90IGluY2x1ZGVcclxuICAgICAgICAgKiBjYWxsIGNyZWRlbnRpYWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhbm5lbCBjcmVkZW50aWFscyB1c2VkIHRvIGNyZWF0ZVxyXG4gICAgICAgICAqIHRoZSBjaGFubmVsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCk7XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IG9wdGlvbnMuZGVhZGxpbmU7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gb3B0aW9ucy5ob3N0O1xyXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmVudENhbGwpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuQ0FOQ0VMTEFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwub24oJ2NhbmNlbGxlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBieSBwYXJlbnQgY2FsbCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVBRExJTkUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1Byb3BhZ2F0aW5nIGRlYWRsaW5lIGZyb20gcGFyZW50OiAnICtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkJyk7XHJcbiAgICAgICAgdGhpcy5ydW5EZWFkbGluZVRpbWVyKCk7XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBydW5EZWFkbGluZVRpbWVyKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmVTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lOiAnICsgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykodGhpcy5kZWFkbGluZSkpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKHRoaXMuZGVhZGxpbmUpO1xyXG4gICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdEZWFkbGluZSB3aWxsIGJlIHJlYWNoZWQgaW4gJyArIHRpbWVvdXQgKyAnbXMnKTtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlRGVhZGxpbmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVhZGxpbmVTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVELCAnRGVhZGxpbmUgZXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWFkbGluZUluZm8gPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRW5kVGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgRGVhZGxpbmUgZXhjZWVkZWQgYWZ0ZXIgJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5kZWFkbGluZVN0YXJ0VGltZSwgZGVhZGxpbmVFbmRUaW1lKX1gKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1JlY2VpdmVkVGltZSA+IHRoaXMuZGVhZGxpbmVTdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goYG5hbWUgcmVzb2x1dGlvbjogJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5kZWFkbGluZVN0YXJ0VGltZSwgdGhpcy5jb25maWdSZWNlaXZlZFRpbWUpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZFN0YXJ0VGltZSA+IHRoaXMuY29uZmlnUmVjZWl2ZWRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgbWV0YWRhdGEgZmlsdGVyczogJHsoMCwgZGVhZGxpbmVfMS5mb3JtYXREYXRlRGlmZmVyZW5jZSkodGhpcy5jb25maWdSZWNlaXZlZFRpbWUsIHRoaXMuY2hpbGRTdGFydFRpbWUpfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaCgnd2FpdGluZyBmb3IgbWV0YWRhdGEgZmlsdGVycycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKCd3YWl0aW5nIGZvciBuYW1lIHJlc29sdXRpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmVJbmZvLnB1c2goLi4udGhpcy5jaGlsZC5nZXREZWFkbGluZUluZm8oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVELCBkZWFkbGluZUluZm8uam9pbignLCcpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhoYW5kbGVEZWFkbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZURlYWRsaW5lLCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJTdGFjaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YXR1cyA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZVRyYWlsZXJzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuY29kZSArXHJcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmRldGFpbHMgK1xyXG4gICAgICAgICAgICAgICAgJ1wiJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmlsdGVyZWRTdGF0dXMpKTtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2VPbkNoaWxkKGNvbnRleHQsIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW5kTWVzc2FnZW9uQ2hpbGQgY2FsbGVkIHdpdGggY2hpbGQgbm90IHBvcHVsYXRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGQ7XHJcbiAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1lc3NhZ2UoUHJvbWlzZS5yZXNvbHZlKHsgbWVzc2FnZTogbWVzc2FnZSwgZmxhZ3M6IGNvbnRleHQuZmxhZ3MgfSkpLnRoZW4oZmlsdGVyZWRNZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENvbmZpZygpIHtcclxuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSB8fCAhdGhpcy5saXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENvbmZpZyBjYWxsZWQgYmVmb3JlIHN0YXJ0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5nZXRDb25maWcodGhpcy5tZXRob2QsIHRoaXMubWV0YWRhdGEpO1xyXG4gICAgICAgIGlmIChjb25maWdSZXN1bHQudHlwZSA9PT0gJ05PTkUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdFUlJPUicpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKGNvbmZpZ1Jlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25maWdSZXN1bHQudHlwZSA9PT0gJ1NVQ0NFU1MnXHJcbiAgICAgICAgdGhpcy5jb25maWdSZWNlaXZlZFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1Jlc3VsdC5jb25maWc7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkoY29uZmlnLnN0YXR1cywgJ0ZhaWxlZCB0byByb3V0ZSBjYWxsIHRvIG1ldGhvZCAnICsgdGhpcy5tZXRob2QpO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0RlYWRsaW5lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgY29uZmlnRGVhZGxpbmUuc2V0U2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRTZWNvbmRzKCkgKyBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXHJcbiAgICAgICAgICAgICAgICBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQubmFub3MgLyAxMDAwMDAwKTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBjb25maWdEZWFkbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5wdXNoKGNvbmZpZy5keW5hbWljRmlsdGVyRmFjdG9yaWVzKTtcclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKHRoaXMubWV0YWRhdGEpKS50aGVuKGZpbHRlcmVkTWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZVJldHJ5aW5nQ2FsbChjb25maWcsIHRoaXMubWV0aG9kLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydChmaWx0ZXJlZE1ldGFkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpLnRoZW4oZmlsdGVyZWRNZXNzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZpbmlzaGVkIGZpbHRlcmluZyByZWNlaXZlZCBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKGZpbHRlcmVkTWVzc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXBvcnRSZXNvbHZlckVycm9yKHN0YXR1cykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XHJcbiAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcclxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YS5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLmdldENvbmZpZygpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKGNvbnRleHQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IHsgY29udGV4dCwgbWVzc2FnZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbGZDbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQgJiYgIXRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG4gICAgYWRkU3RhdHVzV2F0Y2hlcih3YXRjaGVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5wdXNoKHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IFJlc29sdmluZ0NhbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResolvingLoadBalancer = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nconst TRACER_NAME = 'resolving_load_balancer';\r\nfunction trace(text) {\r\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\n/**\r\n * Name match levels in order from most to least specific. This is the order in\r\n * which searches will be performed.\r\n */\r\nconst NAME_MATCH_LEVEL_ORDER = [\r\n    'SERVICE_AND_METHOD',\r\n    'SERVICE',\r\n    'EMPTY',\r\n];\r\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\r\n    for (const name of methodConfig.name) {\r\n        switch (matchLevel) {\r\n            case 'EMPTY':\r\n                if (!name.service && !name.method) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'SERVICE':\r\n                if (name.service === service && !name.method) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'SERVICE_AND_METHOD':\r\n                if (name.service === service && name.method === method) {\r\n                    return true;\r\n                }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\r\n    for (const config of methodConfigs) {\r\n        if (hasMatchingName(service, method, config, matchLevel)) {\r\n            return config;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getDefaultConfigSelector(serviceConfig) {\r\n    return {\r\n        invoke(methodName, metadata) {\r\n            var _a, _b;\r\n            const splitName = methodName.split('/').filter(x => x.length > 0);\r\n            const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\r\n            const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\r\n            if (serviceConfig && serviceConfig.methodConfig) {\r\n                /* Check for the following in order, and return the first method\r\n                * config that matches:\r\n                * 1. A name that exactly matches the service and method\r\n                * 2. A name with no method set that matches the service\r\n                * 3. An empty name\r\n                */\r\n                for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\r\n                    const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\r\n                    if (matchingConfig) {\r\n                        return {\r\n                            methodConfig: matchingConfig,\r\n                            pickInformation: {},\r\n                            status: constants_1.Status.OK,\r\n                            dynamicFilterFactories: [],\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                methodConfig: { name: [] },\r\n                pickInformation: {},\r\n                status: constants_1.Status.OK,\r\n                dynamicFilterFactories: [],\r\n            };\r\n        },\r\n        unref() { }\r\n    };\r\n}\r\nclass ResolvingLoadBalancer {\r\n    /**\r\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\r\n     * resolution internally.\r\n     * @param target The address of the backend to connect to.\r\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\r\n     *     this load balancer's owner.\r\n     * @param defaultServiceConfig The default service configuration to be used\r\n     *     if none is provided by the name resolver. A `null` value indicates\r\n     *     that the default behavior should be the default unconfigured behavior.\r\n     *     In practice, that means using the \"pick first\" load balancer\r\n     *     implmentation\r\n     */\r\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\r\n        this.target = target;\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.channelOptions = channelOptions;\r\n        this.onSuccessfulResolution = onSuccessfulResolution;\r\n        this.onFailedResolution = onFailedResolution;\r\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.latestChildPicker = new picker_1.QueuePicker(this);\r\n        this.latestChildErrorMessage = null;\r\n        /**\r\n         * This resolving load balancer's current connectivity state.\r\n         */\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The service config object from the last successful resolution, if\r\n         * available. A value of null indicates that we have not yet received a valid\r\n         * service config from the resolver.\r\n         */\r\n        this.previousServiceConfig = null;\r\n        /**\r\n         * Indicates whether we should attempt to resolve again after the backoff\r\n         * timer runs out.\r\n         */\r\n        this.continueResolving = false;\r\n        if (channelOptions['grpc.service_config']) {\r\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\r\n        }\r\n        else {\r\n            this.defaultServiceConfig = {\r\n                loadBalancingConfig: [],\r\n                methodConfig: [],\r\n            };\r\n        }\r\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this), null);\r\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\r\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\r\n            requestReresolution: () => {\r\n                /* If the backoffTimeout is running, we're still backing off from\r\n                 * making resolve requests, so we shouldn't make another one here.\r\n                 * In that case, the backoff timer callback will call\r\n                 * updateResolution */\r\n                if (this.backoffTimeout.isRunning()) {\r\n                    trace('requestReresolution delayed by backoff timer until ' +\r\n                        this.backoffTimeout.getEndTime().toISOString());\r\n                    this.continueResolving = true;\r\n                }\r\n                else {\r\n                    this.updateResolution();\r\n                }\r\n            },\r\n            updateState: (newState, picker, errorMessage) => {\r\n                this.latestChildState = newState;\r\n                this.latestChildPicker = picker;\r\n                this.latestChildErrorMessage = errorMessage;\r\n                this.updateState(newState, picker, errorMessage);\r\n            },\r\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\r\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),\r\n        });\r\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\r\n            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {\r\n                var _a;\r\n                this.backoffTimeout.stop();\r\n                this.backoffTimeout.reset();\r\n                let workingServiceConfig = null;\r\n                /* This first group of conditionals implements the algorithm described\r\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\r\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\r\n                 */\r\n                if (serviceConfig === null) {\r\n                    // Step 4 and 5\r\n                    if (serviceConfigError === null) {\r\n                        // Step 5\r\n                        this.previousServiceConfig = null;\r\n                        workingServiceConfig = this.defaultServiceConfig;\r\n                    }\r\n                    else {\r\n                        // Step 4\r\n                        if (this.previousServiceConfig === null) {\r\n                            // Step 4.ii\r\n                            this.handleResolutionFailure(serviceConfigError);\r\n                        }\r\n                        else {\r\n                            // Step 4.i\r\n                            workingServiceConfig = this.previousServiceConfig;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Step 3\r\n                    workingServiceConfig = serviceConfig;\r\n                    this.previousServiceConfig = serviceConfig;\r\n                }\r\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\r\n                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);\r\n                if (loadBalancingConfig === null) {\r\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\r\n                    this.handleResolutionFailure({\r\n                        code: constants_1.Status.UNAVAILABLE,\r\n                        details: 'All load balancer options in service config are not compatible',\r\n                        metadata: new metadata_1.Metadata(),\r\n                    });\r\n                    configSelector === null || configSelector === void 0 ? void 0 : configSelector.unref();\r\n                    return;\r\n                }\r\n                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, Object.assign(Object.assign({}, this.channelOptions), attributes));\r\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\r\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\r\n            },\r\n            onError: (error) => {\r\n                this.handleResolutionFailure(error);\r\n            },\r\n        }, channelOptions);\r\n        const backoffOptions = {\r\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\r\n            if (this.continueResolving) {\r\n                this.updateResolution();\r\n                this.continueResolving = false;\r\n            }\r\n            else {\r\n                this.updateState(this.latestChildState, this.latestChildPicker, this.latestChildErrorMessage);\r\n            }\r\n        }, backoffOptions);\r\n        this.backoffTimeout.unref();\r\n    }\r\n    updateResolution() {\r\n        this.innerResolver.updateResolution();\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            /* this.latestChildPicker is initialized as new QueuePicker(this), which\r\n             * is an appropriate value here if the child LB policy is unset.\r\n             * Otherwise, we want to delegate to the child here, in case that\r\n             * triggers something. */\r\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker, this.latestChildErrorMessage);\r\n        }\r\n        this.backoffTimeout.runOnce();\r\n    }\r\n    updateState(connectivityState, picker, errorMessage) {\r\n        trace((0, uri_parser_1.uriToString)(this.target) +\r\n            ' ' +\r\n            connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[connectivityState]);\r\n        // Ensure that this.exitIdle() is called by the picker\r\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            picker = new picker_1.QueuePicker(this, picker);\r\n        }\r\n        this.currentState = connectivityState;\r\n        this.channelControlHelper.updateState(connectivityState, picker, errorMessage);\r\n    }\r\n    handleResolutionFailure(error) {\r\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error), error.details);\r\n            this.onFailedResolution(error);\r\n        }\r\n    }\r\n    exitIdle() {\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\r\n            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n            if (this.backoffTimeout.isRunning()) {\r\n                this.continueResolving = true;\r\n            }\r\n            else {\r\n                this.updateResolution();\r\n            }\r\n        }\r\n        this.childLoadBalancer.exitIdle();\r\n    }\r\n    updateAddressList(endpointList, lbConfig) {\r\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\r\n    }\r\n    resetBackoff() {\r\n        this.backoffTimeout.reset();\r\n        this.childLoadBalancer.resetBackoff();\r\n    }\r\n    destroy() {\r\n        this.childLoadBalancer.destroy();\r\n        this.innerResolver.destroy();\r\n        this.backoffTimeout.reset();\r\n        this.backoffTimeout.stop();\r\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.latestChildPicker = new picker_1.QueuePicker(this);\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.previousServiceConfig = null;\r\n        this.continueResolving = false;\r\n    }\r\n    getTypeName() {\r\n        return 'resolving_load_balancer';\r\n    }\r\n}\r\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\r\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHNDQUFzQyxtQkFBTyxDQUFDLGtIQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanM/NjE1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XHJcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuLyoqXHJcbiAqIE5hbWUgbWF0Y2ggbGV2ZWxzIGluIG9yZGVyIGZyb20gbW9zdCB0byBsZWFzdCBzcGVjaWZpYy4gVGhpcyBpcyB0aGUgb3JkZXIgaW5cclxuICogd2hpY2ggc2VhcmNoZXMgd2lsbCBiZSBwZXJmb3JtZWQuXHJcbiAqL1xyXG5jb25zdCBOQU1FX01BVENIX0xFVkVMX09SREVSID0gW1xyXG4gICAgJ1NFUlZJQ0VfQU5EX01FVEhPRCcsXHJcbiAgICAnU0VSVklDRScsXHJcbiAgICAnRU1QVFknLFxyXG5dO1xyXG5mdW5jdGlvbiBoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWcsIG1hdGNoTGV2ZWwpIHtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xyXG4gICAgICAgIHN3aXRjaCAobWF0Y2hMZXZlbCkge1xyXG4gICAgICAgICAgICBjYXNlICdFTVBUWSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUuc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFJzpcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgIW5hbWUubWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnU0VSVklDRV9BTkRfTUVUSE9EJzpcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgbmFtZS5tZXRob2QgPT09IG1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdDb25maWcoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWdzLCBtYXRjaExldmVsKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBtZXRob2RDb25maWdzKSB7XHJcbiAgICAgICAgaWYgKGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIGNvbmZpZywgbWF0Y2hMZXZlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnZva2UobWV0aG9kTmFtZSwgbWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgY29uc3Qgc3BsaXROYW1lID0gbWV0aG9kTmFtZS5zcGxpdCgnLycpLmZpbHRlcih4ID0+IHgubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSAoX2EgPSBzcGxpdE5hbWVbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAoX2IgPSBzcGxpdE5hbWVbMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xyXG4gICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZyAmJiBzZXJ2aWNlQ29uZmlnLm1ldGhvZENvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgLyogQ2hlY2sgZm9yIHRoZSBmb2xsb3dpbmcgaW4gb3JkZXIsIGFuZCByZXR1cm4gdGhlIGZpcnN0IG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgKiBjb25maWcgdGhhdCBtYXRjaGVzOlxyXG4gICAgICAgICAgICAgICAgKiAxLiBBIG5hbWUgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIHNlcnZpY2UgYW5kIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgKiAyLiBBIG5hbWUgd2l0aCBubyBtZXRob2Qgc2V0IHRoYXQgbWF0Y2hlcyB0aGUgc2VydmljZVxyXG4gICAgICAgICAgICAgICAgKiAzLiBBbiBlbXB0eSBuYW1lXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaExldmVsIG9mIE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxyXG4gICAgICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxyXG4gICAgICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bnJlZigpIHsgfVxyXG4gICAgfTtcclxufVxyXG5jbGFzcyBSZXNvbHZpbmdMb2FkQmFsYW5jZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIGNsYXNzIHRoYXQgYmVoYXZlcyBsaWtlIGEgYExvYWRCYWxhbmNlcmAgYW5kIGFsc28gaGFuZGxlcyBuYW1lXHJcbiAgICAgKiByZXNvbHV0aW9uIGludGVybmFsbHkuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxyXG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxyXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXHJcbiAgICAgKiAgICAgaWYgbm9uZSBpcyBwcm92aWRlZCBieSB0aGUgbmFtZSByZXNvbHZlci4gQSBgbnVsbGAgdmFsdWUgaW5kaWNhdGVzXHJcbiAgICAgKiAgICAgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBzaG91bGQgYmUgdGhlIGRlZmF1bHQgdW5jb25maWd1cmVkIGJlaGF2aW9yLlxyXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXHJcbiAgICAgKiAgICAgaW1wbG1lbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbE9wdGlvbnMgPSBjaGFubmVsT3B0aW9ucztcclxuICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmxhdGVzdENoaWxkRXJyb3JNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHJlc29sdmluZyBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXHJcbiAgICAgICAgICogYXZhaWxhYmxlLiBBIHZhbHVlIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgd2UgaGF2ZSBub3QgeWV0IHJlY2VpdmVkIGEgdmFsaWRcclxuICAgICAgICAgKiBzZXJ2aWNlIGNvbmZpZyBmcm9tIHRoZSByZXNvbHZlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxyXG4gICAgICAgICAqIHRpbWVyIHJ1bnMgb3V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0gKDAsIHNlcnZpY2VfY29uZmlnXzEudmFsaWRhdGVTZXJ2aWNlQ29uZmlnKShKU09OLnBhcnNlKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcclxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpLCBudWxsKTtcclxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyID0gbmV3IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcih7XHJcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXHJcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiYWNrb2ZmVGltZW91dCBpcyBydW5uaW5nLCB3ZSdyZSBzdGlsbCBiYWNraW5nIG9mZiBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBtYWtpbmcgcmVzb2x2ZSByZXF1ZXN0cywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW5vdGhlciBvbmUgaGVyZS5cclxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXHJcbiAgICAgICAgICAgICAgICAgKiB1cGRhdGVSZXNvbHV0aW9uICovXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXF1ZXN0UmVyZXNvbHV0aW9uIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChuZXdTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IHBpY2tlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXHJcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyID0gKDAsIHJlc29sdmVyXzEuY3JlYXRlUmVzb2x2ZXIpKHRhcmdldCwge1xyXG4gICAgICAgICAgICBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uOiAoZW5kcG9pbnRMaXN0LCBzZXJ2aWNlQ29uZmlnLCBzZXJ2aWNlQ29uZmlnRXJyb3IsIGNvbmZpZ1NlbGVjdG9yLCBhdHRyaWJ1dGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGxldCB3b3JraW5nU2VydmljZUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXHJcbiAgICAgICAgICAgICAgICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMjEtc2VydmljZS1jb25maWctZXJyb3ItaGFuZGxpbmcubWRcclxuICAgICAgICAgICAgICAgICAqIGluIHRoZSBzZWN0aW9uIGNhbGxlZCBcIkJlaGF2aW9yIG9uIHJlY2VpdmluZyBhIG5ldyBnUlBDIENvbmZpZ1wiLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNCBhbmQgNVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JraW5nQ29uZmlnTGlzdCA9IChfYSA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSBudWxsIHx8IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3b3JraW5nU2VydmljZUNvbmZpZy5sb2FkQmFsYW5jaW5nQ29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRCYWxhbmNpbmdDb25maWcgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLnNlbGVjdExiQ29uZmlnRnJvbUxpc3QpKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkQmFsYW5jaW5nQ29uZmlnID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgd2VyZSBsb2FkIGJhbGFuY2luZyBjb25maWdzIGJ1dCBub25lIGFyZSBzdXBwb3J0ZWQuIFRoaXMgY291bnRzIGFzIGEgcmVzb2x1dGlvbiBmYWlsdXJlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ0FsbCBsb2FkIGJhbGFuY2VyIG9wdGlvbnMgaW4gc2VydmljZSBjb25maWcgYXJlIG5vdCBjb21wYXRpYmxlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnU2VsZWN0b3IgPT09IG51bGwgfHwgY29uZmlnU2VsZWN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ1NlbGVjdG9yLnVucmVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci51cGRhdGVBZGRyZXNzTGlzdChlbmRwb2ludExpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jaGFubmVsT3B0aW9ucyksIGF0dHJpYnV0ZXMpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24oZmluYWxTZXJ2aWNlQ29uZmlnLCBjb25maWdTZWxlY3RvciAhPT0gbnVsbCAmJiBjb25maWdTZWxlY3RvciAhPT0gdm9pZCAwID8gY29uZmlnU2VsZWN0b3IgOiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3IoZmluYWxTZXJ2aWNlQ29uZmlnKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgY2hhbm5lbE9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcclxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5sYXRlc3RDaGlsZFN0YXRlLCB0aGlzLmxhdGVzdENoaWxkUGlja2VyLCB0aGlzLmxhdGVzdENoaWxkRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XHJcbiAgICAgICAgICAgIC8qIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgaXMgaW5pdGlhbGl6ZWQgYXMgbmV3IFF1ZXVlUGlja2VyKHRoaXMpLCB3aGljaFxyXG4gICAgICAgICAgICAgKiBpcyBhbiBhcHByb3ByaWF0ZSB2YWx1ZSBoZXJlIGlmIHRoZSBjaGlsZCBMQiBwb2xpY3kgaXMgdW5zZXQuXHJcbiAgICAgICAgICAgICAqIE90aGVyd2lzZSwgd2Ugd2FudCB0byBkZWxlZ2F0ZSB0byB0aGUgY2hpbGQgaGVyZSwgaW4gY2FzZSB0aGF0XHJcbiAgICAgICAgICAgICAqIHRyaWdnZXJzIHNvbWV0aGluZy4gKi9cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCB0aGlzLmxhdGVzdENoaWxkUGlja2VyLCB0aGlzLmxhdGVzdENoaWxkRXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB0cmFjZSgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtjb25uZWN0aXZpdHlTdGF0ZV0pO1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMuZXhpdElkbGUoKSBpcyBjYWxsZWQgYnkgdGhlIHBpY2tlclxyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICBwaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcywgcGlja2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIsIGVycm9yTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdENoaWxkU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKGVycm9yKSwgZXJyb3IuZGV0YWlscyk7XHJcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleGl0SWRsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGVuZHBvaW50TGlzdCwgbGJDb25maWcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUFkZHJlc3NMaXN0IG5vdCBzdXBwb3J0ZWQgb24gUmVzb2x2aW5nTG9hZEJhbGFuY2VyJyk7XHJcbiAgICB9XHJcbiAgICByZXNldEJhY2tvZmYoKSB7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIucmVzZXRCYWNrb2ZmKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldFR5cGVOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'retrying_call';\r\nclass RetryThrottler {\r\n    constructor(maxTokens, tokenRatio, previousRetryThrottler) {\r\n        this.maxTokens = maxTokens;\r\n        this.tokenRatio = tokenRatio;\r\n        if (previousRetryThrottler) {\r\n            /* When carrying over tokens from a previous config, rescale them to the\r\n             * new max value */\r\n            this.tokens =\r\n                previousRetryThrottler.tokens *\r\n                    (maxTokens / previousRetryThrottler.maxTokens);\r\n        }\r\n        else {\r\n            this.tokens = maxTokens;\r\n        }\r\n    }\r\n    addCallSucceeded() {\r\n        this.tokens = Math.min(this.tokens + this.tokenRatio, this.maxTokens);\r\n    }\r\n    addCallFailed() {\r\n        this.tokens = Math.max(this.tokens - 1, 0);\r\n    }\r\n    canRetryCall() {\r\n        return this.tokens > (this.maxTokens / 2);\r\n    }\r\n}\r\nexports.RetryThrottler = RetryThrottler;\r\nclass MessageBufferTracker {\r\n    constructor(totalLimit, limitPerCall) {\r\n        this.totalLimit = totalLimit;\r\n        this.limitPerCall = limitPerCall;\r\n        this.totalAllocated = 0;\r\n        this.allocatedPerCall = new Map();\r\n    }\r\n    allocate(size, callId) {\r\n        var _a;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (this.limitPerCall - currentPerCall < size ||\r\n            this.totalLimit - this.totalAllocated < size) {\r\n            return false;\r\n        }\r\n        this.allocatedPerCall.set(callId, currentPerCall + size);\r\n        this.totalAllocated += size;\r\n        return true;\r\n    }\r\n    free(size, callId) {\r\n        var _a;\r\n        if (this.totalAllocated < size) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\r\n        }\r\n        this.totalAllocated -= size;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (currentPerCall < size) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\r\n        }\r\n        this.allocatedPerCall.set(callId, currentPerCall - size);\r\n    }\r\n    freeAll(callId) {\r\n        var _a;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (this.totalAllocated < currentPerCall) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\r\n        }\r\n        this.totalAllocated -= currentPerCall;\r\n        this.allocatedPerCall.delete(callId);\r\n    }\r\n}\r\nexports.MessageBufferTracker = MessageBufferTracker;\r\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\r\nconst DEFAULT_MAX_ATTEMPTS_LIMIT = 5;\r\nclass RetryingCall {\r\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\r\n        var _a;\r\n        this.channel = channel;\r\n        this.callConfig = callConfig;\r\n        this.methodName = methodName;\r\n        this.host = host;\r\n        this.credentials = credentials;\r\n        this.deadline = deadline;\r\n        this.callNumber = callNumber;\r\n        this.bufferTracker = bufferTracker;\r\n        this.retryThrottler = retryThrottler;\r\n        this.listener = null;\r\n        this.initialMetadata = null;\r\n        this.underlyingCalls = [];\r\n        this.writeBuffer = [];\r\n        /**\r\n         * The offset of message indices in the writeBuffer. For example, if\r\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\r\n         * is in writeBuffer[5].\r\n         */\r\n        this.writeBufferOffset = 0;\r\n        /**\r\n         * Tracks whether a read has been started, so that we know whether to start\r\n         * reads on new child calls. This only matters for the first read, because\r\n         * once a message comes in the child call becomes committed and there will\r\n         * be no new child calls.\r\n         */\r\n        this.readStarted = false;\r\n        this.transparentRetryUsed = false;\r\n        /**\r\n         * Number of attempts so far\r\n         */\r\n        this.attempts = 0;\r\n        this.hedgingTimer = null;\r\n        this.committedCallIndex = null;\r\n        this.initialRetryBackoffSec = 0;\r\n        this.nextRetryBackoffSec = 0;\r\n        const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;\r\n        if (channel.getOptions()['grpc.enable_retries'] === 0) {\r\n            this.state = 'NO_RETRY';\r\n            this.maxAttempts = 1;\r\n        }\r\n        else if (callConfig.methodConfig.retryPolicy) {\r\n            this.state = 'RETRY';\r\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\r\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\r\n            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);\r\n        }\r\n        else if (callConfig.methodConfig.hedgingPolicy) {\r\n            this.state = 'HEDGING';\r\n            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);\r\n        }\r\n        else {\r\n            this.state = 'TRANSPARENT_ONLY';\r\n            this.maxAttempts = 1;\r\n        }\r\n        this.startTime = new Date();\r\n    }\r\n    getDeadlineInfo() {\r\n        if (this.underlyingCalls.length === 0) {\r\n            return [];\r\n        }\r\n        const deadlineInfo = [];\r\n        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];\r\n        if (this.underlyingCalls.length > 1) {\r\n            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);\r\n        }\r\n        if (latestCall.startTime > this.startTime) {\r\n            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);\r\n        }\r\n        deadlineInfo.push(...latestCall.call.getDeadlineInfo());\r\n        return deadlineInfo;\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    reportStatus(statusObject) {\r\n        this.trace('ended with status: code=' +\r\n            statusObject.code +\r\n            ' details=\"' +\r\n            statusObject.details +\r\n            '\" start time=' +\r\n            this.startTime.toISOString());\r\n        this.bufferTracker.freeAll(this.callNumber);\r\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\r\n        this.writeBuffer = [];\r\n        process.nextTick(() => {\r\n            var _a;\r\n            // Explicitly construct status object to remove progress field\r\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\r\n                code: statusObject.code,\r\n                details: statusObject.details,\r\n                metadata: statusObject.metadata,\r\n            });\r\n        });\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });\r\n        for (const { call } of this.underlyingCalls) {\r\n            call.cancelWithStatus(status, details);\r\n        }\r\n    }\r\n    getPeer() {\r\n        if (this.committedCallIndex !== null) {\r\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\r\n        }\r\n        else {\r\n            return 'unknown';\r\n        }\r\n    }\r\n    getBufferEntry(messageIndex) {\r\n        var _a;\r\n        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\r\n            entryType: 'FREED',\r\n            allocated: false,\r\n        });\r\n    }\r\n    getNextBufferIndex() {\r\n        return this.writeBufferOffset + this.writeBuffer.length;\r\n    }\r\n    clearSentMessages() {\r\n        if (this.state !== 'COMMITTED') {\r\n            return;\r\n        }\r\n        let earliestNeededMessageIndex;\r\n        if (this.underlyingCalls[this.committedCallIndex].state === 'COMPLETED') {\r\n            /* If the committed call is completed, clear all messages, even if some\r\n             * have not been sent. */\r\n            earliestNeededMessageIndex = this.getNextBufferIndex();\r\n        }\r\n        else {\r\n            earliestNeededMessageIndex =\r\n                this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\r\n        }\r\n        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\r\n            const bufferEntry = this.getBufferEntry(messageIndex);\r\n            if (bufferEntry.allocated) {\r\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\r\n            }\r\n        }\r\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\r\n        this.writeBufferOffset = earliestNeededMessageIndex;\r\n    }\r\n    commitCall(index) {\r\n        var _a, _b;\r\n        if (this.state === 'COMMITTED') {\r\n            return;\r\n        }\r\n        this.trace('Committing call [' +\r\n            this.underlyingCalls[index].call.getCallNumber() +\r\n            '] at index ' +\r\n            index);\r\n        this.state = 'COMMITTED';\r\n        (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        this.committedCallIndex = index;\r\n        for (let i = 0; i < this.underlyingCalls.length; i++) {\r\n            if (i === index) {\r\n                continue;\r\n            }\r\n            if (this.underlyingCalls[i].state === 'COMPLETED') {\r\n                continue;\r\n            }\r\n            this.underlyingCalls[i].state = 'COMPLETED';\r\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\r\n        }\r\n        this.clearSentMessages();\r\n    }\r\n    commitCallWithMostMessages() {\r\n        if (this.state === 'COMMITTED') {\r\n            return;\r\n        }\r\n        let mostMessages = -1;\r\n        let callWithMostMessages = -1;\r\n        for (const [index, childCall] of this.underlyingCalls.entries()) {\r\n            if (childCall.state === 'ACTIVE' &&\r\n                childCall.nextMessageToSend > mostMessages) {\r\n                mostMessages = childCall.nextMessageToSend;\r\n                callWithMostMessages = index;\r\n            }\r\n        }\r\n        if (callWithMostMessages === -1) {\r\n            /* There are no active calls, disable retries to force the next call that\r\n             * is started to be committed. */\r\n            this.state = 'TRANSPARENT_ONLY';\r\n        }\r\n        else {\r\n            this.commitCall(callWithMostMessages);\r\n        }\r\n    }\r\n    isStatusCodeInList(list, code) {\r\n        return list.some(value => {\r\n            var _a;\r\n            return value === code ||\r\n                value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === void 0 ? void 0 : _a.toLowerCase());\r\n        });\r\n    }\r\n    getNextRetryBackoffMs() {\r\n        var _a;\r\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\r\n        if (!retryPolicy) {\r\n            return 0;\r\n        }\r\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\r\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\r\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\r\n        return nextBackoffMs;\r\n    }\r\n    maybeRetryCall(pushback, callback) {\r\n        if (this.state !== 'RETRY') {\r\n            callback(false);\r\n            return;\r\n        }\r\n        if (this.attempts >= this.maxAttempts) {\r\n            callback(false);\r\n            return;\r\n        }\r\n        let retryDelayMs;\r\n        if (pushback === null) {\r\n            retryDelayMs = this.getNextRetryBackoffMs();\r\n        }\r\n        else if (pushback < 0) {\r\n            this.state = 'TRANSPARENT_ONLY';\r\n            callback(false);\r\n            return;\r\n        }\r\n        else {\r\n            retryDelayMs = pushback;\r\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\r\n        }\r\n        setTimeout(() => {\r\n            var _a, _b;\r\n            if (this.state !== 'RETRY') {\r\n                callback(false);\r\n                return;\r\n            }\r\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\r\n                callback(true);\r\n                this.attempts += 1;\r\n                this.startNewAttempt();\r\n            }\r\n            else {\r\n                this.trace('Retry attempt denied by throttling policy');\r\n                callback(false);\r\n            }\r\n        }, retryDelayMs);\r\n    }\r\n    countActiveCalls() {\r\n        let count = 0;\r\n        for (const call of this.underlyingCalls) {\r\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\r\n                count += 1;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    handleProcessedStatus(status, callIndex, pushback) {\r\n        var _a, _b, _c;\r\n        switch (this.state) {\r\n            case 'COMMITTED':\r\n            case 'NO_RETRY':\r\n            case 'TRANSPARENT_ONLY':\r\n                this.commitCall(callIndex);\r\n                this.reportStatus(status);\r\n                break;\r\n            case 'HEDGING':\r\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\r\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\r\n                    let delayMs;\r\n                    if (pushback === null) {\r\n                        delayMs = 0;\r\n                    }\r\n                    else if (pushback < 0) {\r\n                        this.state = 'TRANSPARENT_ONLY';\r\n                        this.commitCall(callIndex);\r\n                        this.reportStatus(status);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        delayMs = pushback;\r\n                    }\r\n                    setTimeout(() => {\r\n                        this.maybeStartHedgingAttempt();\r\n                        // If after trying to start a call there are no active calls, this was the last one\r\n                        if (this.countActiveCalls() === 0) {\r\n                            this.commitCall(callIndex);\r\n                            this.reportStatus(status);\r\n                        }\r\n                    }, delayMs);\r\n                }\r\n                else {\r\n                    this.commitCall(callIndex);\r\n                    this.reportStatus(status);\r\n                }\r\n                break;\r\n            case 'RETRY':\r\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\r\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\r\n                    this.maybeRetryCall(pushback, retried => {\r\n                        if (!retried) {\r\n                            this.commitCall(callIndex);\r\n                            this.reportStatus(status);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    this.commitCall(callIndex);\r\n                    this.reportStatus(status);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    getPushback(metadata) {\r\n        const mdValue = metadata.get('grpc-retry-pushback-ms');\r\n        if (mdValue.length === 0) {\r\n            return null;\r\n        }\r\n        try {\r\n            return parseInt(mdValue[0]);\r\n        }\r\n        catch (e) {\r\n            return -1;\r\n        }\r\n    }\r\n    handleChildStatus(status, callIndex) {\r\n        var _a;\r\n        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\r\n            return;\r\n        }\r\n        this.trace('state=' +\r\n            this.state +\r\n            ' handling status with progress ' +\r\n            status.progress +\r\n            ' from child [' +\r\n            this.underlyingCalls[callIndex].call.getCallNumber() +\r\n            '] in state ' +\r\n            this.underlyingCalls[callIndex].state);\r\n        this.underlyingCalls[callIndex].state = 'COMPLETED';\r\n        if (status.code === constants_1.Status.OK) {\r\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\r\n            this.commitCall(callIndex);\r\n            this.reportStatus(status);\r\n            return;\r\n        }\r\n        if (this.state === 'NO_RETRY') {\r\n            this.commitCall(callIndex);\r\n            this.reportStatus(status);\r\n            return;\r\n        }\r\n        if (this.state === 'COMMITTED') {\r\n            this.reportStatus(status);\r\n            return;\r\n        }\r\n        const pushback = this.getPushback(status.metadata);\r\n        switch (status.progress) {\r\n            case 'NOT_STARTED':\r\n                // RPC never leaves the client, always safe to retry\r\n                this.startNewAttempt();\r\n                break;\r\n            case 'REFUSED':\r\n                // RPC reaches the server library, but not the server application logic\r\n                if (this.transparentRetryUsed) {\r\n                    this.handleProcessedStatus(status, callIndex, pushback);\r\n                }\r\n                else {\r\n                    this.transparentRetryUsed = true;\r\n                    this.startNewAttempt();\r\n                }\r\n                break;\r\n            case 'DROP':\r\n                this.commitCall(callIndex);\r\n                this.reportStatus(status);\r\n                break;\r\n            case 'PROCESSED':\r\n                this.handleProcessedStatus(status, callIndex, pushback);\r\n                break;\r\n        }\r\n    }\r\n    maybeStartHedgingAttempt() {\r\n        if (this.state !== 'HEDGING') {\r\n            return;\r\n        }\r\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\r\n            return;\r\n        }\r\n        if (this.attempts >= this.maxAttempts) {\r\n            return;\r\n        }\r\n        this.attempts += 1;\r\n        this.startNewAttempt();\r\n        this.maybeStartHedgingTimer();\r\n    }\r\n    maybeStartHedgingTimer() {\r\n        var _a, _b, _c;\r\n        if (this.hedgingTimer) {\r\n            clearTimeout(this.hedgingTimer);\r\n        }\r\n        if (this.state !== 'HEDGING') {\r\n            return;\r\n        }\r\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\r\n            return;\r\n        }\r\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\r\n        if (this.attempts >= this.maxAttempts) {\r\n            return;\r\n        }\r\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\r\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\r\n        this.hedgingTimer = setTimeout(() => {\r\n            this.maybeStartHedgingAttempt();\r\n        }, hedgingDelaySec * 1000);\r\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n    }\r\n    startNewAttempt() {\r\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\r\n        this.trace('Created child call [' +\r\n            child.getCallNumber() +\r\n            '] for attempt ' +\r\n            this.attempts);\r\n        const index = this.underlyingCalls.length;\r\n        this.underlyingCalls.push({\r\n            state: 'ACTIVE',\r\n            call: child,\r\n            nextMessageToSend: 0,\r\n            startTime: new Date()\r\n        });\r\n        const previousAttempts = this.attempts - 1;\r\n        const initialMetadata = this.initialMetadata.clone();\r\n        if (previousAttempts > 0) {\r\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n        }\r\n        let receivedMetadata = false;\r\n        child.start(initialMetadata, {\r\n            onReceiveMetadata: metadata => {\r\n                this.trace('Received metadata from child [' + child.getCallNumber() + ']');\r\n                this.commitCall(index);\r\n                receivedMetadata = true;\r\n                if (previousAttempts > 0) {\r\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n                }\r\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\r\n                    this.listener.onReceiveMetadata(metadata);\r\n                }\r\n            },\r\n            onReceiveMessage: message => {\r\n                this.trace('Received message from child [' + child.getCallNumber() + ']');\r\n                this.commitCall(index);\r\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\r\n                    this.listener.onReceiveMessage(message);\r\n                }\r\n            },\r\n            onReceiveStatus: status => {\r\n                this.trace('Received status from child [' + child.getCallNumber() + ']');\r\n                if (!receivedMetadata && previousAttempts > 0) {\r\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n                }\r\n                this.handleChildStatus(status, index);\r\n            },\r\n        });\r\n        this.sendNextChildMessage(index);\r\n        if (this.readStarted) {\r\n            child.startRead();\r\n        }\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.listener = listener;\r\n        this.initialMetadata = metadata;\r\n        this.attempts += 1;\r\n        this.startNewAttempt();\r\n        this.maybeStartHedgingTimer();\r\n    }\r\n    handleChildWriteCompleted(childIndex) {\r\n        var _a, _b;\r\n        const childCall = this.underlyingCalls[childIndex];\r\n        const messageIndex = childCall.nextMessageToSend;\r\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        this.clearSentMessages();\r\n        childCall.nextMessageToSend += 1;\r\n        this.sendNextChildMessage(childIndex);\r\n    }\r\n    sendNextChildMessage(childIndex) {\r\n        const childCall = this.underlyingCalls[childIndex];\r\n        if (childCall.state === 'COMPLETED') {\r\n            return;\r\n        }\r\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\r\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\r\n            switch (bufferEntry.entryType) {\r\n                case 'MESSAGE':\r\n                    childCall.call.sendMessageWithContext({\r\n                        callback: error => {\r\n                            // Ignore error\r\n                            this.handleChildWriteCompleted(childIndex);\r\n                        },\r\n                    }, bufferEntry.message.message);\r\n                    break;\r\n                case 'HALF_CLOSE':\r\n                    childCall.nextMessageToSend += 1;\r\n                    childCall.call.halfClose();\r\n                    break;\r\n                case 'FREED':\r\n                    // Should not be possible\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        var _a;\r\n        this.trace('write() called with message of length ' + message.length);\r\n        const writeObj = {\r\n            message,\r\n            flags: context.flags,\r\n        };\r\n        const messageIndex = this.getNextBufferIndex();\r\n        const bufferEntry = {\r\n            entryType: 'MESSAGE',\r\n            message: writeObj,\r\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber),\r\n        };\r\n        this.writeBuffer.push(bufferEntry);\r\n        if (bufferEntry.allocated) {\r\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\r\n            for (const [callIndex, call] of this.underlyingCalls.entries()) {\r\n                if (call.state === 'ACTIVE' &&\r\n                    call.nextMessageToSend === messageIndex) {\r\n                    call.call.sendMessageWithContext({\r\n                        callback: error => {\r\n                            // Ignore error\r\n                            this.handleChildWriteCompleted(callIndex);\r\n                        },\r\n                    }, message);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.commitCallWithMostMessages();\r\n            // commitCallWithMostMessages can fail if we are between ping attempts\r\n            if (this.committedCallIndex === null) {\r\n                return;\r\n            }\r\n            const call = this.underlyingCalls[this.committedCallIndex];\r\n            bufferEntry.callback = context.callback;\r\n            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\r\n                call.call.sendMessageWithContext({\r\n                    callback: error => {\r\n                        // Ignore error\r\n                        this.handleChildWriteCompleted(this.committedCallIndex);\r\n                    },\r\n                }, message);\r\n            }\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        this.readStarted = true;\r\n        for (const underlyingCall of this.underlyingCalls) {\r\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\r\n                underlyingCall.call.startRead();\r\n            }\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        const halfCloseIndex = this.getNextBufferIndex();\r\n        this.writeBuffer.push({\r\n            entryType: 'HALF_CLOSE',\r\n            allocated: false,\r\n        });\r\n        for (const call of this.underlyingCalls) {\r\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&\r\n                call.nextMessageToSend === halfCloseIndex) {\r\n                call.nextMessageToSend += 1;\r\n                call.call.halfClose();\r\n            }\r\n        }\r\n    }\r\n    setCredentials(newCredentials) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    getMethod() {\r\n        return this.methodName;\r\n    }\r\n    getHost() {\r\n        return this.host;\r\n    }\r\n}\r\nexports.RetryingCall = RetryingCall;\r\n//# sourceMappingURL=retrying-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQjtBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLFFBQVEsTUFBTSxvQkFBb0Isb0JBQW9CO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsUUFBUSxNQUFNLHVCQUF1QixlQUFlO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsWUFBWSxnQkFBZ0Isb0JBQW9CLG9CQUFvQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0NBQWdDO0FBQ3BGO0FBQ0E7QUFDQSxnRUFBZ0UsMkVBQTJFO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUE0RDtBQUN4RixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3JldHJ5aW5nLWNhbGwuanM/ZmQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SZXRyeWluZ0NhbGwgPSBleHBvcnRzLk1lc3NhZ2VCdWZmZXJUcmFja2VyID0gZXhwb3J0cy5SZXRyeVRocm90dGxlciA9IHZvaWQgMDtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAncmV0cnlpbmdfY2FsbCc7XHJcbmNsYXNzIFJldHJ5VGhyb3R0bGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heFRva2VucywgdG9rZW5SYXRpbywgcHJldmlvdXNSZXRyeVRocm90dGxlcikge1xyXG4gICAgICAgIHRoaXMubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xyXG4gICAgICAgIHRoaXMudG9rZW5SYXRpbyA9IHRva2VuUmF0aW87XHJcbiAgICAgICAgaWYgKHByZXZpb3VzUmV0cnlUaHJvdHRsZXIpIHtcclxuICAgICAgICAgICAgLyogV2hlbiBjYXJyeWluZyBvdmVyIHRva2VucyBmcm9tIGEgcHJldmlvdXMgY29uZmlnLCByZXNjYWxlIHRoZW0gdG8gdGhlXHJcbiAgICAgICAgICAgICAqIG5ldyBtYXggdmFsdWUgKi9cclxuICAgICAgICAgICAgdGhpcy50b2tlbnMgPVxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXRyeVRocm90dGxlci50b2tlbnMgKlxyXG4gICAgICAgICAgICAgICAgICAgIChtYXhUb2tlbnMgLyBwcmV2aW91c1JldHJ5VGhyb3R0bGVyLm1heFRva2Vucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9IG1heFRva2VucztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRDYWxsU3VjY2VlZGVkKCkge1xyXG4gICAgICAgIHRoaXMudG9rZW5zID0gTWF0aC5taW4odGhpcy50b2tlbnMgKyB0aGlzLnRva2VuUmF0aW8sIHRoaXMubWF4VG9rZW5zKTtcclxuICAgIH1cclxuICAgIGFkZENhbGxGYWlsZWQoKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1heCh0aGlzLnRva2VucyAtIDEsIDApO1xyXG4gICAgfVxyXG4gICAgY2FuUmV0cnlDYWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucyA+ICh0aGlzLm1heFRva2VucyAvIDIpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSBSZXRyeVRocm90dGxlcjtcclxuY2xhc3MgTWVzc2FnZUJ1ZmZlclRyYWNrZXIge1xyXG4gICAgY29uc3RydWN0b3IodG90YWxMaW1pdCwgbGltaXRQZXJDYWxsKSB7XHJcbiAgICAgICAgdGhpcy50b3RhbExpbWl0ID0gdG90YWxMaW1pdDtcclxuICAgICAgICB0aGlzLmxpbWl0UGVyQ2FsbCA9IGxpbWl0UGVyQ2FsbDtcclxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkID0gMDtcclxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShzaXplLCBjYWxsSWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXRQZXJDYWxsIC0gY3VycmVudFBlckNhbGwgPCBzaXplIHx8XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxMaW1pdCAtIHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsICsgc2l6ZSk7XHJcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCArPSBzaXplO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnJlZShzaXplLCBjYWxsSWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gc2l6ZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICBpZiAoY3VycmVudFBlckNhbGwgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IGFsbG9jYXRlZCBmb3IgY2FsbCAke2N1cnJlbnRQZXJDYWxsfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuc2V0KGNhbGxJZCwgY3VycmVudFBlckNhbGwgLSBzaXplKTtcclxuICAgIH1cclxuICAgIGZyZWVBbGwoY2FsbElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIGlmICh0aGlzLnRvdGFsQWxsb2NhdGVkIDwgY3VycmVudFBlckNhbGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBhbGxvY2F0ZWQgJHtjdXJyZW50UGVyQ2FsbH0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkIC09IGN1cnJlbnRQZXJDYWxsO1xyXG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5kZWxldGUoY2FsbElkKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc3NhZ2VCdWZmZXJUcmFja2VyID0gTWVzc2FnZUJ1ZmZlclRyYWNrZXI7XHJcbmNvbnN0IFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVkgPSAnZ3JwYy1wcmV2aW91cy1ycGMtYXR0ZW1wdHMnO1xyXG5jb25zdCBERUZBVUxUX01BWF9BVFRFTVBUU19MSU1JVCA9IDU7XHJcbmNsYXNzIFJldHJ5aW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIGJ1ZmZlclRyYWNrZXIsIHJldHJ5VGhyb3R0bGVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5jYWxsQ29uZmlnID0gY2FsbENvbmZpZztcclxuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcclxuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlciA9IGJ1ZmZlclRyYWNrZXI7XHJcbiAgICAgICAgdGhpcy5yZXRyeVRocm90dGxlciA9IHJldHJ5VGhyb3R0bGVyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbE1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscyA9IFtdO1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb2Zmc2V0IG9mIG1lc3NhZ2UgaW5kaWNlcyBpbiB0aGUgd3JpdGVCdWZmZXIuIEZvciBleGFtcGxlLCBpZlxyXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XHJcbiAgICAgICAgICogaXMgaW4gd3JpdGVCdWZmZXJbNV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgYSByZWFkIGhhcyBiZWVuIHN0YXJ0ZWQsIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIHRvIHN0YXJ0XHJcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcclxuICAgICAgICAgKiBvbmNlIGEgbWVzc2FnZSBjb21lcyBpbiB0aGUgY2hpbGQgY2FsbCBiZWNvbWVzIGNvbW1pdHRlZCBhbmQgdGhlcmUgd2lsbFxyXG4gICAgICAgICAqIGJlIG5vIG5ldyBjaGlsZCBjYWxscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlYWRTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBhdHRlbXB0cyBzbyBmYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XHJcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gMDtcclxuICAgICAgICBjb25zdCBtYXhBdHRlbXB0c0xpbWl0ID0gKF9hID0gY2hhbm5lbC5nZXRPcHRpb25zKClbJ2dycGMtbm9kZS5yZXRyeV9tYXhfYXR0ZW1wdHNfbGltaXQnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9NQVhfQVRURU1QVFNfTElNSVQ7XHJcbiAgICAgICAgaWYgKGNoYW5uZWwuZ2V0T3B0aW9ucygpWydncnBjLmVuYWJsZV9yZXRyaWVzJ10gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdOT19SRVRSWSc7XHJcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JFVFJZJztcclxuICAgICAgICAgICAgY29uc3QgcmV0cnlQb2xpY3kgPSBjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcclxuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLnN1YnN0cmluZygwLCByZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4QXR0ZW1wdHMgPSBNYXRoLm1pbihyZXRyeVBvbGljeS5tYXhBdHRlbXB0cywgbWF4QXR0ZW1wdHNMaW1pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcclxuICAgICAgICAgICAgdGhpcy5tYXhBdHRlbXB0cyA9IE1hdGgubWluKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIG1heEF0dGVtcHRzTGltaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcclxuICAgICAgICAgICAgdGhpcy5tYXhBdHRlbXB0cyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgIH1cclxuICAgIGdldERlYWRsaW5lSW5mbygpIHtcclxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVhZGxpbmVJbmZvID0gW107XHJcbiAgICAgICAgY29uc3QgbGF0ZXN0Q2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKGBwcmV2aW91cyBhdHRlbXB0czogJHt0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGggLSAxfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF0ZXN0Q2FsbC5zdGFydFRpbWUgPiB0aGlzLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBkZWFkbGluZUluZm8ucHVzaChgdGltZSB0byBjdXJyZW50IGF0dGVtcHQgc3RhcnQ6ICR7KDAsIGRlYWRsaW5lXzEuZm9ybWF0RGF0ZURpZmZlcmVuY2UpKHRoaXMuc3RhcnRUaW1lLCBsYXRlc3RDYWxsLnN0YXJ0VGltZSl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYWRsaW5lSW5mby5wdXNoKC4uLmxhdGVzdENhbGwuY2FsbC5nZXREZWFkbGluZUluZm8oKSk7XHJcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lSW5mbztcclxuICAgIH1cclxuICAgIGdldENhbGxOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXR1cyhzdGF0dXNPYmplY3QpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcclxuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmNvZGUgK1xyXG4gICAgICAgICAgICAnIGRldGFpbHM9XCInICtcclxuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xyXG4gICAgICAgICAgICAnXCIgc3RhcnQgdGltZT0nICtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyLmZyZWVBbGwodGhpcy5jYWxsTnVtYmVyKTtcclxuICAgICAgICB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCArIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGNvbnN0cnVjdCBzdGF0dXMgb2JqZWN0IHRvIHJlbW92ZSBwcm9ncmVzcyBmaWVsZFxyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IHN0YXR1c09iamVjdC5jb2RlLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogc3RhdHVzT2JqZWN0LmRldGFpbHMsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzT2JqZWN0Lm1ldGFkYXRhLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBjYWxsIH0gb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcclxuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5jYWxsLmdldFBlZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy53cml0ZUJ1ZmZlclttZXNzYWdlSW5kZXggLSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xyXG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdGUkVFRCcsXHJcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0QnVmZmVySW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgKyB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGNsZWFyU2VudE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnQ09NTUlUVEVEJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDtcclxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xyXG4gICAgICAgICAgICAvKiBJZiB0aGUgY29tbWl0dGVkIGNhbGwgaXMgY29tcGxldGVkLCBjbGVhciBhbGwgbWVzc2FnZXMsIGV2ZW4gaWYgc29tZVxyXG4gICAgICAgICAgICAgKiBoYXZlIG5vdCBiZWVuIHNlbnQuICovXHJcbiAgICAgICAgICAgIGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4ID1cclxuICAgICAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5uZXh0TWVzc2FnZVRvU2VuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZUluZGV4ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldDsgbWVzc2FnZUluZGV4IDwgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7IG1lc3NhZ2VJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZShidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4O1xyXG4gICAgfVxyXG4gICAgY29tbWl0Q2FsbChpbmRleCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnQ29tbWl0dGluZyBjYWxsIFsnICtcclxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcclxuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXHJcbiAgICAgICAgICAgIGluZGV4KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gJ0NPTU1JVFRFRCc7XHJcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKS5vbkNvbW1pdHRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLnN0YXRlID0gJ0NPTVBMRVRFRCc7XHJcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnRGlzY2FyZGVkIGluIGZhdm9yIG9mIG90aGVyIGhlZGdlZCBhdHRlbXB0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xlYXJTZW50TWVzc2FnZXMoKTtcclxuICAgIH1cclxuICAgIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtb3N0TWVzc2FnZXMgPSAtMTtcclxuICAgICAgICBsZXQgY2FsbFdpdGhNb3N0TWVzc2FnZXMgPSAtMTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRDYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkQ2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA+IG1vc3RNZXNzYWdlcykge1xyXG4gICAgICAgICAgICAgICAgbW9zdE1lc3NhZ2VzID0gY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kO1xyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhNb3N0TWVzc2FnZXMgPSBpbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbFdpdGhNb3N0TWVzc2FnZXMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8qIFRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMsIGRpc2FibGUgcmV0cmllcyB0byBmb3JjZSB0aGUgbmV4dCBjYWxsIHRoYXRcclxuICAgICAgICAgICAgICogaXMgc3RhcnRlZCB0byBiZSBjb21taXR0ZWQuICovXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbFdpdGhNb3N0TWVzc2FnZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzU3RhdHVzQ29kZUluTGlzdChsaXN0LCBjb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpc3Quc29tZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjb2RlIHx8XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICgoX2EgPSBjb25zdGFudHNfMS5TdGF0dXNbY29kZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldE5leHRSZXRyeUJhY2tvZmZNcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmV0cnlQb2xpY3kgPSAoX2EgPSB0aGlzLmNhbGxDb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXRob2RDb25maWcucmV0cnlQb2xpY3k7XHJcbiAgICAgICAgaWYgKCFyZXRyeVBvbGljeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmZNcyA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiAxMDAwO1xyXG4gICAgICAgIGNvbnN0IG1heEJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kubWF4QmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kubWF4QmFja29mZi5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gTWF0aC5taW4odGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjICogcmV0cnlQb2xpY3kuYmFja29mZk11bHRpcGxpZXIsIG1heEJhY2tvZmZTZWMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0QmFja29mZk1zO1xyXG4gICAgfVxyXG4gICAgbWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdSRVRSWScpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IHRoaXMubWF4QXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXRyeURlbGF5TXM7XHJcbiAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHRoaXMuZ2V0TmV4dFJldHJ5QmFja29mZk1zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHB1c2hiYWNrO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUmV0cnlDYWxsKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JldHJ5IGF0dGVtcHQgZGVuaWVkIGJ5IHRocm90dGxpbmcgcG9saWN5Jyk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCByZXRyeURlbGF5TXMpO1xyXG4gICAgfVxyXG4gICAgY291bnRBY3RpdmVDYWxscygpIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xyXG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuICAgIGhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnQ09NTUlUVEVEJzpcclxuICAgICAgICAgICAgY2FzZSAnTk9fUkVUUlknOlxyXG4gICAgICAgICAgICBjYXNlICdUUkFOU1BBUkVOVF9PTkxZJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdIRURHSU5HJzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdHVzQ29kZUluTGlzdCgoX2EgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kubm9uRmF0YWxTdGF0dXNDb2RlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIHN0YXR1cy5jb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5TXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwdXNoYmFjayA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSBwdXNoYmFjaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIHRyeWluZyB0byBzdGFydCBhIGNhbGwgdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgdGhpcyB3YXMgdGhlIGxhc3Qgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50QWN0aXZlQ2FsbHMoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXlNcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFVFJZJzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdHVzQ29kZUluTGlzdCh0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5LnJldHJ5YWJsZVN0YXR1c0NvZGVzLCBzdGF0dXMuY29kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkQ2FsbEZhaWxlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIHJldHJpZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldHJpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFB1c2hiYWNrKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbWRWYWx1ZSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1yZXRyeS1wdXNoYmFjay1tcycpO1xyXG4gICAgICAgIGlmIChtZFZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1kVmFsdWVbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhdGU9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgK1xyXG4gICAgICAgICAgICAnIGhhbmRsaW5nIHN0YXR1cyB3aXRoIHByb2dyZXNzICcgK1xyXG4gICAgICAgICAgICBzdGF0dXMucHJvZ3Jlc3MgK1xyXG4gICAgICAgICAgICAnIGZyb20gY2hpbGQgWycgK1xyXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcclxuICAgICAgICAgICAgJ10gaW4gc3RhdGUgJyArXHJcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUpO1xyXG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPSAnQ09NUExFVEVEJztcclxuICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ05PX1JFVFJZJykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdXNoYmFjayA9IHRoaXMuZ2V0UHVzaGJhY2soc3RhdHVzLm1ldGFkYXRhKTtcclxuICAgICAgICBzd2l0Y2ggKHN0YXR1cy5wcm9ncmVzcykge1xyXG4gICAgICAgICAgICBjYXNlICdOT1RfU1RBUlRFRCc6XHJcbiAgICAgICAgICAgICAgICAvLyBSUEMgbmV2ZXIgbGVhdmVzIHRoZSBjbGllbnQsIGFsd2F5cyBzYWZlIHRvIHJldHJ5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFRlVTRUQnOlxyXG4gICAgICAgICAgICAgICAgLy8gUlBDIHJlYWNoZXMgdGhlIHNlcnZlciBsaWJyYXJ5LCBidXQgbm90IHRoZSBzZXJ2ZXIgYXBwbGljYXRpb24gbG9naWNcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnRSZXRyeVVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnUFJPQ0VTU0VEJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvY2Vzc2VkU3RhdHVzKHN0YXR1cywgY2FsbEluZGV4LCBwdXNoYmFjayk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdIRURHSU5HJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gdGhpcy5tYXhBdHRlbXB0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcclxuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xyXG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xyXG4gICAgfVxyXG4gICAgbWF5YmVTdGFydEhlZGdpbmdUaW1lcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAodGhpcy5oZWRnaW5nVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVkZ2luZ1RpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdIRURHSU5HJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVkZ2luZ1BvbGljeSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeTtcclxuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSB0aGlzLm1heEF0dGVtcHRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U3RyaW5nID0gKF9hID0gaGVkZ2luZ1BvbGljeS5oZWRnaW5nRGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcwcyc7XHJcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U2VjID0gTnVtYmVyKGhlZGdpbmdEZWxheVN0cmluZy5zdWJzdHJpbmcoMCwgaGVkZ2luZ0RlbGF5U3RyaW5nLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCgpO1xyXG4gICAgICAgIH0sIGhlZGdpbmdEZWxheVNlYyAqIDEwMDApO1xyXG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xyXG4gICAgfVxyXG4gICAgc3RhcnROZXdBdHRlbXB0KCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArXHJcbiAgICAgICAgICAgIGNoaWxkLmdldENhbGxOdW1iZXIoKSArXHJcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRzKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcclxuICAgICAgICAgICAgc3RhdGU6ICdBQ1RJVkUnLFxyXG4gICAgICAgICAgICBjYWxsOiBjaGlsZCxcclxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXR0ZW1wdHMgPSB0aGlzLmF0dGVtcHRzIC0gMTtcclxuICAgICAgICBjb25zdCBpbml0aWFsTWV0YWRhdGEgPSB0aGlzLmluaXRpYWxNZXRhZGF0YS5jbG9uZSgpO1xyXG4gICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xyXG4gICAgICAgICAgICBpbml0aWFsTWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZWNlaXZlZE1ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgY2hpbGQuc3RhcnQoaW5pdGlhbE1ldGFkYXRhLCB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXRhZGF0YSBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uc3RhdGUgPT09ICdBQ1RJVkUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVkTWV0YWRhdGEgJiYgcHJldmlvdXNBdHRlbXB0cyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkU3RhdHVzKHN0YXR1cywgaW5kZXgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2VuZE5leHRDaGlsZE1lc3NhZ2UoaW5kZXgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcclxuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xyXG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjaGlsZENhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1tjaGlsZEluZGV4XTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQ7XHJcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpKS5jYWxsYmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJTZW50TWVzc2FnZXMoKTtcclxuICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcclxuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGNoaWxkSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgc2VuZE5leHRDaGlsZE1lc3NhZ2UoY2hpbGRJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xyXG4gICAgICAgIGlmIChjaGlsZENhbGwuc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0QnVmZmVyRW50cnkoY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kKSkge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkoY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kKTtcclxuICAgICAgICAgICAgc3dpdGNoIChidWZmZXJFbnRyeS5lbnRyeVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ01FU1NBR0UnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2hpbGRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgYnVmZmVyRW50cnkubWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0hBTEZfQ0xPU0UnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnRlJFRUQnOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVPYmogPSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGZsYWdzOiBjb250ZXh0LmZsYWdzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcclxuICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHtcclxuICAgICAgICAgICAgZW50cnlUeXBlOiAnTUVTU0FHRScsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHdyaXRlT2JqLFxyXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IHRoaXMuYnVmZmVyVHJhY2tlci5hbGxvY2F0ZShtZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChidWZmZXJFbnRyeSk7XHJcbiAgICAgICAgaWYgKGJ1ZmZlckVudHJ5LmFsbG9jYXRlZCkge1xyXG4gICAgICAgICAgICAoX2EgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250ZXh0KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbY2FsbEluZGV4LCBjYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IG1lc3NhZ2VJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKTtcclxuICAgICAgICAgICAgLy8gY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMgY2FuIGZhaWwgaWYgd2UgYXJlIGJldHdlZW4gcGluZyBhdHRlbXB0c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdO1xyXG4gICAgICAgICAgICBidWZmZXJFbnRyeS5jYWxsYmFjayA9IGNvbnRleHQuY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJiBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBtZXNzYWdlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydFJlYWQoKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xyXG4gICAgICAgIHRoaXMucmVhZFN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAoY29uc3QgdW5kZXJseWluZ0NhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcclxuICAgICAgICAgICAgaWYgKCh1bmRlcmx5aW5nQ2FsbCA9PT0gbnVsbCB8fCB1bmRlcmx5aW5nQ2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5kZXJseWluZ0NhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xyXG4gICAgICAgICAgICAgICAgdW5kZXJseWluZ0NhbGwuY2FsbC5zdGFydFJlYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbGZDbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XHJcbiAgICAgICAgY29uc3QgaGFsZkNsb3NlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaCh7XHJcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0hBTEZfQ0xPU0UnLFxyXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xyXG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnICYmXHJcbiAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBoYWxmQ2xvc2VJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0Q3JlZGVudGlhbHMobmV3Q3JlZGVudGlhbHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBnZXRNZXRob2QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kTmFtZTtcclxuICAgIH1cclxuICAgIGdldEhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IFJldHJ5aW5nQ2FsbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\r\nexports.serverErrorToStatus = serverErrorToStatus;\r\nconst events_1 = __webpack_require__(/*! events */ \"events\");\r\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nfunction serverErrorToStatus(error, overrideTrailers) {\r\n    var _a;\r\n    const status = {\r\n        code: constants_1.Status.UNKNOWN,\r\n        details: 'message' in error ? error.message : 'Unknown Error',\r\n        metadata: (_a = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a !== void 0 ? _a : null,\r\n    };\r\n    if ('code' in error &&\r\n        typeof error.code === 'number' &&\r\n        Number.isInteger(error.code)) {\r\n        status.code = error.code;\r\n        if ('details' in error && typeof error.details === 'string') {\r\n            status.details = error.details;\r\n        }\r\n    }\r\n    return status;\r\n}\r\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\r\n    constructor(path, call, metadata, request) {\r\n        super();\r\n        this.path = path;\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.request = request;\r\n        this.cancelled = false;\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getHost() {\r\n        return this.call.getHost();\r\n    }\r\n}\r\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\r\nclass ServerReadableStreamImpl extends stream_1.Readable {\r\n    constructor(path, call, metadata) {\r\n        super({ objectMode: true });\r\n        this.path = path;\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.cancelled = false;\r\n    }\r\n    _read(size) {\r\n        this.call.startRead();\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getHost() {\r\n        return this.call.getHost();\r\n    }\r\n}\r\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\r\nclass ServerWritableStreamImpl extends stream_1.Writable {\r\n    constructor(path, call, metadata, request) {\r\n        super({ objectMode: true });\r\n        this.path = path;\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.request = request;\r\n        this.pendingStatus = {\r\n            code: constants_1.Status.OK,\r\n            details: 'OK',\r\n        };\r\n        this.cancelled = false;\r\n        this.trailingMetadata = new metadata_1.Metadata();\r\n        this.on('error', err => {\r\n            this.pendingStatus = serverErrorToStatus(err);\r\n            this.end();\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getHost() {\r\n        return this.call.getHost();\r\n    }\r\n    _write(chunk, encoding, \r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    callback) {\r\n        this.call.sendMessage(chunk, callback);\r\n    }\r\n    _final(callback) {\r\n        var _a;\r\n        callback(null);\r\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    end(metadata) {\r\n        if (metadata) {\r\n            this.trailingMetadata = metadata;\r\n        }\r\n        return super.end();\r\n    }\r\n}\r\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\r\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\r\n    constructor(path, call, metadata) {\r\n        super({ objectMode: true });\r\n        this.path = path;\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.pendingStatus = {\r\n            code: constants_1.Status.OK,\r\n            details: 'OK',\r\n        };\r\n        this.cancelled = false;\r\n        this.trailingMetadata = new metadata_1.Metadata();\r\n        this.on('error', err => {\r\n            this.pendingStatus = serverErrorToStatus(err);\r\n            this.end();\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getHost() {\r\n        return this.call.getHost();\r\n    }\r\n    _read(size) {\r\n        this.call.startRead();\r\n    }\r\n    _write(chunk, encoding, \r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    callback) {\r\n        this.call.sendMessage(chunk, callback);\r\n    }\r\n    _final(callback) {\r\n        var _a;\r\n        callback(null);\r\n        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    end(metadata) {\r\n        if (metadata) {\r\n            this.trailingMetadata = metadata;\r\n        }\r\n        return super.end();\r\n    }\r\n}\r\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\r\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkI7QUFDbEksMkJBQTJCO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHlCQUF5QixxR0FBcUc7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQseUJBQXlCLHFHQUFxRztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanM/MmRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IHZvaWQgMDtcclxuZXhwb3J0cy5zZXJ2ZXJFcnJvclRvU3RhdHVzID0gc2VydmVyRXJyb3JUb1N0YXR1cztcclxuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmZ1bmN0aW9uIHNlcnZlckVycm9yVG9TdGF0dXMoZXJyb3IsIG92ZXJyaWRlVHJhaWxlcnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcclxuICAgICAgICBkZXRhaWxzOiAnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gRXJyb3InLFxyXG4gICAgICAgIG1ldGFkYXRhOiAoX2EgPSBvdmVycmlkZVRyYWlsZXJzICE9PSBudWxsICYmIG92ZXJyaWRlVHJhaWxlcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlVHJhaWxlcnMgOiBlcnJvci5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcclxuICAgIH07XHJcbiAgICBpZiAoJ2NvZGUnIGluIGVycm9yICYmXHJcbiAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSkge1xyXG4gICAgICAgIHN0YXR1cy5jb2RlID0gZXJyb3IuY29kZTtcclxuICAgICAgICBpZiAoJ2RldGFpbHMnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5kZXRhaWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IGVycm9yLmRldGFpbHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXR1cztcclxufVxyXG5jbGFzcyBTZXJ2ZXJVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhLCByZXF1ZXN0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXREZWFkbGluZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRIb3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0SG9zdCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XHJcbmNsYXNzIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIF9yZWFkKHNpemUpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVhZGxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEhvc3QoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbDtcclxuY2xhc3MgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xyXG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgZXJyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gc2VydmVyRXJyb3JUb1N0YXR1cyhlcnIpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcclxuICAgIH1cclxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIGdldERlYWRsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcclxuICAgIH1cclxuICAgIGdldFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcclxuICAgIH1cclxuICAgIGdldEhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRIb3N0KCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZShjaHVuaywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wZW5kaW5nU3RhdHVzKSwgeyBtZXRhZGF0YTogKF9hID0gdGhpcy5wZW5kaW5nU3RhdHVzLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGVuZChtZXRhZGF0YSkge1xyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsO1xyXG5jbGFzcyBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNhbGwsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0ge1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXHJcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XHJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBzZXJ2ZXJFcnJvclRvU3RhdHVzKGVycik7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVhZGxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldEhvc3QoKTtcclxuICAgIH1cclxuICAgIF9yZWFkKHNpemUpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWVzc2FnZShjaHVuaywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wZW5kaW5nU3RhdHVzKSwgeyBtZXRhZGF0YTogKF9hID0gdGhpcy5wZW5kaW5nU3RhdHVzLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGVuZChtZXRhZGF0YSkge1xyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IFNlcnZlckR1cGxleFN0cmVhbUltcGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ServerCredentials = void 0;\r\nexports.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;\r\nexports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;\r\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\r\nclass ServerCredentials {\r\n    constructor(serverConstructorOptions, contextOptions) {\r\n        this.serverConstructorOptions = serverConstructorOptions;\r\n        this.watchers = new Set();\r\n        this.latestContextOptions = null;\r\n        this.latestContextOptions = contextOptions !== null && contextOptions !== void 0 ? contextOptions : null;\r\n    }\r\n    _addWatcher(watcher) {\r\n        this.watchers.add(watcher);\r\n    }\r\n    _removeWatcher(watcher) {\r\n        this.watchers.delete(watcher);\r\n    }\r\n    getWatcherCount() {\r\n        return this.watchers.size;\r\n    }\r\n    updateSecureContextOptions(options) {\r\n        this.latestContextOptions = options;\r\n        for (const watcher of this.watchers) {\r\n            watcher(this.latestContextOptions);\r\n        }\r\n    }\r\n    _isSecure() {\r\n        return this.serverConstructorOptions !== null;\r\n    }\r\n    _getSecureContextOptions() {\r\n        return this.latestContextOptions;\r\n    }\r\n    _getConstructorOptions() {\r\n        return this.serverConstructorOptions;\r\n    }\r\n    _getInterceptors() {\r\n        return [];\r\n    }\r\n    static createInsecure() {\r\n        return new InsecureServerCredentials();\r\n    }\r\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\r\n        var _a;\r\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\r\n            throw new TypeError('rootCerts must be null or a Buffer');\r\n        }\r\n        if (!Array.isArray(keyCertPairs)) {\r\n            throw new TypeError('keyCertPairs must be an array');\r\n        }\r\n        if (typeof checkClientCertificate !== 'boolean') {\r\n            throw new TypeError('checkClientCertificate must be a boolean');\r\n        }\r\n        const cert = [];\r\n        const key = [];\r\n        for (let i = 0; i < keyCertPairs.length; i++) {\r\n            const pair = keyCertPairs[i];\r\n            if (pair === null || typeof pair !== 'object') {\r\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\r\n            }\r\n            if (!Buffer.isBuffer(pair.private_key)) {\r\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\r\n            }\r\n            if (!Buffer.isBuffer(pair.cert_chain)) {\r\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\r\n            }\r\n            cert.push(pair.cert_chain);\r\n            key.push(pair.private_key);\r\n        }\r\n        return new SecureServerCredentials({\r\n            requestCert: checkClientCertificate,\r\n            ciphers: tls_helpers_1.CIPHER_SUITES,\r\n        }, {\r\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\r\n            cert,\r\n            key,\r\n        });\r\n    }\r\n}\r\nexports.ServerCredentials = ServerCredentials;\r\nclass InsecureServerCredentials extends ServerCredentials {\r\n    constructor() {\r\n        super(null);\r\n    }\r\n    _getSettings() {\r\n        return null;\r\n    }\r\n    _equals(other) {\r\n        return other instanceof InsecureServerCredentials;\r\n    }\r\n}\r\nclass SecureServerCredentials extends ServerCredentials {\r\n    constructor(constructorOptions, contextOptions) {\r\n        super(constructorOptions, contextOptions);\r\n        this.options = Object.assign(Object.assign({}, constructorOptions), contextOptions);\r\n    }\r\n    /**\r\n     * Checks equality by checking the options that are actually set by\r\n     * createSsl.\r\n     * @param other\r\n     * @returns\r\n     */\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof SecureServerCredentials)) {\r\n            return false;\r\n        }\r\n        // options.ca equality check\r\n        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {\r\n            if (!this.options.ca.equals(other.options.ca)) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            if (this.options.ca !== other.options.ca) {\r\n                return false;\r\n            }\r\n        }\r\n        // options.cert equality check\r\n        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {\r\n            if (this.options.cert.length !== other.options.cert.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < this.options.cert.length; i++) {\r\n                const thisCert = this.options.cert[i];\r\n                const otherCert = other.options.cert[i];\r\n                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {\r\n                    if (!thisCert.equals(otherCert)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    if (thisCert !== otherCert) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this.options.cert !== other.options.cert) {\r\n                return false;\r\n            }\r\n        }\r\n        // options.key equality check\r\n        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {\r\n            if (this.options.key.length !== other.options.key.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < this.options.key.length; i++) {\r\n                const thisKey = this.options.key[i];\r\n                const otherKey = other.options.key[i];\r\n                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {\r\n                    if (!thisKey.equals(otherKey)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    if (thisKey !== otherKey) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this.options.key !== other.options.key) {\r\n                return false;\r\n            }\r\n        }\r\n        // options.requestCert equality check\r\n        if (this.options.requestCert !== other.options.requestCert) {\r\n            return false;\r\n        }\r\n        /* ciphers is derived from a value that is constant for the process, so no\r\n         * equality check is needed. */\r\n        return true;\r\n    }\r\n}\r\nclass CertificateProviderServerCredentials extends ServerCredentials {\r\n    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {\r\n        super({\r\n            requestCert: caCertificateProvider !== null,\r\n            rejectUnauthorized: requireClientCertificate,\r\n            ciphers: tls_helpers_1.CIPHER_SUITES\r\n        });\r\n        this.identityCertificateProvider = identityCertificateProvider;\r\n        this.caCertificateProvider = caCertificateProvider;\r\n        this.requireClientCertificate = requireClientCertificate;\r\n        this.latestCaUpdate = null;\r\n        this.latestIdentityUpdate = null;\r\n        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);\r\n        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);\r\n    }\r\n    _addWatcher(watcher) {\r\n        var _a;\r\n        if (this.getWatcherCount() === 0) {\r\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.addCaCertificateListener(this.caCertificateUpdateListener);\r\n            this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);\r\n        }\r\n        super._addWatcher(watcher);\r\n    }\r\n    _removeWatcher(watcher) {\r\n        var _a;\r\n        super._removeWatcher(watcher);\r\n        if (this.getWatcherCount() === 0) {\r\n            (_a = this.caCertificateProvider) === null || _a === void 0 ? void 0 : _a.removeCaCertificateListener(this.caCertificateUpdateListener);\r\n            this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);\r\n        }\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof CertificateProviderServerCredentials)) {\r\n            return false;\r\n        }\r\n        return (this.caCertificateProvider === other.caCertificateProvider &&\r\n            this.identityCertificateProvider === other.identityCertificateProvider &&\r\n            this.requireClientCertificate === other.requireClientCertificate);\r\n    }\r\n    calculateSecureContextOptions() {\r\n        var _a;\r\n        if (this.latestIdentityUpdate === null) {\r\n            return null;\r\n        }\r\n        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {\r\n            return null;\r\n        }\r\n        return {\r\n            ca: (_a = this.latestCaUpdate) === null || _a === void 0 ? void 0 : _a.caCertificate,\r\n            cert: [this.latestIdentityUpdate.certificate],\r\n            key: [this.latestIdentityUpdate.privateKey],\r\n        };\r\n    }\r\n    finalizeUpdate() {\r\n        const secureContextOptions = this.calculateSecureContextOptions();\r\n        this.updateSecureContextOptions(secureContextOptions);\r\n    }\r\n    handleCaCertificateUpdate(update) {\r\n        this.latestCaUpdate = update;\r\n        this.finalizeUpdate();\r\n    }\r\n    handleIdentityCertitificateUpdate(update) {\r\n        this.latestIdentityUpdate = update;\r\n        this.finalizeUpdate();\r\n    }\r\n}\r\nfunction createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {\r\n    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);\r\n}\r\nclass InterceptorServerCredentials extends ServerCredentials {\r\n    constructor(childCredentials, interceptors) {\r\n        super({});\r\n        this.childCredentials = childCredentials;\r\n        this.interceptors = interceptors;\r\n    }\r\n    _isSecure() {\r\n        return this.childCredentials._isSecure();\r\n    }\r\n    _equals(other) {\r\n        if (!(other instanceof InterceptorServerCredentials)) {\r\n            return false;\r\n        }\r\n        if (!(this.childCredentials._equals(other.childCredentials))) {\r\n            return false;\r\n        }\r\n        if (this.interceptors.length !== other.interceptors.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.interceptors.length; i++) {\r\n            if (this.interceptors[i] !== other.interceptors[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _getInterceptors() {\r\n        return this.interceptors;\r\n    }\r\n    _addWatcher(watcher) {\r\n        this.childCredentials._addWatcher(watcher);\r\n    }\r\n    _removeWatcher(watcher) {\r\n        this.childCredentials._removeWatcher(watcher);\r\n    }\r\n    _getConstructorOptions() {\r\n        return this.childCredentials._getConstructorOptions();\r\n    }\r\n    _getSecureContextOptions() {\r\n        return this.childCredentials._getSecureContextOptions();\r\n    }\r\n}\r\nfunction createServerCredentialsWithInterceptors(credentials, interceptors) {\r\n    return new InterceptorServerCredentials(credentials, interceptors);\r\n}\r\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGtEQUFrRDtBQUNsRCwrQ0FBK0M7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsa0ZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzP2Q4NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSB2b2lkIDA7XHJcbmV4cG9ydHMuY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzID0gY3JlYXRlQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzO1xyXG5leHBvcnRzLmNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9ycyA9IGNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9ycztcclxuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xyXG5jbGFzcyBTZXJ2ZXJDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnMgPSBzZXJ2ZXJDb25zdHJ1Y3Rvck9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy53YXRjaGVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmxhdGVzdENvbnRleHRPcHRpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdENvbnRleHRPcHRpb25zID0gY29udGV4dE9wdGlvbnMgIT09IG51bGwgJiYgY29udGV4dE9wdGlvbnMgIT09IHZvaWQgMCA/IGNvbnRleHRPcHRpb25zIDogbnVsbDtcclxuICAgIH1cclxuICAgIF9hZGRXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgICAgICB0aGlzLndhdGNoZXJzLmFkZCh3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgICAgICB0aGlzLndhdGNoZXJzLmRlbGV0ZSh3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIGdldFdhdGNoZXJDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53YXRjaGVycy5zaXplO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q29udGV4dE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlciBvZiB0aGlzLndhdGNoZXJzKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXIodGhpcy5sYXRlc3RDb250ZXh0T3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnN0cnVjdG9yT3B0aW9ucyAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIF9nZXRTZWN1cmVDb250ZXh0T3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RDb250ZXh0T3B0aW9ucztcclxuICAgIH1cclxuICAgIF9nZXRDb25zdHJ1Y3Rvck9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29uc3RydWN0b3JPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgX2dldEludGVyY2VwdG9ycygpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywga2V5Q2VydFBhaXJzLCBjaGVja0NsaWVudENlcnRpZmljYXRlID0gZmFsc2UpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdENlcnRzIG11c3QgYmUgbnVsbCBvciBhIEJ1ZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlDZXJ0UGFpcnMgbXVzdCBiZSBhbiBhcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja0NsaWVudENlcnRpZmljYXRlIG11c3QgYmUgYSBib29sZWFuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcclxuICAgICAgICBjb25zdCBrZXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNlcnRQYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGFpciA9PT0gbnVsbCB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dIG11c3QgYmUgYW4gb2JqZWN0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5wcml2YXRlX2tleSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLnByaXZhdGVfa2V5IG11c3QgYmUgYSBCdWZmZXJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLmNlcnRfY2hhaW4pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5jZXJ0X2NoYWluIG11c3QgYmUgYSBCdWZmZXJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjZXJ0LnB1c2gocGFpci5jZXJ0X2NoYWluKTtcclxuICAgICAgICAgICAga2V5LnB1c2gocGFpci5wcml2YXRlX2tleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgICAgICByZXF1ZXN0Q2VydDogY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSxcclxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgY2E6IChfYSA9IHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiByb290Q2VydHMgIT09IHZvaWQgMCA/IHJvb3RDZXJ0cyA6ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2VydCxcclxuICAgICAgICAgICAga2V5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBTZXJ2ZXJDcmVkZW50aWFscztcclxuY2xhc3MgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKG51bGwpO1xyXG4gICAgfVxyXG4gICAgX2dldFNldHRpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvck9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoY29uc3RydWN0b3JPcHRpb25zLCBjb250ZXh0T3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdHJ1Y3Rvck9wdGlvbnMpLCBjb250ZXh0T3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBlcXVhbGl0eSBieSBjaGVja2luZyB0aGUgb3B0aW9ucyB0aGF0IGFyZSBhY3R1YWxseSBzZXQgYnlcclxuICAgICAqIGNyZWF0ZVNzbC5cclxuICAgICAqIEBwYXJhbSBvdGhlclxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvcHRpb25zLmNhIGVxdWFsaXR5IGNoZWNrXHJcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLm9wdGlvbnMuY2EpICYmIEJ1ZmZlci5pc0J1ZmZlcihvdGhlci5vcHRpb25zLmNhKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jYS5lcXVhbHMob3RoZXIub3B0aW9ucy5jYSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYSAhPT0gb3RoZXIub3B0aW9ucy5jYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9wdGlvbnMuY2VydCBlcXVhbGl0eSBjaGVja1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5jZXJ0KSAmJiBBcnJheS5pc0FycmF5KG90aGVyLm9wdGlvbnMuY2VydCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZXJ0Lmxlbmd0aCAhPT0gb3RoZXIub3B0aW9ucy5jZXJ0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmNlcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNDZXJ0ID0gdGhpcy5vcHRpb25zLmNlcnRbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNlcnQgPSBvdGhlci5vcHRpb25zLmNlcnRbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXNDZXJ0KSAmJiBCdWZmZXIuaXNCdWZmZXIob3RoZXJDZXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpc0NlcnQuZXF1YWxzKG90aGVyQ2VydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ2VydCAhPT0gb3RoZXJDZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2VydCAhPT0gb3RoZXIub3B0aW9ucy5jZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3B0aW9ucy5rZXkgZXF1YWxpdHkgY2hlY2tcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMua2V5KSAmJiBBcnJheS5pc0FycmF5KG90aGVyLm9wdGlvbnMua2V5KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleS5sZW5ndGggIT09IG90aGVyLm9wdGlvbnMua2V5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmtleS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0tleSA9IHRoaXMub3B0aW9ucy5rZXlbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlcktleSA9IG90aGVyLm9wdGlvbnMua2V5W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzS2V5KSAmJiBCdWZmZXIuaXNCdWZmZXIob3RoZXJLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzS2V5LmVxdWFscyhvdGhlcktleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzS2V5ICE9PSBvdGhlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtleSAhPT0gb3RoZXIub3B0aW9ucy5rZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvcHRpb25zLnJlcXVlc3RDZXJ0IGVxdWFsaXR5IGNoZWNrXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0Q2VydCAhPT0gb3RoZXIub3B0aW9ucy5yZXF1ZXN0Q2VydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIGNpcGhlcnMgaXMgZGVyaXZlZCBmcm9tIGEgdmFsdWUgdGhhdCBpcyBjb25zdGFudCBmb3IgdGhlIHByb2Nlc3MsIHNvIG5vXHJcbiAgICAgICAgICogZXF1YWxpdHkgY2hlY2sgaXMgbmVlZGVkLiAqL1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENlcnRpZmljYXRlUHJvdmlkZXJTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciwgY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCByZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUpIHtcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjYUNlcnRpZmljYXRlUHJvdmlkZXIgIT09IG51bGwsXHJcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogcmVxdWlyZUNsaWVudENlcnRpZmljYXRlLFxyXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciA9IGlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVQcm92aWRlciA9IGNhQ2VydGlmaWNhdGVQcm92aWRlcjtcclxuICAgICAgICB0aGlzLnJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSA9IHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZTtcclxuICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNhQ2VydGlmaWNhdGVVcGRhdGVMaXN0ZW5lciA9IHRoaXMuaGFuZGxlQ2FDZXJ0aWZpY2F0ZVVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHlDZXJ0aWZpY2F0ZVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVJZGVudGl0eUNlcnRpdGlmaWNhdGVVcGRhdGUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIF9hZGRXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2F0Y2hlckNvdW50KCkgPT09IDApIHtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlci5hZGRJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fYWRkV2F0Y2hlcih3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIuX3JlbW92ZVdhdGNoZXIod2F0Y2hlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2F0Y2hlckNvdW50KCkgPT09IDApIHtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDYUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5jYUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlci5yZW1vdmVJZGVudGl0eUNlcnRpZmljYXRlTGlzdGVuZXIodGhpcy5pZGVudGl0eUNlcnRpZmljYXRlVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQ2VydGlmaWNhdGVQcm92aWRlclNlcnZlckNyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgPT09IG90aGVyLmNhQ2VydGlmaWNhdGVQcm92aWRlciAmJlxyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5Q2VydGlmaWNhdGVQcm92aWRlciA9PT0gb3RoZXIuaWRlbnRpdHlDZXJ0aWZpY2F0ZVByb3ZpZGVyICYmXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUNsaWVudENlcnRpZmljYXRlID09PSBvdGhlci5yZXF1aXJlQ2xpZW50Q2VydGlmaWNhdGUpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jYUNlcnRpZmljYXRlUHJvdmlkZXIgIT09IG51bGwgJiYgdGhpcy5sYXRlc3RDYVVwZGF0ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2E6IChfYSA9IHRoaXMubGF0ZXN0Q2FVcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYUNlcnRpZmljYXRlLFxyXG4gICAgICAgICAgICBjZXJ0OiBbdGhpcy5sYXRlc3RJZGVudGl0eVVwZGF0ZS5jZXJ0aWZpY2F0ZV0sXHJcbiAgICAgICAgICAgIGtleTogW3RoaXMubGF0ZXN0SWRlbnRpdHlVcGRhdGUucHJpdmF0ZUtleV0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZpbmFsaXplVXBkYXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlY3VyZUNvbnRleHRPcHRpb25zID0gdGhpcy5jYWxjdWxhdGVTZWN1cmVDb250ZXh0T3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2VjdXJlQ29udGV4dE9wdGlvbnMoc2VjdXJlQ29udGV4dE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2FDZXJ0aWZpY2F0ZVVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICB0aGlzLmxhdGVzdENhVXBkYXRlID0gdXBkYXRlO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVVcGRhdGUoKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUlkZW50aXR5Q2VydGl0aWZpY2F0ZVVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICB0aGlzLmxhdGVzdElkZW50aXR5VXBkYXRlID0gdXBkYXRlO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVVcGRhdGUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHMoY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZVByb3ZpZGVyU2VydmVyQ3JlZGVudGlhbHMoY2FDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBpZGVudGl0eUNlcnRpZmljYXRlUHJvdmlkZXIsIHJlcXVpcmVDbGllbnRDZXJ0aWZpY2F0ZSk7XHJcbn1cclxuY2xhc3MgSW50ZXJjZXB0b3JTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkQ3JlZGVudGlhbHMsIGludGVyY2VwdG9ycykge1xyXG4gICAgICAgIHN1cGVyKHt9KTtcclxuICAgICAgICB0aGlzLmNoaWxkQ3JlZGVudGlhbHMgPSBjaGlsZENyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0b3JzO1xyXG4gICAgfVxyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3JlZGVudGlhbHMuX2lzU2VjdXJlKCk7XHJcbiAgICB9XHJcbiAgICBfZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBJbnRlcmNlcHRvclNlcnZlckNyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRoaXMuY2hpbGRDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNoaWxkQ3JlZGVudGlhbHMpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmludGVyY2VwdG9ycy5sZW5ndGggIT09IG90aGVyLmludGVyY2VwdG9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW50ZXJjZXB0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyY2VwdG9yc1tpXSAhPT0gb3RoZXIuaW50ZXJjZXB0b3JzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBfZ2V0SW50ZXJjZXB0b3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVyY2VwdG9ycztcclxuICAgIH1cclxuICAgIF9hZGRXYXRjaGVyKHdhdGNoZXIpIHtcclxuICAgICAgICB0aGlzLmNoaWxkQ3JlZGVudGlhbHMuX2FkZFdhdGNoZXIod2F0Y2hlcik7XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlV2F0Y2hlcih3YXRjaGVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9yZW1vdmVXYXRjaGVyKHdhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbnN0cnVjdG9yT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9nZXRDb25zdHJ1Y3Rvck9wdGlvbnMoKTtcclxuICAgIH1cclxuICAgIF9nZXRTZWN1cmVDb250ZXh0T3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZENyZWRlbnRpYWxzLl9nZXRTZWN1cmVDb250ZXh0T3B0aW9ucygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNyZWRlbnRpYWxzV2l0aEludGVyY2VwdG9ycyhjcmVkZW50aWFscywgaW50ZXJjZXB0b3JzKSB7XHJcbiAgICByZXR1cm4gbmV3IEludGVyY2VwdG9yU2VydmVyQ3JlZGVudGlhbHMoY3JlZGVudGlhbHMsIGludGVyY2VwdG9ycyk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2024 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = void 0;\r\nexports.isInterceptingServerListener = isInterceptingServerListener;\r\nexports.getServerInterceptingCall = getServerInterceptingCall;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'server_call';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nclass ServerListenerBuilder {\r\n    constructor() {\r\n        this.metadata = undefined;\r\n        this.message = undefined;\r\n        this.halfClose = undefined;\r\n        this.cancel = undefined;\r\n    }\r\n    withOnReceiveMetadata(onReceiveMetadata) {\r\n        this.metadata = onReceiveMetadata;\r\n        return this;\r\n    }\r\n    withOnReceiveMessage(onReceiveMessage) {\r\n        this.message = onReceiveMessage;\r\n        return this;\r\n    }\r\n    withOnReceiveHalfClose(onReceiveHalfClose) {\r\n        this.halfClose = onReceiveHalfClose;\r\n        return this;\r\n    }\r\n    withOnCancel(onCancel) {\r\n        this.cancel = onCancel;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            onReceiveMetadata: this.metadata,\r\n            onReceiveMessage: this.message,\r\n            onReceiveHalfClose: this.halfClose,\r\n            onCancel: this.cancel,\r\n        };\r\n    }\r\n}\r\nexports.ServerListenerBuilder = ServerListenerBuilder;\r\nfunction isInterceptingServerListener(listener) {\r\n    return (listener.onReceiveMetadata !== undefined &&\r\n        listener.onReceiveMetadata.length === 1);\r\n}\r\nclass InterceptingServerListenerImpl {\r\n    constructor(listener, nextListener) {\r\n        this.listener = listener;\r\n        this.nextListener = nextListener;\r\n        /**\r\n         * Once the call is cancelled, ignore all other events.\r\n         */\r\n        this.cancelled = false;\r\n        this.processingMetadata = false;\r\n        this.hasPendingMessage = false;\r\n        this.pendingMessage = null;\r\n        this.processingMessage = false;\r\n        this.hasPendingHalfClose = false;\r\n    }\r\n    processPendingMessage() {\r\n        if (this.hasPendingMessage) {\r\n            this.nextListener.onReceiveMessage(this.pendingMessage);\r\n            this.pendingMessage = null;\r\n            this.hasPendingMessage = false;\r\n        }\r\n    }\r\n    processPendingHalfClose() {\r\n        if (this.hasPendingHalfClose) {\r\n            this.nextListener.onReceiveHalfClose();\r\n            this.hasPendingHalfClose = false;\r\n        }\r\n    }\r\n    onReceiveMetadata(metadata) {\r\n        if (this.cancelled) {\r\n            return;\r\n        }\r\n        this.processingMetadata = true;\r\n        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {\r\n            this.processingMetadata = false;\r\n            if (this.cancelled) {\r\n                return;\r\n            }\r\n            this.nextListener.onReceiveMetadata(interceptedMetadata);\r\n            this.processPendingMessage();\r\n            this.processPendingHalfClose();\r\n        });\r\n    }\r\n    onReceiveMessage(message) {\r\n        if (this.cancelled) {\r\n            return;\r\n        }\r\n        this.processingMessage = true;\r\n        this.listener.onReceiveMessage(message, msg => {\r\n            this.processingMessage = false;\r\n            if (this.cancelled) {\r\n                return;\r\n            }\r\n            if (this.processingMetadata) {\r\n                this.pendingMessage = msg;\r\n                this.hasPendingMessage = true;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveMessage(msg);\r\n                this.processPendingHalfClose();\r\n            }\r\n        });\r\n    }\r\n    onReceiveHalfClose() {\r\n        if (this.cancelled) {\r\n            return;\r\n        }\r\n        this.listener.onReceiveHalfClose(() => {\r\n            if (this.cancelled) {\r\n                return;\r\n            }\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.hasPendingHalfClose = true;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveHalfClose();\r\n            }\r\n        });\r\n    }\r\n    onCancel() {\r\n        this.cancelled = true;\r\n        this.listener.onCancel();\r\n        this.nextListener.onCancel();\r\n    }\r\n}\r\nclass ResponderBuilder {\r\n    constructor() {\r\n        this.start = undefined;\r\n        this.metadata = undefined;\r\n        this.message = undefined;\r\n        this.status = undefined;\r\n    }\r\n    withStart(start) {\r\n        this.start = start;\r\n        return this;\r\n    }\r\n    withSendMetadata(sendMetadata) {\r\n        this.metadata = sendMetadata;\r\n        return this;\r\n    }\r\n    withSendMessage(sendMessage) {\r\n        this.message = sendMessage;\r\n        return this;\r\n    }\r\n    withSendStatus(sendStatus) {\r\n        this.status = sendStatus;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            start: this.start,\r\n            sendMetadata: this.metadata,\r\n            sendMessage: this.message,\r\n            sendStatus: this.status,\r\n        };\r\n    }\r\n}\r\nexports.ResponderBuilder = ResponderBuilder;\r\nconst defaultServerListener = {\r\n    onReceiveMetadata: (metadata, next) => {\r\n        next(metadata);\r\n    },\r\n    onReceiveMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    onReceiveHalfClose: next => {\r\n        next();\r\n    },\r\n    onCancel: () => { },\r\n};\r\nconst defaultResponder = {\r\n    start: next => {\r\n        next();\r\n    },\r\n    sendMetadata: (metadata, next) => {\r\n        next(metadata);\r\n    },\r\n    sendMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    sendStatus: (status, next) => {\r\n        next(status);\r\n    },\r\n};\r\nclass ServerInterceptingCall {\r\n    constructor(nextCall, responder) {\r\n        var _a, _b, _c, _d;\r\n        this.nextCall = nextCall;\r\n        this.processingMetadata = false;\r\n        this.sentMetadata = false;\r\n        this.processingMessage = false;\r\n        this.pendingMessage = null;\r\n        this.pendingMessageCallback = null;\r\n        this.pendingStatus = null;\r\n        this.responder = {\r\n            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,\r\n            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,\r\n            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,\r\n            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus,\r\n        };\r\n    }\r\n    processPendingMessage() {\r\n        if (this.pendingMessageCallback) {\r\n            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);\r\n            this.pendingMessage = null;\r\n            this.pendingMessageCallback = null;\r\n        }\r\n    }\r\n    processPendingStatus() {\r\n        if (this.pendingStatus) {\r\n            this.nextCall.sendStatus(this.pendingStatus);\r\n            this.pendingStatus = null;\r\n        }\r\n    }\r\n    start(listener) {\r\n        this.responder.start(interceptedListener => {\r\n            var _a, _b, _c, _d;\r\n            const fullInterceptedListener = {\r\n                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,\r\n                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,\r\n                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,\r\n                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel,\r\n            };\r\n            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);\r\n            this.nextCall.start(finalInterceptingListener);\r\n        });\r\n    }\r\n    sendMetadata(metadata) {\r\n        this.processingMetadata = true;\r\n        this.sentMetadata = true;\r\n        this.responder.sendMetadata(metadata, interceptedMetadata => {\r\n            this.processingMetadata = false;\r\n            this.nextCall.sendMetadata(interceptedMetadata);\r\n            this.processPendingMessage();\r\n            this.processPendingStatus();\r\n        });\r\n    }\r\n    sendMessage(message, callback) {\r\n        this.processingMessage = true;\r\n        if (!this.sentMetadata) {\r\n            this.sendMetadata(new metadata_1.Metadata());\r\n        }\r\n        this.responder.sendMessage(message, interceptedMessage => {\r\n            this.processingMessage = false;\r\n            if (this.processingMetadata) {\r\n                this.pendingMessage = interceptedMessage;\r\n                this.pendingMessageCallback = callback;\r\n            }\r\n            else {\r\n                this.nextCall.sendMessage(interceptedMessage, callback);\r\n            }\r\n        });\r\n    }\r\n    sendStatus(status) {\r\n        this.responder.sendStatus(status, interceptedStatus => {\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.pendingStatus = interceptedStatus;\r\n            }\r\n            else {\r\n                this.nextCall.sendStatus(interceptedStatus);\r\n            }\r\n        });\r\n    }\r\n    startRead() {\r\n        this.nextCall.startRead();\r\n    }\r\n    getPeer() {\r\n        return this.nextCall.getPeer();\r\n    }\r\n    getDeadline() {\r\n        return this.nextCall.getDeadline();\r\n    }\r\n    getHost() {\r\n        return this.nextCall.getHost();\r\n    }\r\n}\r\nexports.ServerInterceptingCall = ServerInterceptingCall;\r\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\r\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\r\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\r\nconst GRPC_STATUS_HEADER = 'grpc-status';\r\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\r\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\r\nconst deadlineUnitsToMs = {\r\n    H: 3600000,\r\n    M: 60000,\r\n    S: 1000,\r\n    m: 1,\r\n    u: 0.001,\r\n    n: 0.000001,\r\n};\r\nconst defaultCompressionHeaders = {\r\n    // TODO(cjihrig): Remove these encoding headers from the default response\r\n    // once compression is integrated.\r\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\r\n    [GRPC_ENCODING_HEADER]: 'identity',\r\n};\r\nconst defaultResponseHeaders = {\r\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\r\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\r\n};\r\nconst defaultResponseOptions = {\r\n    waitForTrailers: true,\r\n};\r\nclass BaseServerInterceptingCall {\r\n    constructor(stream, headers, callEventTracker, handler, options) {\r\n        var _a;\r\n        this.stream = stream;\r\n        this.callEventTracker = callEventTracker;\r\n        this.handler = handler;\r\n        this.listener = null;\r\n        this.deadlineTimer = null;\r\n        this.deadline = Infinity;\r\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\r\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        this.cancelled = false;\r\n        this.metadataSent = false;\r\n        this.wantTrailers = false;\r\n        this.cancelNotified = false;\r\n        this.incomingEncoding = 'identity';\r\n        this.readQueue = [];\r\n        this.isReadPending = false;\r\n        this.receivedHalfClose = false;\r\n        this.streamEnded = false;\r\n        this.stream.once('error', (err) => {\r\n            /* We need an error handler to avoid uncaught error event exceptions, but\r\n             * there is nothing we can reasonably do here. Any error event should\r\n             * have a corresponding close event, which handles emitting the cancelled\r\n             * event. And the stream is now in a bad state, so we can't reasonably\r\n             * expect to be able to send an error over it. */\r\n        });\r\n        this.stream.once('close', () => {\r\n            var _a;\r\n            trace('Request to method ' +\r\n                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\r\n                ' stream closed with rstCode ' +\r\n                this.stream.rstCode);\r\n            if (this.callEventTracker && !this.streamEnded) {\r\n                this.streamEnded = true;\r\n                this.callEventTracker.onStreamEnd(false);\r\n                this.callEventTracker.onCallEnd({\r\n                    code: constants_1.Status.CANCELLED,\r\n                    details: 'Stream closed before sending status',\r\n                    metadata: null,\r\n                });\r\n            }\r\n            this.notifyOnCancel();\r\n        });\r\n        this.stream.on('data', (data) => {\r\n            this.handleDataFrame(data);\r\n        });\r\n        this.stream.pause();\r\n        this.stream.on('end', () => {\r\n            this.handleEndEvent();\r\n        });\r\n        if ('grpc.max_send_message_length' in options) {\r\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\r\n        }\r\n        if ('grpc.max_receive_message_length' in options) {\r\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\r\n        }\r\n        this.host = (_a = headers[':authority']) !== null && _a !== void 0 ? _a : headers.host;\r\n        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\r\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n        if (logging.isTracerEnabled(TRACER_NAME)) {\r\n            trace('Request to ' +\r\n                this.handler.path +\r\n                ' received headers ' +\r\n                JSON.stringify(metadata.toJSON()));\r\n        }\r\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\r\n        if (timeoutHeader.length > 0) {\r\n            this.handleTimeoutHeader(timeoutHeader[0]);\r\n        }\r\n        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);\r\n        if (encodingHeader.length > 0) {\r\n            this.incomingEncoding = encodingHeader[0];\r\n        }\r\n        // Remove several headers that should not be propagated to the application\r\n        metadata.remove(GRPC_TIMEOUT_HEADER);\r\n        metadata.remove(GRPC_ENCODING_HEADER);\r\n        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);\r\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\r\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\r\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\r\n        this.metadata = metadata;\r\n    }\r\n    handleTimeoutHeader(timeoutHeader) {\r\n        const match = timeoutHeader.toString().match(DEADLINE_REGEX);\r\n        if (match === null) {\r\n            const status = {\r\n                code: constants_1.Status.INTERNAL,\r\n                details: `Invalid ${GRPC_TIMEOUT_HEADER} value \"${timeoutHeader}\"`,\r\n                metadata: null,\r\n            };\r\n            // Wait for the constructor to complete before sending the error.\r\n            process.nextTick(() => {\r\n                this.sendStatus(status);\r\n            });\r\n            return;\r\n        }\r\n        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\r\n        const now = new Date();\r\n        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\r\n        this.deadlineTimer = setTimeout(() => {\r\n            const status = {\r\n                code: constants_1.Status.DEADLINE_EXCEEDED,\r\n                details: 'Deadline exceeded',\r\n                metadata: null,\r\n            };\r\n            this.sendStatus(status);\r\n        }, timeout);\r\n    }\r\n    checkCancelled() {\r\n        /* In some cases the stream can become destroyed before the close event\r\n         * fires. That creates a race condition that this check works around */\r\n        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {\r\n            this.notifyOnCancel();\r\n            this.cancelled = true;\r\n        }\r\n        return this.cancelled;\r\n    }\r\n    notifyOnCancel() {\r\n        if (this.cancelNotified) {\r\n            return;\r\n        }\r\n        this.cancelNotified = true;\r\n        this.cancelled = true;\r\n        process.nextTick(() => {\r\n            var _a;\r\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();\r\n        });\r\n        if (this.deadlineTimer) {\r\n            clearTimeout(this.deadlineTimer);\r\n        }\r\n        // Flush incoming data frames\r\n        this.stream.resume();\r\n    }\r\n    /**\r\n     * A server handler can start sending messages without explicitly sending\r\n     * metadata. In that case, we need to send headers before sending any\r\n     * messages. This function does that if necessary.\r\n     */\r\n    maybeSendMetadata() {\r\n        if (!this.metadataSent) {\r\n            this.sendMetadata(new metadata_1.Metadata());\r\n        }\r\n    }\r\n    /**\r\n     * Serialize a message to a length-delimited byte string.\r\n     * @param value\r\n     * @returns\r\n     */\r\n    serializeMessage(value) {\r\n        const messageBuffer = this.handler.serialize(value);\r\n        const byteLength = messageBuffer.byteLength;\r\n        const output = Buffer.allocUnsafe(byteLength + 5);\r\n        /* Note: response compression is currently not supported, so this\r\n         * compressed bit is always 0. */\r\n        output.writeUInt8(0, 0);\r\n        output.writeUInt32BE(byteLength, 1);\r\n        messageBuffer.copy(output, 5);\r\n        return output;\r\n    }\r\n    decompressMessage(message, encoding) {\r\n        const messageContents = message.subarray(5);\r\n        if (encoding === 'identity') {\r\n            return messageContents;\r\n        }\r\n        else if (encoding === 'deflate' || encoding === 'gzip') {\r\n            let decompresser;\r\n            if (encoding === 'deflate') {\r\n                decompresser = zlib.createInflate();\r\n            }\r\n            else {\r\n                decompresser = zlib.createGunzip();\r\n            }\r\n            return new Promise((resolve, reject) => {\r\n                let totalLength = 0;\r\n                const messageParts = [];\r\n                decompresser.on('data', (chunk) => {\r\n                    messageParts.push(chunk);\r\n                    totalLength += chunk.byteLength;\r\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\r\n                        decompresser.destroy();\r\n                        reject({\r\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\r\n                        });\r\n                    }\r\n                });\r\n                decompresser.on('end', () => {\r\n                    resolve(Buffer.concat(messageParts));\r\n                });\r\n                decompresser.write(messageContents);\r\n                decompresser.end();\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject({\r\n                code: constants_1.Status.UNIMPLEMENTED,\r\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`,\r\n            });\r\n        }\r\n    }\r\n    async decompressAndMaybePush(queueEntry) {\r\n        if (queueEntry.type !== 'COMPRESSED') {\r\n            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);\r\n        }\r\n        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;\r\n        const compressedMessageEncoding = compressed\r\n            ? this.incomingEncoding\r\n            : 'identity';\r\n        let decompressedMessage;\r\n        try {\r\n            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);\r\n        }\r\n        catch (err) {\r\n            this.sendStatus(err);\r\n            return;\r\n        }\r\n        try {\r\n            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);\r\n        }\r\n        catch (err) {\r\n            this.sendStatus({\r\n                code: constants_1.Status.INTERNAL,\r\n                details: `Error deserializing request: ${err.message}`,\r\n            });\r\n            return;\r\n        }\r\n        queueEntry.type = 'READABLE';\r\n        this.maybePushNextMessage();\r\n    }\r\n    maybePushNextMessage() {\r\n        if (this.listener &&\r\n            this.isReadPending &&\r\n            this.readQueue.length > 0 &&\r\n            this.readQueue[0].type !== 'COMPRESSED') {\r\n            this.isReadPending = false;\r\n            const nextQueueEntry = this.readQueue.shift();\r\n            if (nextQueueEntry.type === 'READABLE') {\r\n                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);\r\n            }\r\n            else {\r\n                // nextQueueEntry.type === 'HALF_CLOSE'\r\n                this.listener.onReceiveHalfClose();\r\n            }\r\n        }\r\n    }\r\n    handleDataFrame(data) {\r\n        var _a;\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        trace('Request to ' +\r\n            this.handler.path +\r\n            ' received data frame of size ' +\r\n            data.length);\r\n        let rawMessages;\r\n        try {\r\n            rawMessages = this.decoder.write(data);\r\n        }\r\n        catch (e) {\r\n            this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });\r\n            return;\r\n        }\r\n        for (const messageBytes of rawMessages) {\r\n            this.stream.pause();\r\n            const queueEntry = {\r\n                type: 'COMPRESSED',\r\n                compressedMessage: messageBytes,\r\n                parsedMessage: null,\r\n            };\r\n            this.readQueue.push(queueEntry);\r\n            this.decompressAndMaybePush(queueEntry);\r\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();\r\n        }\r\n    }\r\n    handleEndEvent() {\r\n        this.readQueue.push({\r\n            type: 'HALF_CLOSE',\r\n            compressedMessage: null,\r\n            parsedMessage: null,\r\n        });\r\n        this.receivedHalfClose = true;\r\n        this.maybePushNextMessage();\r\n    }\r\n    start(listener) {\r\n        trace('Request to ' + this.handler.path + ' start called');\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        this.listener = listener;\r\n        listener.onReceiveMetadata(this.metadata);\r\n    }\r\n    sendMetadata(metadata) {\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        if (this.metadataSent) {\r\n            return;\r\n        }\r\n        this.metadataSent = true;\r\n        const custom = metadata ? metadata.toHttp2Headers() : null;\r\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\r\n        this.stream.respond(headers, defaultResponseOptions);\r\n    }\r\n    sendMessage(message, callback) {\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        let response;\r\n        try {\r\n            response = this.serializeMessage(message);\r\n        }\r\n        catch (e) {\r\n            this.sendStatus({\r\n                code: constants_1.Status.INTERNAL,\r\n                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,\r\n                metadata: null,\r\n            });\r\n            return;\r\n        }\r\n        if (this.maxSendMessageSize !== -1 &&\r\n            response.length - 5 > this.maxSendMessageSize) {\r\n            this.sendStatus({\r\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,\r\n                metadata: null,\r\n            });\r\n            return;\r\n        }\r\n        this.maybeSendMetadata();\r\n        trace('Request to ' +\r\n            this.handler.path +\r\n            ' sent data frame of size ' +\r\n            response.length);\r\n        this.stream.write(response, error => {\r\n            var _a;\r\n            if (error) {\r\n                this.sendStatus({\r\n                    code: constants_1.Status.INTERNAL,\r\n                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,\r\n                    metadata: null,\r\n                });\r\n                return;\r\n            }\r\n            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\r\n            callback();\r\n        });\r\n    }\r\n    sendStatus(status) {\r\n        var _a, _b;\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        trace('Request to method ' +\r\n            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\r\n            ' ended with status code: ' +\r\n            constants_1.Status[status.code] +\r\n            ' details: ' +\r\n            status.details);\r\n        if (this.metadataSent) {\r\n            if (!this.wantTrailers) {\r\n                this.wantTrailers = true;\r\n                this.stream.once('wantTrailers', () => {\r\n                    var _a;\r\n                    if (this.callEventTracker && !this.streamEnded) {\r\n                        this.streamEnded = true;\r\n                        this.callEventTracker.onStreamEnd(true);\r\n                        this.callEventTracker.onCallEnd(status);\r\n                    }\r\n                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a = status.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\r\n                    this.stream.sendTrailers(trailersToSend);\r\n                    this.notifyOnCancel();\r\n                });\r\n                this.stream.end();\r\n            }\r\n            else {\r\n                this.notifyOnCancel();\r\n            }\r\n        }\r\n        else {\r\n            if (this.callEventTracker && !this.streamEnded) {\r\n                this.streamEnded = true;\r\n                this.callEventTracker.onStreamEnd(true);\r\n                this.callEventTracker.onCallEnd(status);\r\n            }\r\n            // Trailers-only response\r\n            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\r\n            this.stream.respond(trailersToSend, { endStream: true });\r\n            this.notifyOnCancel();\r\n        }\r\n    }\r\n    startRead() {\r\n        trace('Request to ' + this.handler.path + ' startRead called');\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        this.isReadPending = true;\r\n        if (this.readQueue.length === 0) {\r\n            if (!this.receivedHalfClose) {\r\n                this.stream.resume();\r\n            }\r\n        }\r\n        else {\r\n            this.maybePushNextMessage();\r\n        }\r\n    }\r\n    getPeer() {\r\n        var _a;\r\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\r\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\r\n            if (socket.remotePort) {\r\n                return `${socket.remoteAddress}:${socket.remotePort}`;\r\n            }\r\n            else {\r\n                return socket.remoteAddress;\r\n            }\r\n        }\r\n        else {\r\n            return 'unknown';\r\n        }\r\n    }\r\n    getDeadline() {\r\n        return this.deadline;\r\n    }\r\n    getHost() {\r\n        return this.host;\r\n    }\r\n}\r\nexports.BaseServerInterceptingCall = BaseServerInterceptingCall;\r\nfunction getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {\r\n    const methodDefinition = {\r\n        path: handler.path,\r\n        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',\r\n        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',\r\n        requestDeserialize: handler.deserialize,\r\n        responseSerialize: handler.serialize,\r\n    };\r\n    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);\r\n    return interceptors.reduce((call, interceptor) => {\r\n        return interceptor(methodDefinition, call);\r\n    }, baseCall);\r\n}\r\n//# sourceMappingURL=server-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDhCQUE4QixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QjtBQUM5SCxvQ0FBb0M7QUFDcEMsaUNBQWlDO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBUztBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUIsU0FBUyxjQUFjO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDJCQUEyQjtBQUM1SCx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFNBQVM7QUFDNUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFpRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdDQUFnQztBQUN4RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCLE1BQU0sd0JBQXdCO0FBQ3pHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0M7QUFDM0Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUZBQXFGO0FBQ2hKO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUscUZBQXFGO0FBQ3RKLGtEQUFrRCxpQkFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsR0FBRyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci1pbnRlcmNlcHRvcnMuanM/MmRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjQgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5CYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVzcG9uZGVyQnVpbGRlciA9IGV4cG9ydHMuU2VydmVyTGlzdGVuZXJCdWlsZGVyID0gdm9pZCAwO1xyXG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nU2VydmVyTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVyO1xyXG5leHBvcnRzLmdldFNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBnZXRTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcclxuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xyXG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XHJcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5jbGFzcyBTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB3aXRoT25SZWNlaXZlTWV0YWRhdGEob25SZWNlaXZlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhPblJlY2VpdmVIYWxmQ2xvc2Uob25SZWNlaXZlSGFsZkNsb3NlKSB7XHJcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSBvblJlY2VpdmVIYWxmQ2xvc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoT25DYW5jZWwob25DYW5jZWwpIHtcclxuICAgICAgICB0aGlzLmNhbmNlbCA9IG9uQ2FuY2VsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYnVpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcclxuICAgICAgICAgICAgb25DYW5jZWw6IHRoaXMuY2FuY2VsLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TZXJ2ZXJMaXN0ZW5lckJ1aWxkZXIgPSBTZXJ2ZXJMaXN0ZW5lckJ1aWxkZXI7XHJcbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nU2VydmVyTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgIHJldHVybiAobGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XHJcbn1cclxuY2xhc3MgSW50ZXJjZXB0aW5nU2VydmVyTGlzdGVuZXJJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVyLCBuZXh0TGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25jZSB0aGUgY2FsbCBpcyBjYW5jZWxsZWQsIGlnbm9yZSBhbGwgb3RoZXIgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgaW50ZXJjZXB0ZWRNZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKGludGVyY2VwdGVkTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwgbXNnID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtc2c7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25DYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIub25DYW5jZWwoKTtcclxuICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vbkNhbmNlbCgpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJlc3BvbmRlckJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHdpdGhTdGFydChzdGFydCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhTZW5kTWV0YWRhdGEoc2VuZE1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHNlbmRNZXRhZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhTZW5kTWVzc2FnZShzZW5kTWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgd2l0aFNlbmRTdGF0dXMoc2VuZFN0YXR1cykge1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gc2VuZFN0YXR1cztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGJ1aWxkKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxyXG4gICAgICAgICAgICBzZW5kTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHNlbmRTdGF0dXM6IHRoaXMuc3RhdHVzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZXNwb25kZXJCdWlsZGVyID0gUmVzcG9uZGVyQnVpbGRlcjtcclxuY29uc3QgZGVmYXVsdFNlcnZlckxpc3RlbmVyID0ge1xyXG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xyXG4gICAgfSxcclxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XHJcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcclxuICAgIH0sXHJcbiAgICBvblJlY2VpdmVIYWxmQ2xvc2U6IG5leHQgPT4ge1xyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH0sXHJcbiAgICBvbkNhbmNlbDogKCkgPT4geyB9LFxyXG59O1xyXG5jb25zdCBkZWZhdWx0UmVzcG9uZGVyID0ge1xyXG4gICAgc3RhcnQ6IG5leHQgPT4ge1xyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH0sXHJcbiAgICBzZW5kTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xyXG4gICAgfSxcclxuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQobWVzc2FnZSk7XHJcbiAgICB9LFxyXG4gICAgc2VuZFN0YXR1czogKHN0YXR1cywgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQoc3RhdHVzKTtcclxuICAgIH0sXHJcbn07XHJcbmNsYXNzIFNlcnZlckludGVyY2VwdGluZ0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IobmV4dENhbGwsIHJlc3BvbmRlcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNlbnRNZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXNwb25kZXIgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXNwb25kZXIgPT09IG51bGwgfHwgcmVzcG9uZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25kZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXNwb25kZXIuc3RhcnQsXHJcbiAgICAgICAgICAgIHNlbmRNZXRhZGF0YTogKF9iID0gcmVzcG9uZGVyID09PSBudWxsIHx8IHJlc3BvbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uZGVyLnNlbmRNZXRhZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlc3BvbmRlci5zZW5kTWV0YWRhdGEsXHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAoX2MgPSByZXNwb25kZXIgPT09IG51bGwgfHwgcmVzcG9uZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25kZXIuc2VuZE1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXNwb25kZXIuc2VuZE1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHNlbmRTdGF0dXM6IChfZCA9IHJlc3BvbmRlciA9PT0gbnVsbCB8fCByZXNwb25kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbmRlci5zZW5kU3RhdHVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0UmVzcG9uZGVyLnNlbmRTdGF0dXMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSwgdGhpcy5wZW5kaW5nTWVzc2FnZUNhbGxiYWNrKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1N0YXR1cykge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydChsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMucmVzcG9uZGVyLnN0YXJ0KGludGVyY2VwdGVkTGlzdGVuZXIgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRlZExpc3RlbmVyID0ge1xyXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYSA9IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0ZWRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFNlcnZlckxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9iID0gaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRlZExpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRlZExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRTZXJ2ZXJMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlOiAoX2MgPSBpbnRlcmNlcHRlZExpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGVkTGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0U2VydmVyTGlzdGVuZXIub25SZWNlaXZlSGFsZkNsb3NlLFxyXG4gICAgICAgICAgICAgICAgb25DYW5jZWw6IChfZCA9IGludGVyY2VwdGVkTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0ZWRMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0ZWRMaXN0ZW5lci5vbkNhbmNlbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFNlcnZlckxpc3RlbmVyLm9uQ2FuY2VsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbmV3IEludGVyY2VwdGluZ1NlcnZlckxpc3RlbmVySW1wbChmdWxsSW50ZXJjZXB0ZWRMaXN0ZW5lciwgbGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0KGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VudE1ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlc3BvbmRlci5zZW5kTWV0YWRhdGEobWV0YWRhdGEsIGludGVyY2VwdGVkTWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXRhZGF0YShpbnRlcmNlcHRlZE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoIXRoaXMuc2VudE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3BvbmRlci5zZW5kTWVzc2FnZShtZXNzYWdlLCBpbnRlcmNlcHRlZE1lc3NhZ2UgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IGludGVyY2VwdGVkTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZShpbnRlcmNlcHRlZE1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZFN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICB0aGlzLnJlc3BvbmRlci5zZW5kU3RhdHVzKHN0YXR1cywgaW50ZXJjZXB0ZWRTdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gaW50ZXJjZXB0ZWRTdGF0dXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRTdGF0dXMoaW50ZXJjZXB0ZWRTdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFJlYWQoKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVhZGxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0RGVhZGxpbmUoKTtcclxuICAgIH1cclxuICAgIGdldEhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0SG9zdCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVySW50ZXJjZXB0aW5nQ2FsbCA9IFNlcnZlckludGVyY2VwdGluZ0NhbGw7XHJcbmNvbnN0IEdSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUiA9ICdncnBjLWFjY2VwdC1lbmNvZGluZyc7XHJcbmNvbnN0IEdSUENfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtZW5jb2RpbmcnO1xyXG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XHJcbmNvbnN0IEdSUENfU1RBVFVTX0hFQURFUiA9ICdncnBjLXN0YXR1cyc7XHJcbmNvbnN0IEdSUENfVElNRU9VVF9IRUFERVIgPSAnZ3JwYy10aW1lb3V0JztcclxuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcclxuY29uc3QgZGVhZGxpbmVVbml0c1RvTXMgPSB7XHJcbiAgICBIOiAzNjAwMDAwLFxyXG4gICAgTTogNjAwMDAsXHJcbiAgICBTOiAxMDAwLFxyXG4gICAgbTogMSxcclxuICAgIHU6IDAuMDAxLFxyXG4gICAgbjogMC4wMDAwMDEsXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMgPSB7XHJcbiAgICAvLyBUT0RPKGNqaWhyaWcpOiBSZW1vdmUgdGhlc2UgZW5jb2RpbmcgaGVhZGVycyBmcm9tIHRoZSBkZWZhdWx0IHJlc3BvbnNlXHJcbiAgICAvLyBvbmNlIGNvbXByZXNzaW9uIGlzIGludGVncmF0ZWQuXHJcbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXHJcbiAgICBbR1JQQ19FTkNPRElOR19IRUFERVJdOiAnaWRlbnRpdHknLFxyXG59O1xyXG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xyXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfU1RBVFVTXTogaHR0cDIuY29uc3RhbnRzLkhUVFBfU1RBVFVTX09LLFxyXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nLFxyXG59O1xyXG5jb25zdCBkZWZhdWx0UmVzcG9uc2VPcHRpb25zID0ge1xyXG4gICAgd2FpdEZvclRyYWlsZXJzOiB0cnVlLFxyXG59O1xyXG5jbGFzcyBCYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcclxuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxOb3RpZmllZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5jb21pbmdFbmNvZGluZyA9ICdpZGVudGl0eSc7XHJcbiAgICAgICAgdGhpcy5yZWFkUXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLmlzUmVhZFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVkSGFsZkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1FbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgdW5jYXVnaHQgZXJyb3IgZXZlbnQgZXhjZXB0aW9ucywgYnV0XHJcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG5vdGhpbmcgd2UgY2FuIHJlYXNvbmFibHkgZG8gaGVyZS4gQW55IGVycm9yIGV2ZW50IHNob3VsZFxyXG4gICAgICAgICAgICAgKiBoYXZlIGEgY29ycmVzcG9uZGluZyBjbG9zZSBldmVudCwgd2hpY2ggaGFuZGxlcyBlbWl0dGluZyB0aGUgY2FuY2VsbGVkXHJcbiAgICAgICAgICAgICAqIGV2ZW50LiBBbmQgdGhlIHN0cmVhbSBpcyBub3cgaW4gYSBiYWQgc3RhdGUsIHNvIHdlIGNhbid0IHJlYXNvbmFibHlcclxuICAgICAgICAgICAgICogZXhwZWN0IHRvIGJlIGFibGUgdG8gc2VuZCBhbiBlcnJvciBvdmVyIGl0LiAqL1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcclxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXHJcbiAgICAgICAgICAgICAgICAnIHN0cmVhbSBjbG9zZWQgd2l0aCByc3RDb2RlICcgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucnN0Q29kZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudFRyYWNrZXIgJiYgIXRoaXMuc3RyZWFtRW5kZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vbkNhbGxFbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1N0cmVhbSBjbG9zZWQgYmVmb3JlIHNlbmRpbmcgc3RhdHVzJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T25DYW5jZWwoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUZyYW1lKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbmRFdmVudCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICgnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhvc3QgPSAoX2EgPSBoZWFkZXJzWyc6YXV0aG9yaXR5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGhlYWRlcnMuaG9zdDtcclxuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcclxuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XHJcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnBhdGggK1xyXG4gICAgICAgICAgICAgICAgJyByZWNlaXZlZCBoZWFkZXJzICcgK1xyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEudG9KU09OKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGltZW91dEhlYWRlciA9IG1ldGFkYXRhLmdldChHUlBDX1RJTUVPVVRfSEVBREVSKTtcclxuICAgICAgICBpZiAodGltZW91dEhlYWRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGltZW91dEhlYWRlcih0aW1lb3V0SGVhZGVyWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RpbmdIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19FTkNPRElOR19IRUFERVIpO1xyXG4gICAgICAgIGlmIChlbmNvZGluZ0hlYWRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdFbmNvZGluZyA9IGVuY29kaW5nSGVhZGVyWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgc2V2ZXJhbCBoZWFkZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBhcHBsaWNhdGlvblxyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX1RJTUVPVVRfSEVBREVSKTtcclxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19FTkNPRElOR19IRUFERVIpO1xyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIpO1xyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0FDQ0VQVF9FTkNPRElORyk7XHJcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfVEUpO1xyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSk7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlVGltZW91dEhlYWRlcih0aW1lb3V0SGVhZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aW1lb3V0SGVhZGVyLnRvU3RyaW5nKCkubWF0Y2goREVBRExJTkVfUkVHRVgpO1xyXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgSW52YWxpZCAke0dSUENfVElNRU9VVF9IRUFERVJ9IHZhbHVlIFwiJHt0aW1lb3V0SGVhZGVyfVwiYCxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY29uc3RydWN0b3IgdG8gY29tcGxldGUgYmVmb3JlIHNlbmRpbmcgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKCttYXRjaFsxXSAqIGRlYWRsaW5lVW5pdHNUb01zW21hdGNoWzJdXSkgfCAwO1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IG5vdy5zZXRNaWxsaXNlY29uZHMobm93LmdldE1pbGxpc2Vjb25kcygpICsgdGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdEZWFkbGluZSBleGNlZWRlZCcsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NhbmNlbGxlZCgpIHtcclxuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxyXG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGxlZCAmJiAodGhpcy5zdHJlYW0uZGVzdHJveWVkIHx8IHRoaXMuc3RyZWFtLmNsb3NlZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcclxuICAgIH1cclxuICAgIG5vdGlmeU9uQ2FuY2VsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbE5vdGlmaWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYW5jZWxOb3RpZmllZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkNhbmNlbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZsdXNoIGluY29taW5nIGRhdGEgZnJhbWVzXHJcbiAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgc2VydmVyIGhhbmRsZXIgY2FuIHN0YXJ0IHNlbmRpbmcgbWVzc2FnZXMgd2l0aG91dCBleHBsaWNpdGx5IHNlbmRpbmdcclxuICAgICAqIG1ldGFkYXRhLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gc2VuZCBoZWFkZXJzIGJlZm9yZSBzZW5kaW5nIGFueVxyXG4gICAgICogbWVzc2FnZXMuIFRoaXMgZnVuY3Rpb24gZG9lcyB0aGF0IGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgbWF5YmVTZW5kTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhU2VudCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNZXRhZGF0YShuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlcmlhbGl6ZSBhIG1lc3NhZ2UgdG8gYSBsZW5ndGgtZGVsaW1pdGVkIGJ5dGUgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBzZXJpYWxpemVNZXNzYWdlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRoaXMuaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBtZXNzYWdlQnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVMZW5ndGggKyA1KTtcclxuICAgICAgICAvKiBOb3RlOiByZXNwb25zZSBjb21wcmVzc2lvbiBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCwgc28gdGhpc1xyXG4gICAgICAgICAqIGNvbXByZXNzZWQgYml0IGlzIGFsd2F5cyAwLiAqL1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKGJ5dGVMZW5ndGgsIDEpO1xyXG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlLCBlbmNvZGluZykge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50cyA9IG1lc3NhZ2Uuc3ViYXJyYXkoNSk7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaWRlbnRpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQ29udGVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAnZGVmbGF0ZScgfHwgZW5jb2RpbmcgPT09ICdnemlwJykge1xyXG4gICAgICAgICAgICBsZXQgZGVjb21wcmVzc2VyO1xyXG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVJbmZsYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUd1bnppcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSB0aGF0IGRlY29tcHJlc3NlcyB0byBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZX1gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZUNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZGVjb21wcmVzc0FuZE1heWJlUHVzaChxdWV1ZUVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXVlRW50cnkudHlwZSAhPT0gJ0NPTVBSRVNTRUQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBxdWV1ZSBlbnRyeSB0eXBlOiAke3F1ZXVlRW50cnkudHlwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IHF1ZXVlRW50cnkuY29tcHJlc3NlZE1lc3NhZ2UucmVhZFVJbnQ4KDApID09PSAxO1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkXHJcbiAgICAgICAgICAgID8gdGhpcy5pbmNvbWluZ0VuY29kaW5nXHJcbiAgICAgICAgICAgIDogJ2lkZW50aXR5JztcclxuICAgICAgICBsZXQgZGVjb21wcmVzc2VkTWVzc2FnZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzTWVzc2FnZShxdWV1ZUVudHJ5LmNvbXByZXNzZWRNZXNzYWdlLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBxdWV1ZUVudHJ5LnBhcnNlZE1lc3NhZ2UgPSB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoZGVjb21wcmVzc2VkTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBFcnJvciBkZXNlcmlhbGl6aW5nIHJlcXVlc3Q6ICR7ZXJyLm1lc3NhZ2V9YCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVFbnRyeS50eXBlID0gJ1JFQURBQkxFJztcclxuICAgICAgICB0aGlzLm1heWJlUHVzaE5leHRNZXNzYWdlKCk7XHJcbiAgICB9XHJcbiAgICBtYXliZVB1c2hOZXh0TWVzc2FnZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lciAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzUmVhZFBlbmRpbmcgJiZcclxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWUubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLnJlYWRRdWV1ZVswXS50eXBlICE9PSAnQ09NUFJFU1NFRCcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1JlYWRQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRRdWV1ZUVudHJ5ID0gdGhpcy5yZWFkUXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKG5leHRRdWV1ZUVudHJ5LnR5cGUgPT09ICdSRUFEQUJMRScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShuZXh0UXVldWVFbnRyeS5wYXJzZWRNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5leHRRdWV1ZUVudHJ5LnR5cGUgPT09ICdIQUxGX0NMT1NFJ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVIYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZURhdGFGcmFtZShkYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnBhdGggK1xyXG4gICAgICAgICAgICAnIHJlY2VpdmVkIGRhdGEgZnJhbWUgb2Ygc2l6ZSAnICtcclxuICAgICAgICAgICAgZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGxldCByYXdNZXNzYWdlcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByYXdNZXNzYWdlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgZGV0YWlsczogZS5tZXNzYWdlIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZUJ5dGVzIG9mIHJhd01lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlRW50cnkgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ09NUFJFU1NFRCcsXHJcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkTWVzc2FnZTogbWVzc2FnZUJ5dGVzLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZTogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5yZWFkUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcclxuICAgICAgICAgICAgdGhpcy5kZWNvbXByZXNzQW5kTWF5YmVQdXNoKHF1ZXVlRW50cnkpO1xyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNhbGxFdmVudFRyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFbmRFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnJlYWRRdWV1ZS5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogJ0hBTEZfQ0xPU0UnLFxyXG4gICAgICAgICAgICBjb21wcmVzc2VkTWVzc2FnZTogbnVsbCxcclxuICAgICAgICAgICAgcGFyc2VkTWVzc2FnZTogbnVsbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVkSGFsZkNsb3NlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1heWJlUHVzaE5leHRNZXNzYWdlKCk7XHJcbiAgICB9XHJcbiAgICBzdGFydChsaXN0ZW5lcikge1xyXG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgKyB0aGlzLmhhbmRsZXIucGF0aCArICcgc3RhcnQgY2FsbGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLm1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgY3VzdG9tID0gbWV0YWRhdGEgPyBtZXRhZGF0YS50b0h0dHAySGVhZGVycygpIDogbnVsbDtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRSZXNwb25zZUhlYWRlcnMpLCBkZWZhdWx0Q29tcHJlc3Npb25IZWFkZXJzKSwgY3VzdG9tKTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKGhlYWRlcnMsIGRlZmF1bHRSZXNwb25zZU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYEVycm9yIHNlcmlhbGl6aW5nIHJlc3BvbnNlOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZSl9YCxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXHJcbiAgICAgICAgICAgIHJlc3BvbnNlLmxlbmd0aCAtIDUgPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZW50IG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke3Jlc3BvbnNlLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhTZW5kTWVzc2FnZVNpemV9KWAsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXliZVNlbmRNZXRhZGF0YSgpO1xyXG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgK1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucGF0aCArXHJcbiAgICAgICAgICAgICcgc2VudCBkYXRhIGZyYW1lIG9mIHNpemUgJyArXHJcbiAgICAgICAgICAgIHJlc3BvbnNlLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUocmVzcG9uc2UsIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBFcnJvciB3cml0aW5nIG1lc3NhZ2U6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9YCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY2FsbEV2ZW50VHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZE1lc3NhZ2VTZW50KCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcclxuICAgICAgICAgICAgKChfYSA9IHRoaXMuaGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpICtcclxuICAgICAgICAgICAgJyBlbmRlZCB3aXRoIHN0YXR1cyBjb2RlOiAnICtcclxuICAgICAgICAgICAgY29uc3RhbnRzXzEuU3RhdHVzW3N0YXR1cy5jb2RlXSArXHJcbiAgICAgICAgICAgICcgZGV0YWlsczogJyArXHJcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzKTtcclxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLndhbnRUcmFpbGVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnd2FudFRyYWlsZXJzJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnRUcmFja2VyICYmICF0aGlzLnN0cmVhbUVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25TdHJlYW1FbmQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vbkNhbGxFbmQoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1cy5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXMuZGV0YWlscykgfSwgKF9hID0gc3RhdHVzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9IdHRwMkhlYWRlcnMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uc2VuZFRyYWlsZXJzKHRyYWlsZXJzVG9TZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uQ2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLmVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnRUcmFja2VyICYmICF0aGlzLnN0cmVhbUVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vbkNhbGxFbmQoc3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUcmFpbGVycy1vbmx5IHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1cy5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXMuZGV0YWlscykgfSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIChfYiA9IHN0YXR1cy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSHR0cDJIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKHRyYWlsZXJzVG9TZW5kLCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICsgdGhpcy5oYW5kbGVyLnBhdGggKyAnIHN0YXJ0UmVhZCBjYWxsZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc1JlYWRQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNlaXZlZEhhbGZDbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF5YmVQdXNoTmV4dE1lc3NhZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzb2NrZXQgPSAoX2EgPSB0aGlzLnN0cmVhbS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29ja2V0O1xyXG4gICAgICAgIGlmIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlQWRkcmVzcykge1xyXG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5yZW1vdGVBZGRyZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldERlYWRsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xyXG4gICAgfVxyXG4gICAgZ2V0SG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQmFzZVNlcnZlckludGVyY2VwdGluZ0NhbGwgPSBCYXNlU2VydmVySW50ZXJjZXB0aW5nQ2FsbDtcclxuZnVuY3Rpb24gZ2V0U2VydmVySW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvcnMsIHN0cmVhbSwgaGVhZGVycywgY2FsbEV2ZW50VHJhY2tlciwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcclxuICAgICAgICBwYXRoOiBoYW5kbGVyLnBhdGgsXHJcbiAgICAgICAgcmVxdWVzdFN0cmVhbTogaGFuZGxlci50eXBlID09PSAnY2xpZW50U3RyZWFtJyB8fCBoYW5kbGVyLnR5cGUgPT09ICdiaWRpJyxcclxuICAgICAgICByZXNwb25zZVN0cmVhbTogaGFuZGxlci50eXBlID09PSAnc2VydmVyU3RyZWFtJyB8fCBoYW5kbGVyLnR5cGUgPT09ICdiaWRpJyxcclxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGhhbmRsZXIuZGVzZXJpYWxpemUsXHJcbiAgICAgICAgcmVzcG9uc2VTZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGJhc2VDYWxsID0gbmV3IEJhc2VTZXJ2ZXJJbnRlcmNlcHRpbmdDYWxsKHN0cmVhbSwgaGVhZGVycywgY2FsbEV2ZW50VHJhY2tlciwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gaW50ZXJjZXB0b3JzLnJlZHVjZSgoY2FsbCwgaW50ZXJjZXB0b3IpID0+IHtcclxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0b3IobWV0aG9kRGVmaW5pdGlvbiwgY2FsbCk7XHJcbiAgICB9LCBiYXNlQ2FsbCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWludGVyY2VwdG9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Server = void 0;\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst util = __webpack_require__(/*! util */ \"util\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\r\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst server_interceptors_1 = __webpack_require__(/*! ./server-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-interceptors.js\");\r\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\r\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\r\nconst KEEPALIVE_TIMEOUT_MS = 20000;\r\nconst MAX_CONNECTION_IDLE_MS = ~(1 << 31);\r\nconst { HTTP2_HEADER_PATH } = http2.constants;\r\nconst TRACER_NAME = 'server';\r\nconst kMaxAge = Buffer.from('max_age');\r\nfunction serverCallTrace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'server_call', text);\r\n}\r\nfunction noop() { }\r\n/**\r\n * Decorator to wrap a class method with util.deprecate\r\n * @param message The message to output if the deprecated method is called\r\n * @returns\r\n */\r\nfunction deprecate(message) {\r\n    return function (target, context) {\r\n        return util.deprecate(target, message);\r\n    };\r\n}\r\nfunction getUnimplementedStatusResponse(methodName) {\r\n    return {\r\n        code: constants_1.Status.UNIMPLEMENTED,\r\n        details: `The server does not implement the method ${methodName}`,\r\n    };\r\n}\r\nfunction getDefaultHandler(handlerType, methodName) {\r\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\r\n    switch (handlerType) {\r\n        case 'unary':\r\n            return (call, callback) => {\r\n                callback(unimplementedStatusResponse, null);\r\n            };\r\n        case 'clientStream':\r\n            return (call, callback) => {\r\n                callback(unimplementedStatusResponse, null);\r\n            };\r\n        case 'serverStream':\r\n            return (call) => {\r\n                call.emit('error', unimplementedStatusResponse);\r\n            };\r\n        case 'bidi':\r\n            return (call) => {\r\n                call.emit('error', unimplementedStatusResponse);\r\n            };\r\n        default:\r\n            throw new Error(`Invalid handlerType ${handlerType}`);\r\n    }\r\n}\r\nlet Server = (() => {\r\n    var _a;\r\n    let _instanceExtraInitializers = [];\r\n    let _start_decorators;\r\n    return _a = class Server {\r\n            constructor(options) {\r\n                var _b, _c, _d, _e, _f, _g;\r\n                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\r\n                this.http2Servers = new Map();\r\n                this.sessionIdleTimeouts = new Map();\r\n                this.handlers = new Map();\r\n                this.sessions = new Map();\r\n                /**\r\n                 * This field only exists to ensure that the start method throws an error if\r\n                 * it is called twice, as it did previously.\r\n                 */\r\n                this.started = false;\r\n                this.shutdown = false;\r\n                this.serverAddressString = 'null';\r\n                // Channelz Info\r\n                this.channelzEnabled = true;\r\n                this.options = options !== null && options !== void 0 ? options : {};\r\n                if (this.options['grpc.enable_channelz'] === 0) {\r\n                    this.channelzEnabled = false;\r\n                    this.channelzTrace = new channelz_1.ChannelzTraceStub();\r\n                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();\r\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\r\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\r\n                }\r\n                else {\r\n                    this.channelzTrace = new channelz_1.ChannelzTrace();\r\n                    this.callTracker = new channelz_1.ChannelzCallTracker();\r\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n                }\r\n                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);\r\n                this.channelzTrace.addTrace('CT_INFO', 'Server created');\r\n                this.maxConnectionAgeMs =\r\n                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\r\n                this.maxConnectionAgeGraceMs =\r\n                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\r\n                this.keepaliveTimeMs =\r\n                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\r\n                this.keepaliveTimeoutMs =\r\n                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\r\n                this.sessionIdleTimeout =\r\n                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\r\n                this.commonServerOptions = {\r\n                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\r\n                };\r\n                if ('grpc-node.max_session_memory' in this.options) {\r\n                    this.commonServerOptions.maxSessionMemory =\r\n                        this.options['grpc-node.max_session_memory'];\r\n                }\r\n                else {\r\n                    /* By default, set a very large max session memory limit, to effectively\r\n                     * disable enforcement of the limit. Some testing indicates that Node's\r\n                     * behavior degrades badly when this limit is reached, so we solve that\r\n                     * by disabling the check entirely. */\r\n                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\r\n                }\r\n                if ('grpc.max_concurrent_streams' in this.options) {\r\n                    this.commonServerOptions.settings = {\r\n                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\r\n                    };\r\n                }\r\n                this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];\r\n                this.trace('Server constructed');\r\n            }\r\n            getChannelzInfo() {\r\n                return {\r\n                    trace: this.channelzTrace,\r\n                    callTracker: this.callTracker,\r\n                    listenerChildren: this.listenerChildrenTracker.getChildLists(),\r\n                    sessionChildren: this.sessionChildrenTracker.getChildLists(),\r\n                };\r\n            }\r\n            getChannelzSessionInfo(session) {\r\n                var _b, _c, _d;\r\n                const sessionInfo = this.sessions.get(session);\r\n                const sessionSocket = session.socket;\r\n                const remoteAddress = sessionSocket.remoteAddress\r\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\r\n                    : null;\r\n                const localAddress = sessionSocket.localAddress\r\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\r\n                    : null;\r\n                let tlsInfo;\r\n                if (session.encrypted) {\r\n                    const tlsSocket = sessionSocket;\r\n                    const cipherInfo = tlsSocket.getCipher();\r\n                    const certificate = tlsSocket.getCertificate();\r\n                    const peerCertificate = tlsSocket.getPeerCertificate();\r\n                    tlsInfo = {\r\n                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,\r\n                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\r\n                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\r\n                        remoteCertificate: peerCertificate && 'raw' in peerCertificate\r\n                            ? peerCertificate.raw\r\n                            : null,\r\n                    };\r\n                }\r\n                else {\r\n                    tlsInfo = null;\r\n                }\r\n                const socketInfo = {\r\n                    remoteAddress: remoteAddress,\r\n                    localAddress: localAddress,\r\n                    security: tlsInfo,\r\n                    remoteName: null,\r\n                    streamsStarted: sessionInfo.streamTracker.callsStarted,\r\n                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\r\n                    streamsFailed: sessionInfo.streamTracker.callsFailed,\r\n                    messagesSent: sessionInfo.messagesSent,\r\n                    messagesReceived: sessionInfo.messagesReceived,\r\n                    keepAlivesSent: sessionInfo.keepAlivesSent,\r\n                    lastLocalStreamCreatedTimestamp: null,\r\n                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\r\n                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\r\n                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\r\n                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,\r\n                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null,\r\n                };\r\n                return socketInfo;\r\n            }\r\n            trace(text) {\r\n                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\r\n            }\r\n            keepaliveTrace(text) {\r\n                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);\r\n            }\r\n            addProtoService() {\r\n                throw new Error('Not implemented. Use addService() instead');\r\n            }\r\n            addService(service, implementation) {\r\n                if (service === null ||\r\n                    typeof service !== 'object' ||\r\n                    implementation === null ||\r\n                    typeof implementation !== 'object') {\r\n                    throw new Error('addService() requires two objects as arguments');\r\n                }\r\n                const serviceKeys = Object.keys(service);\r\n                if (serviceKeys.length === 0) {\r\n                    throw new Error('Cannot add an empty service to a server');\r\n                }\r\n                serviceKeys.forEach(name => {\r\n                    const attrs = service[name];\r\n                    let methodType;\r\n                    if (attrs.requestStream) {\r\n                        if (attrs.responseStream) {\r\n                            methodType = 'bidi';\r\n                        }\r\n                        else {\r\n                            methodType = 'clientStream';\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (attrs.responseStream) {\r\n                            methodType = 'serverStream';\r\n                        }\r\n                        else {\r\n                            methodType = 'unary';\r\n                        }\r\n                    }\r\n                    let implFn = implementation[name];\r\n                    let impl;\r\n                    if (implFn === undefined && typeof attrs.originalName === 'string') {\r\n                        implFn = implementation[attrs.originalName];\r\n                    }\r\n                    if (implFn !== undefined) {\r\n                        impl = implFn.bind(implementation);\r\n                    }\r\n                    else {\r\n                        impl = getDefaultHandler(methodType, name);\r\n                    }\r\n                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\r\n                    if (success === false) {\r\n                        throw new Error(`Method handler for ${attrs.path} already provided.`);\r\n                    }\r\n                });\r\n            }\r\n            removeService(service) {\r\n                if (service === null || typeof service !== 'object') {\r\n                    throw new Error('removeService() requires object as argument');\r\n                }\r\n                const serviceKeys = Object.keys(service);\r\n                serviceKeys.forEach(name => {\r\n                    const attrs = service[name];\r\n                    this.unregister(attrs.path);\r\n                });\r\n            }\r\n            bind(port, creds) {\r\n                throw new Error('Not implemented. Use bindAsync() instead');\r\n            }\r\n            /**\r\n             * This API is experimental, so API stability is not guaranteed across minor versions.\r\n             * @param boundAddress\r\n             * @returns\r\n             */\r\n            experimentalRegisterListenerToChannelz(boundAddress) {\r\n                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {\r\n                    return {\r\n                        localAddress: boundAddress,\r\n                        remoteAddress: null,\r\n                        security: null,\r\n                        remoteName: null,\r\n                        streamsStarted: 0,\r\n                        streamsSucceeded: 0,\r\n                        streamsFailed: 0,\r\n                        messagesSent: 0,\r\n                        messagesReceived: 0,\r\n                        keepAlivesSent: 0,\r\n                        lastLocalStreamCreatedTimestamp: null,\r\n                        lastRemoteStreamCreatedTimestamp: null,\r\n                        lastMessageSentTimestamp: null,\r\n                        lastMessageReceivedTimestamp: null,\r\n                        localFlowControlWindow: null,\r\n                        remoteFlowControlWindow: null,\r\n                    };\r\n                }, this.channelzEnabled);\r\n            }\r\n            experimentalUnregisterListenerFromChannelz(channelzRef) {\r\n                (0, channelz_1.unregisterChannelzRef)(channelzRef);\r\n            }\r\n            createHttp2Server(credentials) {\r\n                let http2Server;\r\n                if (credentials._isSecure()) {\r\n                    const constructorOptions = credentials._getConstructorOptions();\r\n                    const contextOptions = credentials._getSecureContextOptions();\r\n                    const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });\r\n                    let areCredentialsValid = contextOptions !== null;\r\n                    this.trace('Initial credentials valid: ' + areCredentialsValid);\r\n                    http2Server = http2.createSecureServer(secureServerOptions);\r\n                    http2Server.prependListener('connection', (socket) => {\r\n                        if (!areCredentialsValid) {\r\n                            this.trace('Dropped connection from ' + JSON.stringify(socket.address()) + ' due to unloaded credentials');\r\n                            socket.destroy();\r\n                        }\r\n                    });\r\n                    http2Server.on('secureConnection', (socket) => {\r\n                        /* These errors need to be handled by the user of Http2SecureServer,\r\n                         * according to https://github.com/nodejs/node/issues/35824 */\r\n                        socket.on('error', (e) => {\r\n                            this.trace('An incoming TLS connection closed with error: ' + e.message);\r\n                        });\r\n                    });\r\n                    const credsWatcher = options => {\r\n                        if (options) {\r\n                            const secureServer = http2Server;\r\n                            try {\r\n                                secureServer.setSecureContext(options);\r\n                            }\r\n                            catch (e) {\r\n                                logging.log(constants_1.LogVerbosity.ERROR, 'Failed to set secure context with error ' + e.message);\r\n                                options = null;\r\n                            }\r\n                        }\r\n                        areCredentialsValid = options !== null;\r\n                        this.trace('Post-update credentials valid: ' + areCredentialsValid);\r\n                    };\r\n                    credentials._addWatcher(credsWatcher);\r\n                    http2Server.on('close', () => {\r\n                        credentials._removeWatcher(credsWatcher);\r\n                    });\r\n                }\r\n                else {\r\n                    http2Server = http2.createServer(this.commonServerOptions);\r\n                }\r\n                http2Server.setTimeout(0, noop);\r\n                this._setupHandlers(http2Server, credentials._getInterceptors());\r\n                return http2Server;\r\n            }\r\n            bindOneAddress(address, boundPortObject) {\r\n                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\r\n                const http2Server = this.createHttp2Server(boundPortObject.credentials);\r\n                return new Promise((resolve, reject) => {\r\n                    const onError = (err) => {\r\n                        this.trace('Failed to bind ' +\r\n                            (0, subchannel_address_1.subchannelAddressToString)(address) +\r\n                            ' with error ' +\r\n                            err.message);\r\n                        resolve({\r\n                            port: 'port' in address ? address.port : 1,\r\n                            error: err.message,\r\n                        });\r\n                    };\r\n                    http2Server.once('error', onError);\r\n                    http2Server.listen(address, () => {\r\n                        const boundAddress = http2Server.address();\r\n                        let boundSubchannelAddress;\r\n                        if (typeof boundAddress === 'string') {\r\n                            boundSubchannelAddress = {\r\n                                path: boundAddress,\r\n                            };\r\n                        }\r\n                        else {\r\n                            boundSubchannelAddress = {\r\n                                host: boundAddress.address,\r\n                                port: boundAddress.port,\r\n                            };\r\n                        }\r\n                        const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);\r\n                        this.listenerChildrenTracker.refChild(channelzRef);\r\n                        this.http2Servers.set(http2Server, {\r\n                            channelzRef: channelzRef,\r\n                            sessions: new Set(),\r\n                            ownsChannelzRef: true\r\n                        });\r\n                        boundPortObject.listeningServers.add(http2Server);\r\n                        this.trace('Successfully bound ' +\r\n                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\r\n                        resolve({\r\n                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,\r\n                        });\r\n                        http2Server.removeListener('error', onError);\r\n                    });\r\n                });\r\n            }\r\n            async bindManyPorts(addressList, boundPortObject) {\r\n                if (addressList.length === 0) {\r\n                    return {\r\n                        count: 0,\r\n                        port: 0,\r\n                        errors: [],\r\n                    };\r\n                }\r\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {\r\n                    /* If binding to port 0, first try to bind the first address, then bind\r\n                     * the rest of the address list to the specific port that it binds. */\r\n                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\r\n                    if (firstAddressResult.error) {\r\n                        /* If the first address fails to bind, try the same operation starting\r\n                         * from the second item in the list. */\r\n                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\r\n                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });\r\n                    }\r\n                    else {\r\n                        const restAddresses = addressList\r\n                            .slice(1)\r\n                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)\r\n                            ? { host: address.host, port: firstAddressResult.port }\r\n                            : address);\r\n                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));\r\n                        const allResults = [firstAddressResult, ...restAddressResult];\r\n                        return {\r\n                            count: allResults.filter(result => result.error === undefined).length,\r\n                            port: firstAddressResult.port,\r\n                            errors: allResults\r\n                                .filter(result => result.error)\r\n                                .map(result => result.error),\r\n                        };\r\n                    }\r\n                }\r\n                else {\r\n                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));\r\n                    return {\r\n                        count: allResults.filter(result => result.error === undefined).length,\r\n                        port: allResults[0].port,\r\n                        errors: allResults\r\n                            .filter(result => result.error)\r\n                            .map(result => result.error),\r\n                    };\r\n                }\r\n            }\r\n            async bindAddressList(addressList, boundPortObject) {\r\n                const bindResult = await this.bindManyPorts(addressList, boundPortObject);\r\n                if (bindResult.count > 0) {\r\n                    if (bindResult.count < addressList.length) {\r\n                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\r\n                    }\r\n                    return bindResult.port;\r\n                }\r\n                else {\r\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\r\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\r\n                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);\r\n                }\r\n            }\r\n            resolvePort(port) {\r\n                return new Promise((resolve, reject) => {\r\n                    const resolverListener = {\r\n                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {\r\n                            // We only want one resolution result. Discard all future results\r\n                            resolverListener.onSuccessfulResolution = () => { };\r\n                            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));\r\n                            if (addressList.length === 0) {\r\n                                reject(new Error(`No addresses resolved for port ${port}`));\r\n                                return;\r\n                            }\r\n                            resolve(addressList);\r\n                        },\r\n                        onError: error => {\r\n                            reject(new Error(error.details));\r\n                        },\r\n                    };\r\n                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\r\n                    resolver.updateResolution();\r\n                });\r\n            }\r\n            async bindPort(port, boundPortObject) {\r\n                const addressList = await this.resolvePort(port);\r\n                if (boundPortObject.cancelled) {\r\n                    this.completeUnbind(boundPortObject);\r\n                    throw new Error('bindAsync operation cancelled by unbind call');\r\n                }\r\n                const portNumber = await this.bindAddressList(addressList, boundPortObject);\r\n                if (boundPortObject.cancelled) {\r\n                    this.completeUnbind(boundPortObject);\r\n                    throw new Error('bindAsync operation cancelled by unbind call');\r\n                }\r\n                return portNumber;\r\n            }\r\n            normalizePort(port) {\r\n                const initialPortUri = (0, uri_parser_1.parseUri)(port);\r\n                if (initialPortUri === null) {\r\n                    throw new Error(`Could not parse port \"${port}\"`);\r\n                }\r\n                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\r\n                if (portUri === null) {\r\n                    throw new Error(`Could not get a default scheme for port \"${port}\"`);\r\n                }\r\n                return portUri;\r\n            }\r\n            bindAsync(port, creds, callback) {\r\n                if (this.shutdown) {\r\n                    throw new Error('bindAsync called after shutdown');\r\n                }\r\n                if (typeof port !== 'string') {\r\n                    throw new TypeError('port must be a string');\r\n                }\r\n                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\r\n                    throw new TypeError('creds must be a ServerCredentials object');\r\n                }\r\n                if (typeof callback !== 'function') {\r\n                    throw new TypeError('callback must be a function');\r\n                }\r\n                this.trace('bindAsync port=' + port);\r\n                const portUri = this.normalizePort(port);\r\n                const deferredCallback = (error, port) => {\r\n                    process.nextTick(() => callback(error, port));\r\n                };\r\n                /* First, if this port is already bound or that bind operation is in\r\n                 * progress, use that result. */\r\n                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\r\n                if (boundPortObject) {\r\n                    if (!creds._equals(boundPortObject.credentials)) {\r\n                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\r\n                        return;\r\n                    }\r\n                    /* If that operation has previously been cancelled by an unbind call,\r\n                     * uncancel it. */\r\n                    boundPortObject.cancelled = false;\r\n                    if (boundPortObject.completionPromise) {\r\n                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));\r\n                    }\r\n                    else {\r\n                        deferredCallback(null, boundPortObject.portNumber);\r\n                    }\r\n                    return;\r\n                }\r\n                boundPortObject = {\r\n                    mapKey: (0, uri_parser_1.uriToString)(portUri),\r\n                    originalUri: portUri,\r\n                    completionPromise: null,\r\n                    cancelled: false,\r\n                    portNumber: 0,\r\n                    credentials: creds,\r\n                    listeningServers: new Set(),\r\n                };\r\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\r\n                const completionPromise = this.bindPort(portUri, boundPortObject);\r\n                boundPortObject.completionPromise = completionPromise;\r\n                /* If the port number is 0, defer populating the map entry until after the\r\n                 * bind operation completes and we have a specific port number. Otherwise,\r\n                 * populate it immediately. */\r\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\r\n                    completionPromise.then(portNum => {\r\n                        const finalUri = {\r\n                            scheme: portUri.scheme,\r\n                            authority: portUri.authority,\r\n                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),\r\n                        };\r\n                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\r\n                        boundPortObject.completionPromise = null;\r\n                        boundPortObject.portNumber = portNum;\r\n                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\r\n                        callback(null, portNum);\r\n                    }, error => {\r\n                        callback(error, 0);\r\n                    });\r\n                }\r\n                else {\r\n                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\r\n                    completionPromise.then(portNum => {\r\n                        boundPortObject.completionPromise = null;\r\n                        boundPortObject.portNumber = portNum;\r\n                        callback(null, portNum);\r\n                    }, error => {\r\n                        callback(error, 0);\r\n                    });\r\n                }\r\n            }\r\n            registerInjectorToChannelz() {\r\n                return (0, channelz_1.registerChannelzSocket)('injector', () => {\r\n                    return {\r\n                        localAddress: null,\r\n                        remoteAddress: null,\r\n                        security: null,\r\n                        remoteName: null,\r\n                        streamsStarted: 0,\r\n                        streamsSucceeded: 0,\r\n                        streamsFailed: 0,\r\n                        messagesSent: 0,\r\n                        messagesReceived: 0,\r\n                        keepAlivesSent: 0,\r\n                        lastLocalStreamCreatedTimestamp: null,\r\n                        lastRemoteStreamCreatedTimestamp: null,\r\n                        lastMessageSentTimestamp: null,\r\n                        lastMessageReceivedTimestamp: null,\r\n                        localFlowControlWindow: null,\r\n                        remoteFlowControlWindow: null,\r\n                    };\r\n                }, this.channelzEnabled);\r\n            }\r\n            /**\r\n             * This API is experimental, so API stability is not guaranteed across minor versions.\r\n             * @param credentials\r\n             * @param channelzRef\r\n             * @returns\r\n             */\r\n            experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {\r\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\r\n                    throw new TypeError('creds must be a ServerCredentials object');\r\n                }\r\n                if (this.channelzEnabled) {\r\n                    this.listenerChildrenTracker.refChild(channelzRef);\r\n                }\r\n                const server = this.createHttp2Server(credentials);\r\n                const sessionsSet = new Set();\r\n                this.http2Servers.set(server, {\r\n                    channelzRef: channelzRef,\r\n                    sessions: sessionsSet,\r\n                    ownsChannelzRef\r\n                });\r\n                return {\r\n                    injectConnection: (connection) => {\r\n                        server.emit('connection', connection);\r\n                    },\r\n                    drain: (graceTimeMs) => {\r\n                        var _b, _c;\r\n                        for (const session of sessionsSet) {\r\n                            this.closeSession(session);\r\n                        }\r\n                        (_c = (_b = setTimeout(() => {\r\n                            for (const session of sessionsSet) {\r\n                                session.destroy(http2.constants.NGHTTP2_CANCEL);\r\n                            }\r\n                        }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n                    },\r\n                    destroy: () => {\r\n                        this.closeServer(server);\r\n                        for (const session of sessionsSet) {\r\n                            this.closeSession(session);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n            createConnectionInjector(credentials) {\r\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\r\n                    throw new TypeError('creds must be a ServerCredentials object');\r\n                }\r\n                const channelzRef = this.registerInjectorToChannelz();\r\n                return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\r\n            }\r\n            closeServer(server, callback) {\r\n                this.trace('Closing server with address ' + JSON.stringify(server.address()));\r\n                const serverInfo = this.http2Servers.get(server);\r\n                server.close(() => {\r\n                    if (serverInfo && serverInfo.ownsChannelzRef) {\r\n                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\r\n                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\r\n                    }\r\n                    this.http2Servers.delete(server);\r\n                    callback === null || callback === void 0 ? void 0 : callback();\r\n                });\r\n            }\r\n            closeSession(session, callback) {\r\n                var _b;\r\n                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\r\n                const sessionInfo = this.sessions.get(session);\r\n                const closeCallback = () => {\r\n                    if (sessionInfo) {\r\n                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\r\n                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\r\n                    }\r\n                    callback === null || callback === void 0 ? void 0 : callback();\r\n                };\r\n                if (session.closed) {\r\n                    queueMicrotask(closeCallback);\r\n                }\r\n                else {\r\n                    session.close(closeCallback);\r\n                }\r\n            }\r\n            completeUnbind(boundPortObject) {\r\n                for (const server of boundPortObject.listeningServers) {\r\n                    const serverInfo = this.http2Servers.get(server);\r\n                    this.closeServer(server, () => {\r\n                        boundPortObject.listeningServers.delete(server);\r\n                    });\r\n                    if (serverInfo) {\r\n                        for (const session of serverInfo.sessions) {\r\n                            this.closeSession(session);\r\n                        }\r\n                    }\r\n                }\r\n                this.boundPorts.delete(boundPortObject.mapKey);\r\n            }\r\n            /**\r\n             * Unbind a previously bound port, or cancel an in-progress bindAsync\r\n             * operation. If port 0 was bound, only the actual bound port can be\r\n             * unbound. For example, if bindAsync was called with \"localhost:0\" and the\r\n             * bound port result was 54321, it can be unbound as \"localhost:54321\".\r\n             * @param port\r\n             */\r\n            unbind(port) {\r\n                this.trace('unbind port=' + port);\r\n                const portUri = this.normalizePort(port);\r\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\r\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\r\n                    throw new Error('Cannot unbind port 0');\r\n                }\r\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\r\n                if (boundPortObject) {\r\n                    this.trace('unbinding ' +\r\n                        boundPortObject.mapKey +\r\n                        ' originally bound as ' +\r\n                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\r\n                    /* If the bind operation is pending, the cancelled flag will trigger\r\n                     * the unbind operation later. */\r\n                    if (boundPortObject.completionPromise) {\r\n                        boundPortObject.cancelled = true;\r\n                    }\r\n                    else {\r\n                        this.completeUnbind(boundPortObject);\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Gracefully close all connections associated with a previously bound port.\r\n             * After the grace time, forcefully close all remaining open connections.\r\n             *\r\n             * If port 0 was bound, only the actual bound port can be\r\n             * drained. For example, if bindAsync was called with \"localhost:0\" and the\r\n             * bound port result was 54321, it can be drained as \"localhost:54321\".\r\n             * @param port\r\n             * @param graceTimeMs\r\n             * @returns\r\n             */\r\n            drain(port, graceTimeMs) {\r\n                var _b, _c;\r\n                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\r\n                const portUri = this.normalizePort(port);\r\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\r\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\r\n                    throw new Error('Cannot drain port 0');\r\n                }\r\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\r\n                if (!boundPortObject) {\r\n                    return;\r\n                }\r\n                const allSessions = new Set();\r\n                for (const http2Server of boundPortObject.listeningServers) {\r\n                    const serverEntry = this.http2Servers.get(http2Server);\r\n                    if (serverEntry) {\r\n                        for (const session of serverEntry.sessions) {\r\n                            allSessions.add(session);\r\n                            this.closeSession(session, () => {\r\n                                allSessions.delete(session);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                /* After the grace time ends, send another goaway to all remaining sessions\r\n                 * with the CANCEL code. */\r\n                (_c = (_b = setTimeout(() => {\r\n                    for (const session of allSessions) {\r\n                        session.destroy(http2.constants.NGHTTP2_CANCEL);\r\n                    }\r\n                }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n            }\r\n            forceShutdown() {\r\n                for (const boundPortObject of this.boundPorts.values()) {\r\n                    boundPortObject.cancelled = true;\r\n                }\r\n                this.boundPorts.clear();\r\n                // Close the server if it is still running.\r\n                for (const server of this.http2Servers.keys()) {\r\n                    this.closeServer(server);\r\n                }\r\n                // Always destroy any available sessions. It's possible that one or more\r\n                // tryShutdown() calls are in progress. Don't wait on them to finish.\r\n                this.sessions.forEach((channelzInfo, session) => {\r\n                    this.closeSession(session);\r\n                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\r\n                    // recognize destroy(code) as a valid signature.\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    session.destroy(http2.constants.NGHTTP2_CANCEL);\r\n                });\r\n                this.sessions.clear();\r\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n                this.shutdown = true;\r\n            }\r\n            register(name, handler, serialize, deserialize, type) {\r\n                if (this.handlers.has(name)) {\r\n                    return false;\r\n                }\r\n                this.handlers.set(name, {\r\n                    func: handler,\r\n                    serialize,\r\n                    deserialize,\r\n                    type,\r\n                    path: name,\r\n                });\r\n                return true;\r\n            }\r\n            unregister(name) {\r\n                return this.handlers.delete(name);\r\n            }\r\n            /**\r\n             * @deprecated No longer needed as of version 1.10.x\r\n             */\r\n            start() {\r\n                if (this.http2Servers.size === 0 ||\r\n                    [...this.http2Servers.keys()].every(server => !server.listening)) {\r\n                    throw new Error('server must be bound in order to start');\r\n                }\r\n                if (this.started === true) {\r\n                    throw new Error('server is already started');\r\n                }\r\n                this.started = true;\r\n            }\r\n            tryShutdown(callback) {\r\n                var _b;\r\n                const wrappedCallback = (error) => {\r\n                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n                    callback(error);\r\n                };\r\n                let pendingChecks = 0;\r\n                function maybeCallback() {\r\n                    pendingChecks--;\r\n                    if (pendingChecks === 0) {\r\n                        wrappedCallback();\r\n                    }\r\n                }\r\n                this.shutdown = true;\r\n                for (const [serverKey, server] of this.http2Servers.entries()) {\r\n                    pendingChecks++;\r\n                    const serverString = server.channelzRef.name;\r\n                    this.trace('Waiting for server ' + serverString + ' to close');\r\n                    this.closeServer(serverKey, () => {\r\n                        this.trace('Server ' + serverString + ' finished closing');\r\n                        maybeCallback();\r\n                    });\r\n                    for (const session of server.sessions.keys()) {\r\n                        pendingChecks++;\r\n                        const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\r\n                        this.trace('Waiting for session ' + sessionString + ' to close');\r\n                        this.closeSession(session, () => {\r\n                            this.trace('Session ' + sessionString + ' finished closing');\r\n                            maybeCallback();\r\n                        });\r\n                    }\r\n                }\r\n                if (pendingChecks === 0) {\r\n                    wrappedCallback();\r\n                }\r\n            }\r\n            addHttp2Port() {\r\n                throw new Error('Not yet implemented');\r\n            }\r\n            /**\r\n             * Get the channelz reference object for this server. The returned value is\r\n             * garbage if channelz is disabled for this server.\r\n             * @returns\r\n             */\r\n            getChannelzRef() {\r\n                return this.channelzRef;\r\n            }\r\n            _verifyContentType(stream, headers) {\r\n                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\r\n                if (typeof contentType !== 'string' ||\r\n                    !contentType.startsWith('application/grpc')) {\r\n                    stream.respond({\r\n                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\r\n                    }, { endStream: true });\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            _retrieveHandler(path) {\r\n                serverCallTrace('Received call to method ' +\r\n                    path +\r\n                    ' at address ' +\r\n                    this.serverAddressString);\r\n                const handler = this.handlers.get(path);\r\n                if (handler === undefined) {\r\n                    serverCallTrace('No handler registered for method ' +\r\n                        path +\r\n                        '. Sending UNIMPLEMENTED status.');\r\n                    return null;\r\n                }\r\n                return handler;\r\n            }\r\n            _respondWithError(err, stream, channelzSessionInfo = null) {\r\n                var _b, _c;\r\n                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\r\n                stream.respond(trailersToSend, { endStream: true });\r\n                this.callTracker.addCallFailed();\r\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\r\n            }\r\n            _channelzHandler(extraInterceptors, stream, headers) {\r\n                // for handling idle timeout\r\n                this.onStreamOpened(stream);\r\n                const channelzSessionInfo = this.sessions.get(stream.session);\r\n                this.callTracker.addCallStarted();\r\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\r\n                if (!this._verifyContentType(stream, headers)) {\r\n                    this.callTracker.addCallFailed();\r\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\r\n                    return;\r\n                }\r\n                const path = headers[HTTP2_HEADER_PATH];\r\n                const handler = this._retrieveHandler(path);\r\n                if (!handler) {\r\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\r\n                    return;\r\n                }\r\n                const callEventTracker = {\r\n                    addMessageSent: () => {\r\n                        if (channelzSessionInfo) {\r\n                            channelzSessionInfo.messagesSent += 1;\r\n                            channelzSessionInfo.lastMessageSentTimestamp = new Date();\r\n                        }\r\n                    },\r\n                    addMessageReceived: () => {\r\n                        if (channelzSessionInfo) {\r\n                            channelzSessionInfo.messagesReceived += 1;\r\n                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\r\n                        }\r\n                    },\r\n                    onCallEnd: status => {\r\n                        if (status.code === constants_1.Status.OK) {\r\n                            this.callTracker.addCallSucceeded();\r\n                        }\r\n                        else {\r\n                            this.callTracker.addCallFailed();\r\n                        }\r\n                    },\r\n                    onStreamEnd: success => {\r\n                        if (channelzSessionInfo) {\r\n                            if (success) {\r\n                                channelzSessionInfo.streamTracker.addCallSucceeded();\r\n                            }\r\n                            else {\r\n                                channelzSessionInfo.streamTracker.addCallFailed();\r\n                            }\r\n                        }\r\n                    },\r\n                };\r\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);\r\n                if (!this._runHandlerForCall(call, handler)) {\r\n                    this.callTracker.addCallFailed();\r\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\r\n                    call.sendStatus({\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: `Unknown handler type: ${handler.type}`,\r\n                    });\r\n                }\r\n            }\r\n            _streamHandler(extraInterceptors, stream, headers) {\r\n                // for handling idle timeout\r\n                this.onStreamOpened(stream);\r\n                if (this._verifyContentType(stream, headers) !== true) {\r\n                    return;\r\n                }\r\n                const path = headers[HTTP2_HEADER_PATH];\r\n                const handler = this._retrieveHandler(path);\r\n                if (!handler) {\r\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\r\n                    return;\r\n                }\r\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);\r\n                if (!this._runHandlerForCall(call, handler)) {\r\n                    call.sendStatus({\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: `Unknown handler type: ${handler.type}`,\r\n                    });\r\n                }\r\n            }\r\n            _runHandlerForCall(call, handler) {\r\n                const { type } = handler;\r\n                if (type === 'unary') {\r\n                    handleUnary(call, handler);\r\n                }\r\n                else if (type === 'clientStream') {\r\n                    handleClientStreaming(call, handler);\r\n                }\r\n                else if (type === 'serverStream') {\r\n                    handleServerStreaming(call, handler);\r\n                }\r\n                else if (type === 'bidi') {\r\n                    handleBidiStreaming(call, handler);\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            _setupHandlers(http2Server, extraInterceptors) {\r\n                if (http2Server === null) {\r\n                    return;\r\n                }\r\n                const serverAddress = http2Server.address();\r\n                let serverAddressString = 'null';\r\n                if (serverAddress) {\r\n                    if (typeof serverAddress === 'string') {\r\n                        serverAddressString = serverAddress;\r\n                    }\r\n                    else {\r\n                        serverAddressString = serverAddress.address + ':' + serverAddress.port;\r\n                    }\r\n                }\r\n                this.serverAddressString = serverAddressString;\r\n                const handler = this.channelzEnabled\r\n                    ? this._channelzHandler\r\n                    : this._streamHandler;\r\n                const sessionHandler = this.channelzEnabled\r\n                    ? this._channelzSessionHandler(http2Server)\r\n                    : this._sessionHandler(http2Server);\r\n                http2Server.on('stream', handler.bind(this, extraInterceptors));\r\n                http2Server.on('session', sessionHandler);\r\n            }\r\n            _sessionHandler(http2Server) {\r\n                return (session) => {\r\n                    var _b, _c;\r\n                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\r\n                    let connectionAgeTimer = null;\r\n                    let connectionAgeGraceTimer = null;\r\n                    let keepaliveTimer = null;\r\n                    let sessionClosedByServer = false;\r\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\r\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\r\n                        // Apply a random jitter within a +/-10% range\r\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\r\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\r\n                        connectionAgeTimer = setTimeout(() => {\r\n                            var _b, _c;\r\n                            sessionClosedByServer = true;\r\n                            this.trace('Connection dropped by max connection age: ' +\r\n                                ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\r\n                            try {\r\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\r\n                            }\r\n                            catch (e) {\r\n                                // The goaway can't be sent because the session is already closed\r\n                                session.destroy();\r\n                                return;\r\n                            }\r\n                            session.close();\r\n                            /* Allow a grace period after sending the GOAWAY before forcibly\r\n                             * closing the connection. */\r\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\r\n                                connectionAgeGraceTimer = setTimeout(() => {\r\n                                    session.destroy();\r\n                                }, this.maxConnectionAgeGraceMs);\r\n                                (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\r\n                            }\r\n                        }, this.maxConnectionAgeMs + jitter);\r\n                        (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\r\n                    }\r\n                    const clearKeepaliveTimeout = () => {\r\n                        if (keepaliveTimer) {\r\n                            clearTimeout(keepaliveTimer);\r\n                            keepaliveTimer = null;\r\n                        }\r\n                    };\r\n                    const canSendPing = () => {\r\n                        return (!session.destroyed &&\r\n                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\r\n                            this.keepaliveTimeMs > 0);\r\n                    };\r\n                    /* eslint-disable-next-line prefer-const */\r\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\r\n                    const maybeStartKeepalivePingTimer = () => {\r\n                        var _b;\r\n                        if (!canSendPing()) {\r\n                            return;\r\n                        }\r\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\r\n                        keepaliveTimer = setTimeout(() => {\r\n                            clearKeepaliveTimeout();\r\n                            sendPing();\r\n                        }, this.keepaliveTimeMs);\r\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\r\n                    };\r\n                    sendPing = () => {\r\n                        var _b;\r\n                        if (!canSendPing()) {\r\n                            return;\r\n                        }\r\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\r\n                        let pingSendError = '';\r\n                        try {\r\n                            const pingSentSuccessfully = session.ping((err, duration, payload) => {\r\n                                clearKeepaliveTimeout();\r\n                                if (err) {\r\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\r\n                                    sessionClosedByServer = true;\r\n                                    session.close();\r\n                                }\r\n                                else {\r\n                                    this.keepaliveTrace('Received ping response');\r\n                                    maybeStartKeepalivePingTimer();\r\n                                }\r\n                            });\r\n                            if (!pingSentSuccessfully) {\r\n                                pingSendError = 'Ping returned false';\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            // grpc/grpc-node#2139\r\n                            pingSendError =\r\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\r\n                        }\r\n                        if (pingSendError) {\r\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\r\n                            this.trace('Connection dropped due to ping send error: ' + pingSendError);\r\n                            sessionClosedByServer = true;\r\n                            session.close();\r\n                            return;\r\n                        }\r\n                        keepaliveTimer = setTimeout(() => {\r\n                            clearKeepaliveTimeout();\r\n                            this.keepaliveTrace('Ping timeout passed without response');\r\n                            this.trace('Connection dropped by keepalive timeout');\r\n                            sessionClosedByServer = true;\r\n                            session.close();\r\n                        }, this.keepaliveTimeoutMs);\r\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\r\n                    };\r\n                    maybeStartKeepalivePingTimer();\r\n                    session.on('close', () => {\r\n                        var _b, _c;\r\n                        if (!sessionClosedByServer) {\r\n                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\r\n                        }\r\n                        if (connectionAgeTimer) {\r\n                            clearTimeout(connectionAgeTimer);\r\n                        }\r\n                        if (connectionAgeGraceTimer) {\r\n                            clearTimeout(connectionAgeGraceTimer);\r\n                        }\r\n                        clearKeepaliveTimeout();\r\n                        if (idleTimeoutObj !== null) {\r\n                            clearTimeout(idleTimeoutObj.timeout);\r\n                            this.sessionIdleTimeouts.delete(session);\r\n                        }\r\n                        (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\r\n                    });\r\n                };\r\n            }\r\n            _channelzSessionHandler(http2Server) {\r\n                return (session) => {\r\n                    var _b, _c, _d, _e;\r\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\r\n                    const channelzSessionInfo = {\r\n                        ref: channelzRef,\r\n                        streamTracker: new channelz_1.ChannelzCallTracker(),\r\n                        messagesSent: 0,\r\n                        messagesReceived: 0,\r\n                        keepAlivesSent: 0,\r\n                        lastMessageSentTimestamp: null,\r\n                        lastMessageReceivedTimestamp: null,\r\n                    };\r\n                    (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\r\n                    this.sessions.set(session, channelzSessionInfo);\r\n                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\r\n                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\r\n                    this.trace('Connection established by client ' + clientAddress);\r\n                    this.sessionChildrenTracker.refChild(channelzRef);\r\n                    let connectionAgeTimer = null;\r\n                    let connectionAgeGraceTimer = null;\r\n                    let keepaliveTimeout = null;\r\n                    let sessionClosedByServer = false;\r\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\r\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\r\n                        // Apply a random jitter within a +/-10% range\r\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\r\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\r\n                        connectionAgeTimer = setTimeout(() => {\r\n                            var _b;\r\n                            sessionClosedByServer = true;\r\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\r\n                            try {\r\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);\r\n                            }\r\n                            catch (e) {\r\n                                // The goaway can't be sent because the session is already closed\r\n                                session.destroy();\r\n                                return;\r\n                            }\r\n                            session.close();\r\n                            /* Allow a grace period after sending the GOAWAY before forcibly\r\n                             * closing the connection. */\r\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\r\n                                connectionAgeGraceTimer = setTimeout(() => {\r\n                                    session.destroy();\r\n                                }, this.maxConnectionAgeGraceMs);\r\n                                (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\r\n                            }\r\n                        }, this.maxConnectionAgeMs + jitter);\r\n                        (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\r\n                    }\r\n                    const clearKeepaliveTimeout = () => {\r\n                        if (keepaliveTimeout) {\r\n                            clearTimeout(keepaliveTimeout);\r\n                            keepaliveTimeout = null;\r\n                        }\r\n                    };\r\n                    const canSendPing = () => {\r\n                        return (!session.destroyed &&\r\n                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&\r\n                            this.keepaliveTimeMs > 0);\r\n                    };\r\n                    /* eslint-disable-next-line prefer-const */\r\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\r\n                    const maybeStartKeepalivePingTimer = () => {\r\n                        var _b;\r\n                        if (!canSendPing()) {\r\n                            return;\r\n                        }\r\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\r\n                        keepaliveTimeout = setTimeout(() => {\r\n                            clearKeepaliveTimeout();\r\n                            sendPing();\r\n                        }, this.keepaliveTimeMs);\r\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\r\n                    };\r\n                    sendPing = () => {\r\n                        var _b;\r\n                        if (!canSendPing()) {\r\n                            return;\r\n                        }\r\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\r\n                        let pingSendError = '';\r\n                        try {\r\n                            const pingSentSuccessfully = session.ping((err, duration, payload) => {\r\n                                clearKeepaliveTimeout();\r\n                                if (err) {\r\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\r\n                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +\r\n                                        err.message +\r\n                                        ' return in ' +\r\n                                        duration);\r\n                                    sessionClosedByServer = true;\r\n                                    session.close();\r\n                                }\r\n                                else {\r\n                                    this.keepaliveTrace('Received ping response');\r\n                                    maybeStartKeepalivePingTimer();\r\n                                }\r\n                            });\r\n                            if (!pingSentSuccessfully) {\r\n                                pingSendError = 'Ping returned false';\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            // grpc/grpc-node#2139\r\n                            pingSendError =\r\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\r\n                        }\r\n                        if (pingSendError) {\r\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\r\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);\r\n                            sessionClosedByServer = true;\r\n                            session.close();\r\n                            return;\r\n                        }\r\n                        channelzSessionInfo.keepAlivesSent += 1;\r\n                        keepaliveTimeout = setTimeout(() => {\r\n                            clearKeepaliveTimeout();\r\n                            this.keepaliveTrace('Ping timeout passed without response');\r\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\r\n                            sessionClosedByServer = true;\r\n                            session.close();\r\n                        }, this.keepaliveTimeoutMs);\r\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\r\n                    };\r\n                    maybeStartKeepalivePingTimer();\r\n                    session.on('close', () => {\r\n                        var _b;\r\n                        if (!sessionClosedByServer) {\r\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\r\n                        }\r\n                        this.sessionChildrenTracker.unrefChild(channelzRef);\r\n                        (0, channelz_1.unregisterChannelzRef)(channelzRef);\r\n                        if (connectionAgeTimer) {\r\n                            clearTimeout(connectionAgeTimer);\r\n                        }\r\n                        if (connectionAgeGraceTimer) {\r\n                            clearTimeout(connectionAgeGraceTimer);\r\n                        }\r\n                        clearKeepaliveTimeout();\r\n                        if (idleTimeoutObj !== null) {\r\n                            clearTimeout(idleTimeoutObj.timeout);\r\n                            this.sessionIdleTimeouts.delete(session);\r\n                        }\r\n                        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\r\n                        this.sessions.delete(session);\r\n                    });\r\n                };\r\n            }\r\n            enableIdleTimeout(session) {\r\n                var _b, _c;\r\n                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {\r\n                    return null;\r\n                }\r\n                const idleTimeoutObj = {\r\n                    activeStreams: 0,\r\n                    lastIdle: Date.now(),\r\n                    onClose: this.onStreamClose.bind(this, session),\r\n                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),\r\n                };\r\n                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n                this.sessionIdleTimeouts.set(session, idleTimeoutObj);\r\n                const { socket } = session;\r\n                this.trace('Enable idle timeout for ' +\r\n                    socket.remoteAddress +\r\n                    ':' +\r\n                    socket.remotePort);\r\n                return idleTimeoutObj;\r\n            }\r\n            onIdleTimeout(ctx, session) {\r\n                const { socket } = session;\r\n                const sessionInfo = ctx.sessionIdleTimeouts.get(session);\r\n                // if it is called while we have activeStreams - timer will not be rescheduled\r\n                // until last active stream is closed, then it will call .refresh() on the timer\r\n                // important part is to not clearTimeout(timer) or it becomes unusable\r\n                // for future refreshes\r\n                if (sessionInfo !== undefined &&\r\n                    sessionInfo.activeStreams === 0) {\r\n                    if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {\r\n                        ctx.trace('Session idle timeout triggered for ' +\r\n                            (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) +\r\n                            ':' +\r\n                            (socket === null || socket === void 0 ? void 0 : socket.remotePort) +\r\n                            ' last idle at ' +\r\n                            sessionInfo.lastIdle);\r\n                        ctx.closeSession(session);\r\n                    }\r\n                    else {\r\n                        sessionInfo.timeout.refresh();\r\n                    }\r\n                }\r\n            }\r\n            onStreamOpened(stream) {\r\n                const session = stream.session;\r\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\r\n                if (idleTimeoutObj) {\r\n                    idleTimeoutObj.activeStreams += 1;\r\n                    stream.once('close', idleTimeoutObj.onClose);\r\n                }\r\n            }\r\n            onStreamClose(session) {\r\n                var _b, _c;\r\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\r\n                if (idleTimeoutObj) {\r\n                    idleTimeoutObj.activeStreams -= 1;\r\n                    if (idleTimeoutObj.activeStreams === 0) {\r\n                        idleTimeoutObj.lastIdle = Date.now();\r\n                        idleTimeoutObj.timeout.refresh();\r\n                        this.trace('Session onStreamClose' +\r\n                            ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) +\r\n                            ':' +\r\n                            ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) +\r\n                            ' at ' +\r\n                            idleTimeoutObj.lastIdle);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        (() => {\r\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\r\n            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];\r\n            __esDecorate(_a, null, _start_decorators, { kind: \"method\", name: \"start\", static: false, private: false, access: { has: obj => \"start\" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);\r\n            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\r\n        })(),\r\n        _a;\r\n})();\r\nexports.Server = Server;\r\nasync function handleUnary(call, handler) {\r\n    let stream;\r\n    function respond(err, value, trailer, flags) {\r\n        if (err) {\r\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\r\n            return;\r\n        }\r\n        call.sendMessage(value, () => {\r\n            call.sendStatus({\r\n                code: constants_1.Status.OK,\r\n                details: 'OK',\r\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null,\r\n            });\r\n        });\r\n    }\r\n    let requestMetadata;\r\n    let requestMessage = null;\r\n    call.start({\r\n        onReceiveMetadata(metadata) {\r\n            requestMetadata = metadata;\r\n            call.startRead();\r\n        },\r\n        onReceiveMessage(message) {\r\n            if (requestMessage) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNIMPLEMENTED,\r\n                    details: `Received a second request message for server streaming method ${handler.path}`,\r\n                    metadata: null,\r\n                });\r\n                return;\r\n            }\r\n            requestMessage = message;\r\n            call.startRead();\r\n        },\r\n        onReceiveHalfClose() {\r\n            if (!requestMessage) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNIMPLEMENTED,\r\n                    details: `Received no request message for server streaming method ${handler.path}`,\r\n                    metadata: null,\r\n                });\r\n                return;\r\n            }\r\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\r\n            try {\r\n                handler.func(stream, respond);\r\n            }\r\n            catch (err) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNKNOWN,\r\n                    details: `Server method handler threw error ${err.message}`,\r\n                    metadata: null,\r\n                });\r\n            }\r\n        },\r\n        onCancel() {\r\n            if (stream) {\r\n                stream.cancelled = true;\r\n                stream.emit('cancelled', 'cancelled');\r\n            }\r\n        },\r\n    });\r\n}\r\nfunction handleClientStreaming(call, handler) {\r\n    let stream;\r\n    function respond(err, value, trailer, flags) {\r\n        if (err) {\r\n            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));\r\n            return;\r\n        }\r\n        call.sendMessage(value, () => {\r\n            call.sendStatus({\r\n                code: constants_1.Status.OK,\r\n                details: 'OK',\r\n                metadata: trailer !== null && trailer !== void 0 ? trailer : null,\r\n            });\r\n        });\r\n    }\r\n    call.start({\r\n        onReceiveMetadata(metadata) {\r\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\r\n            try {\r\n                handler.func(stream, respond);\r\n            }\r\n            catch (err) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNKNOWN,\r\n                    details: `Server method handler threw error ${err.message}`,\r\n                    metadata: null,\r\n                });\r\n            }\r\n        },\r\n        onReceiveMessage(message) {\r\n            stream.push(message);\r\n        },\r\n        onReceiveHalfClose() {\r\n            stream.push(null);\r\n        },\r\n        onCancel() {\r\n            if (stream) {\r\n                stream.cancelled = true;\r\n                stream.emit('cancelled', 'cancelled');\r\n                stream.destroy();\r\n            }\r\n        },\r\n    });\r\n}\r\nfunction handleServerStreaming(call, handler) {\r\n    let stream;\r\n    let requestMetadata;\r\n    let requestMessage = null;\r\n    call.start({\r\n        onReceiveMetadata(metadata) {\r\n            requestMetadata = metadata;\r\n            call.startRead();\r\n        },\r\n        onReceiveMessage(message) {\r\n            if (requestMessage) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNIMPLEMENTED,\r\n                    details: `Received a second request message for server streaming method ${handler.path}`,\r\n                    metadata: null,\r\n                });\r\n                return;\r\n            }\r\n            requestMessage = message;\r\n            call.startRead();\r\n        },\r\n        onReceiveHalfClose() {\r\n            if (!requestMessage) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNIMPLEMENTED,\r\n                    details: `Received no request message for server streaming method ${handler.path}`,\r\n                    metadata: null,\r\n                });\r\n                return;\r\n            }\r\n            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);\r\n            try {\r\n                handler.func(stream);\r\n            }\r\n            catch (err) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNKNOWN,\r\n                    details: `Server method handler threw error ${err.message}`,\r\n                    metadata: null,\r\n                });\r\n            }\r\n        },\r\n        onCancel() {\r\n            if (stream) {\r\n                stream.cancelled = true;\r\n                stream.emit('cancelled', 'cancelled');\r\n                stream.destroy();\r\n            }\r\n        },\r\n    });\r\n}\r\nfunction handleBidiStreaming(call, handler) {\r\n    let stream;\r\n    call.start({\r\n        onReceiveMetadata(metadata) {\r\n            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);\r\n            try {\r\n                handler.func(stream);\r\n            }\r\n            catch (err) {\r\n                call.sendStatus({\r\n                    code: constants_1.Status.UNKNOWN,\r\n                    details: `Server method handler threw error ${err.message}`,\r\n                    metadata: null,\r\n                });\r\n            }\r\n        },\r\n        onReceiveMessage(message) {\r\n            stream.push(message);\r\n        },\r\n        onReceiveHalfClose() {\r\n            stream.push(null);\r\n        },\r\n        onCancel() {\r\n            if (stream) {\r\n                stream.cancelled = true;\r\n                stream.emit('cancelled', 'cancelled');\r\n                stream.destroy();\r\n            }\r\n        },\r\n    });\r\n}\r\n//# sourceMappingURL=server.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVGQUF1RjtBQUNoSDtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxnREFBZ0QseUZBQXlGO0FBQ3pJLGdFQUFnRSwyQ0FBMkM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcscUVBQXFFLCtEQUErRDtBQUM5TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdCQUF3QixpRUFBaUU7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsa0JBQWtCLCtCQUErQixvQkFBb0I7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsb0JBQW9CO0FBQzdGO0FBQ0EsdUNBQXVDLGFBQWEsV0FBVyw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsS0FBSztBQUN4RjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixLQUFLO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UscUNBQXFDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd1FBQXdRO0FBQy9ULGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDRFQUE0RTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QixHQUFHLDBCQUEwQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0VBQXdFLG1EQUFtRCx1QkFBdUI7QUFDMU0sd0VBQXdFLHdFQUF3RTtBQUNoSixTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci5qcz9hNTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcclxuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcclxufTtcclxudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcclxuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxyXG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcclxuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xyXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XHJcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xyXG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XHJcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcclxuICAgIGRvbmUgPSB0cnVlO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xyXG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3Qgc2VydmVyX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jYWxsXCIpO1xyXG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcclxuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcclxuY29uc3Qgc2VydmVyX2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWludGVyY2VwdG9yc1wiKTtcclxuY29uc3QgVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TID0gfigxIDw8IDMxKTtcclxuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcclxuY29uc3QgS0VFUEFMSVZFX1RJTUVPVVRfTVMgPSAyMDAwMDtcclxuY29uc3QgTUFYX0NPTk5FQ1RJT05fSURMRV9NUyA9IH4oMSA8PCAzMSk7XHJcbmNvbnN0IHsgSFRUUDJfSEVBREVSX1BBVEggfSA9IGh0dHAyLmNvbnN0YW50cztcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyJztcclxuY29uc3Qga01heEFnZSA9IEJ1ZmZlci5mcm9tKCdtYXhfYWdlJyk7XHJcbmZ1bmN0aW9uIHNlcnZlckNhbGxUcmFjZSh0ZXh0KSB7XHJcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3NlcnZlcl9jYWxsJywgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9vcCgpIHsgfVxyXG4vKipcclxuICogRGVjb3JhdG9yIHRvIHdyYXAgYSBjbGFzcyBtZXRob2Qgd2l0aCB1dGlsLmRlcHJlY2F0ZVxyXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBvdXRwdXQgaWYgdGhlIGRlcHJlY2F0ZWQgbWV0aG9kIGlzIGNhbGxlZFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuZGVwcmVjYXRlKHRhcmdldCwgbWVzc2FnZSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShtZXRob2ROYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxyXG4gICAgICAgIGRldGFpbHM6IGBUaGUgc2VydmVyIGRvZXMgbm90IGltcGxlbWVudCB0aGUgbWV0aG9kICR7bWV0aG9kTmFtZX1gLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0SGFuZGxlcihoYW5kbGVyVHlwZSwgbWV0aG9kTmFtZSkge1xyXG4gICAgY29uc3QgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlID0gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpO1xyXG4gICAgc3dpdGNoIChoYW5kbGVyVHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3VuYXJ5JzpcclxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlLCBudWxsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlICdjbGllbnRTdHJlYW0nOlxyXG4gICAgICAgICAgICByZXR1cm4gKGNhbGwsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UsIG51bGwpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgJ3NlcnZlclN0cmVhbSc6XHJcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSAnYmlkaSc6XHJcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhhbmRsZXJUeXBlICR7aGFuZGxlclR5cGV9YCk7XHJcbiAgICB9XHJcbn1cclxubGV0IFNlcnZlciA9ICgoKSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcclxuICAgIGxldCBfc3RhcnRfZGVjb3JhdG9ycztcclxuICAgIHJldHVybiBfYSA9IGNsYXNzIFNlcnZlciB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFBvcnRzID0gKF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKSwgbmV3IE1hcCgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgZmllbGQgb25seSBleGlzdHMgdG8gZW5zdXJlIHRoYXQgdGhlIHN0YXJ0IG1ldGhvZCB0aHJvd3MgYW4gZXJyb3IgaWZcclxuICAgICAgICAgICAgICAgICAqIGl0IGlzIGNhbGxlZCB0d2ljZSwgYXMgaXQgZGlkIHByZXZpb3VzbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hhbm5lbHogSW5mb1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlU3R1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyU3R1YigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlclN0dWIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcikoJ3NlcnZlcicsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTZXJ2ZXIgY3JlYXRlZCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgPVxyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub3B0aW9uc1snZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyA9XHJcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25uZWN0aW9uX2FnZV9ncmFjZV9tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9XHJcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gdGhpcy5vcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEtFRVBBTElWRV9NQVhfVElNRV9NUztcclxuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dE1zID1cclxuICAgICAgICAgICAgICAgICAgICAoX2UgPSB0aGlzLm9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogS0VFUEFMSVZFX1RJTUVPVVRfTVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZGxlVGltZW91dCA9XHJcbiAgICAgICAgICAgICAgICAgICAgKF9mID0gdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25uZWN0aW9uX2lkbGVfbXMnXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogTUFYX0NPTk5FQ1RJT05fSURMRV9NUztcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gdGhpcy5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXHJcbiAgICAgICAgICAgICAgICAgICAgICogYmVoYXZpb3IgZGVncmFkZXMgYmFkbHkgd2hlbiB0aGlzIGxpbWl0IGlzIHJlYWNoZWQsIHNvIHdlIHNvbHZlIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uU2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoJ2dycGMubWF4X2NvbmN1cnJlbnRfc3RyZWFtcycgaW4gdGhpcy5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zLnNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50U3RyZWFtczogdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnXSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSAoX2cgPSB0aGlzLm9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciBjb25zdHJ1Y3RlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldENoYW5uZWx6SW5mbygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2U6IHRoaXMuY2hhbm5lbHpUcmFjZSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckNoaWxkcmVuOiB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcclxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2hpbGRyZW46IHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldENoYW5uZWx6U2Vzc2lvbkluZm8oc2Vzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHNlc3Npb24uc29ja2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KVxyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KVxyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCB0bHNJbmZvO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uZW5jcnlwdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRsc0luZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2IgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogcGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwZWVyQ2VydGlmaWNhdGUucmF3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogc2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5jYWxsc0ZhaWxlZCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHNlc3Npb25JbmZvLm1lc3NhZ2VzU2VudCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiBzZXNzaW9uSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiBzZXNzaW9uSW5mby5rZWVwQWxpdmVzU2VudCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYyA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2QgPSBzZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2UodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRQcm90b1NlcnZpY2UoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGFkZFNlcnZpY2UoKSBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkU2VydmljZShzZXJ2aWNlLCBpbXBsZW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc2VydmljZSAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbXBsZW1lbnRhdGlvbiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFNlcnZpY2UoKSByZXF1aXJlcyB0d28gb2JqZWN0cyBhcyBhcmd1bWVudHMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VLZXlzID0gT2JqZWN0LmtleXMoc2VydmljZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFuIGVtcHR5IHNlcnZpY2UgdG8gYSBzZXJ2ZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlcnZpY2VLZXlzLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXRob2RUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50U3RyZWFtJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlclN0cmVhbSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW1wbEZuID0gaW1wbGVtZW50YXRpb25bbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltcGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcGxGbiA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhdHRycy5vcmlnaW5hbE5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcGxGbiA9IGltcGxlbWVudGF0aW9uW2F0dHJzLm9yaWdpbmFsTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBsRm4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBsID0gaW1wbEZuLmJpbmQoaW1wbGVtZW50YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wbCA9IGdldERlZmF1bHRIYW5kbGVyKG1ldGhvZFR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gdGhpcy5yZWdpc3RlcihhdHRycy5wYXRoLCBpbXBsLCBhdHRycy5yZXNwb25zZVNlcmlhbGl6ZSwgYXR0cnMucmVxdWVzdERlc2VyaWFsaXplLCBtZXRob2RUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2QgaGFuZGxlciBmb3IgJHthdHRycy5wYXRofSBhbHJlYWR5IHByb3ZpZGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW92ZVNlcnZpY2Uoc2VydmljZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2UgPT09IG51bGwgfHwgdHlwZW9mIHNlcnZpY2UgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVTZXJ2aWNlKCkgcmVxdWlyZXMgb2JqZWN0IGFzIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xyXG4gICAgICAgICAgICAgICAgc2VydmljZUtleXMuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IHNlcnZpY2VbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmluZChwb3J0LCBjcmVkcykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBiaW5kQXN5bmMoKSBpbnN0ZWFkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCwgc28gQVBJIHN0YWJpbGl0eSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgbWlub3IgdmVyc2lvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBib3VuZEFkZHJlc3NcclxuICAgICAgICAgICAgICogQHJldHVybnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbFJlZ2lzdGVyTGlzdGVuZXJUb0NoYW5uZWx6KGJvdW5kQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQpKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShib3VuZEFkZHJlc3MpLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBib3VuZEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBlcmltZW50YWxVbnJlZ2lzdGVyTGlzdGVuZXJGcm9tQ2hhbm5lbHooY2hhbm5lbHpSZWYpIHtcclxuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNyZWF0ZUh0dHAyU2VydmVyKGNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaHR0cDJTZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3JlZGVudGlhbHMuX2lzU2VjdXJlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3Rvck9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0Q29uc3RydWN0b3JPcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dE9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0U2VjdXJlQ29udGV4dE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN1cmVTZXJ2ZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21tb25TZXJ2ZXJPcHRpb25zKSwgY29uc3RydWN0b3JPcHRpb25zKSwgY29udGV4dE9wdGlvbnMpLCB7IGVuYWJsZVRyYWNlOiB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJ10gPT09IDEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZUNyZWRlbnRpYWxzVmFsaWQgPSBjb250ZXh0T3B0aW9ucyAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdJbml0aWFsIGNyZWRlbnRpYWxzIHZhbGlkOiAnICsgYXJlQ3JlZGVudGlhbHNWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZWN1cmVTZXJ2ZXIoc2VjdXJlU2VydmVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucHJlcGVuZExpc3RlbmVyKCdjb25uZWN0aW9uJywgKHNvY2tldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZUNyZWRlbnRpYWxzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Ryb3BwZWQgY29ubmVjdGlvbiBmcm9tICcgKyBKU09OLnN0cmluZ2lmeShzb2NrZXQuYWRkcmVzcygpKSArICcgZHVlIHRvIHVubG9hZGVkIGNyZWRlbnRpYWxzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3NlY3VyZUNvbm5lY3Rpb24nLCAoc29ja2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZXNlIGVycm9ycyBuZWVkIHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIgb2YgSHR0cDJTZWN1cmVTZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFjY29yZGluZyB0byBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzM1ODI0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQW4gaW5jb21pbmcgVExTIGNvbm5lY3Rpb24gY2xvc2VkIHdpdGggZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVkc1dhdGNoZXIgPSBvcHRpb25zID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyZVNlcnZlciA9IGh0dHAyU2VydmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN1cmVTZXJ2ZXIuc2V0U2VjdXJlQ29udGV4dChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIHNldCBzZWN1cmUgY29udGV4dCB3aXRoIGVycm9yICcgKyBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZUNyZWRlbnRpYWxzVmFsaWQgPSBvcHRpb25zICE9PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQb3N0LXVwZGF0ZSBjcmVkZW50aWFscyB2YWxpZDogJyArIGFyZUNyZWRlbnRpYWxzVmFsaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHMuX2FkZFdhdGNoZXIoY3JlZHNXYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLl9yZW1vdmVXYXRjaGVyKGNyZWRzV2F0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlcnZlcih0aGlzLmNvbW1vblNlcnZlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIuc2V0VGltZW91dCgwLCBub29wKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwSGFuZGxlcnMoaHR0cDJTZXJ2ZXIsIGNyZWRlbnRpYWxzLl9nZXRJbnRlcmNlcHRvcnMoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmluZE9uZUFkZHJlc3MoYWRkcmVzcywgYm91bmRQb3J0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBdHRlbXB0aW5nIHRvIGJpbmQgJyArICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBodHRwMlNlcnZlciA9IHRoaXMuY3JlYXRlSHR0cDJTZXJ2ZXIoYm91bmRQb3J0T2JqZWN0LmNyZWRlbnRpYWxzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICdwb3J0JyBpbiBhZGRyZXNzID8gYWRkcmVzcy5wb3J0IDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyZXNzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRBZGRyZXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBib3VuZEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBib3VuZEFkZHJlc3MucG9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSB0aGlzLmV4cGVyaW1lbnRhbFJlZ2lzdGVyTGlzdGVuZXJUb0NoYW5uZWx6KGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlcnMuc2V0KGh0dHAyU2VydmVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselJlZjogY2hhbm5lbHpSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uczogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duc0NoYW5uZWx6UmVmOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycy5hZGQoaHR0cDJTZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYm91bmRTdWJjaGFubmVsQWRkcmVzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICdwb3J0JyBpbiBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID8gYm91bmRTdWJjaGFubmVsQWRkcmVzcy5wb3J0IDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXN5bmMgYmluZE1hbnlQb3J0cyhhZGRyZXNzTGlzdCwgYm91bmRQb3J0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzc0xpc3RbMF0pICYmIGFkZHJlc3NMaXN0WzBdLnBvcnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZiBiaW5kaW5nIHRvIHBvcnQgMCwgZmlyc3QgdHJ5IHRvIGJpbmQgdGhlIGZpcnN0IGFkZHJlc3MsIHRoZW4gYmluZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSByZXN0IG9mIHRoZSBhZGRyZXNzIGxpc3QgdG8gdGhlIHNwZWNpZmljIHBvcnQgdGhhdCBpdCBiaW5kcy4gKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCB0aGlzLmJpbmRPbmVBZGRyZXNzKGFkZHJlc3NMaXN0WzBdLCBib3VuZFBvcnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEFkZHJlc3NSZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIGZpcnN0IGFkZHJlc3MgZmFpbHMgdG8gYmluZCwgdHJ5IHRoZSBzYW1lIG9wZXJhdGlvbiBzdGFydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBmcm9tIHRoZSBzZWNvbmQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCB0aGlzLmJpbmRNYW55UG9ydHMoYWRkcmVzc0xpc3Quc2xpY2UoMSksIGJvdW5kUG9ydE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RBZGRyZXNzUmVzdWx0KSwgeyBlcnJvcnM6IFtmaXJzdEFkZHJlc3NSZXN1bHQuZXJyb3IsIC4uLnJlc3RBZGRyZXNzUmVzdWx0LmVycm9yc10gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN0QWRkcmVzc2VzID0gYWRkcmVzc0xpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGhvc3Q6IGFkZHJlc3MuaG9zdCwgcG9ydDogZmlyc3RBZGRyZXNzUmVzdWx0LnBvcnQgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdEFkZHJlc3NSZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChyZXN0QWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IHRoaXMuYmluZE9uZUFkZHJlc3MoYWRkcmVzcywgYm91bmRQb3J0T2JqZWN0KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxSZXN1bHRzID0gW2ZpcnN0QWRkcmVzc1Jlc3VsdCwgLi4ucmVzdEFkZHJlc3NSZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGFsbFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IgPT09IHVuZGVmaW5lZCkubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogZmlyc3RBZGRyZXNzUmVzdWx0LnBvcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGFsbFJlc3VsdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmVycm9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gdGhpcy5iaW5kT25lQWRkcmVzcyhhZGRyZXNzLCBib3VuZFBvcnRPYmplY3QpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGFsbFJlc3VsdHMuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuZXJyb3IgPT09IHVuZGVmaW5lZCkubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBhbGxSZXN1bHRzWzBdLnBvcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogYWxsUmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LmVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmVycm9yKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzeW5jIGJpbmRBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgYm91bmRQb3J0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kUmVzdWx0ID0gYXdhaXQgdGhpcy5iaW5kTWFueVBvcnRzKGFkZHJlc3NMaXN0LCBib3VuZFBvcnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRSZXN1bHQuY291bnQgPCBhZGRyZXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sIGBXQVJOSU5HIE9ubHkgJHtiaW5kUmVzdWx0LmNvdW50fSBhZGRyZXNzZXMgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZFJlc3VsdC5wb3J0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBgTm8gYWRkcmVzcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYDtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGVycm9yU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JTdHJpbmd9IGVycm9yczogWyR7YmluZFJlc3VsdC5lcnJvcnMuam9pbignLCcpfV1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlUG9ydChwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyTGlzdGVuZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChlbmRwb2ludExpc3QsIHNlcnZpY2VDb25maWcsIHNlcnZpY2VDb25maWdFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uZSByZXNvbHV0aW9uIHJlc3VsdC4gRGlzY2FyZCBhbGwgZnV0dXJlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyTGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9ICgpID0+IHsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NMaXN0ID0gW10uY29uY2F0KC4uLmVuZHBvaW50TGlzdC5tYXAoZW5kcG9pbnQgPT4gZW5kcG9pbnQuYWRkcmVzc2VzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm8gYWRkcmVzc2VzIHJlc29sdmVkIGZvciBwb3J0ICR7cG9ydH1gKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IuZGV0YWlscykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoMCwgcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcikocG9ydCwgcmVzb2x2ZXJMaXN0ZW5lciwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3luYyBiaW5kUG9ydChwb3J0LCBib3VuZFBvcnRPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NMaXN0ID0gYXdhaXQgdGhpcy5yZXNvbHZlUG9ydChwb3J0KTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmluZEFzeW5jIG9wZXJhdGlvbiBjYW5jZWxsZWQgYnkgdW5iaW5kIGNhbGwnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnROdW1iZXIgPSBhd2FpdCB0aGlzLmJpbmRBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgYm91bmRQb3J0T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVVuYmluZChib3VuZFBvcnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmluZEFzeW5jIG9wZXJhdGlvbiBjYW5jZWxsZWQgYnkgdW5iaW5kIGNhbGwnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3J0TnVtYmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVBvcnQocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFBvcnRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShwb3J0KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsUG9ydFVyaSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHBvcnQgXCIke3BvcnR9XCJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRVcmkgPSAoMCwgcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKShpbml0aWFsUG9ydFVyaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydFVyaSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBhIGRlZmF1bHQgc2NoZW1lIGZvciBwb3J0IFwiJHtwb3J0fVwiYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9ydFVyaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiaW5kQXN5bmMocG9ydCwgY3JlZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaHV0ZG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmluZEFzeW5jIGNhbGxlZCBhZnRlciBzaHV0ZG93bicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BvcnQgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNyZWRzID09PSBudWxsIHx8ICEoY3JlZHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjcmVkcyBtdXN0IGJlIGEgU2VydmVyQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdiaW5kQXN5bmMgcG9ydD0nICsgcG9ydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0VXJpID0gdGhpcy5ub3JtYWxpemVQb3J0KHBvcnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWRDYWxsYmFjayA9IChlcnJvciwgcG9ydCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gY2FsbGJhY2soZXJyb3IsIHBvcnQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKiBGaXJzdCwgaWYgdGhpcyBwb3J0IGlzIGFscmVhZHkgYm91bmQgb3IgdGhhdCBiaW5kIG9wZXJhdGlvbiBpcyBpblxyXG4gICAgICAgICAgICAgICAgICogcHJvZ3Jlc3MsIHVzZSB0aGF0IHJlc3VsdC4gKi9cclxuICAgICAgICAgICAgICAgIGxldCBib3VuZFBvcnRPYmplY3QgPSB0aGlzLmJvdW5kUG9ydHMuZ2V0KCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBvcnRVcmkpKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNyZWRzLl9lcXVhbHMoYm91bmRQb3J0T2JqZWN0LmNyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihgJHtwb3J0fSBhbHJlYWR5IGJvdW5kIHdpdGggaW5jb21wYXRpYmxlIGNyZWRlbnRpYWxzYCksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoYXQgb3BlcmF0aW9uIGhhcyBwcmV2aW91c2x5IGJlZW4gY2FuY2VsbGVkIGJ5IGFuIHVuYmluZCBjYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHVuY2FuY2VsIGl0LiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZS50aGVuKHBvcnROdW0gPT4gY2FsbGJhY2sobnVsbCwgcG9ydE51bSksIGVycm9yID0+IGNhbGxiYWNrKGVycm9yLCAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG51bGwsIGJvdW5kUG9ydE9iamVjdC5wb3J0TnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcEtleTogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocG9ydFVyaSksXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxVcmk6IHBvcnRVcmksXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblByb21pc2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBwb3J0TnVtYmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBjcmVkcyxcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5pbmdTZXJ2ZXJzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwb3J0VXJpLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvblByb21pc2UgPSB0aGlzLmJpbmRQb3J0KHBvcnRVcmksIGJvdW5kUG9ydE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY29tcGxldGlvblByb21pc2UgPSBjb21wbGV0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBwb3J0IG51bWJlciBpcyAwLCBkZWZlciBwb3B1bGF0aW5nIHRoZSBtYXAgZW50cnkgdW50aWwgYWZ0ZXIgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBiaW5kIG9wZXJhdGlvbiBjb21wbGV0ZXMgYW5kIHdlIGhhdmUgYSBzcGVjaWZpYyBwb3J0IG51bWJlci4gT3RoZXJ3aXNlLFxyXG4gICAgICAgICAgICAgICAgICogcG9wdWxhdGUgaXQgaW1tZWRpYXRlbHkuICovXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNwbGl0UG9ydCA9PT0gbnVsbCB8fCBzcGxpdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwbGl0UG9ydC5wb3J0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlLnRoZW4ocG9ydE51bSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXJpID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1lOiBwb3J0VXJpLnNjaGVtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml0eTogcG9ydFVyaS5hdXRob3JpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAoMCwgdXJpX3BhcnNlcl8xLmNvbWJpbmVIb3N0UG9ydCkoeyBob3N0OiBzcGxpdFBvcnQuaG9zdCwgcG9ydDogcG9ydE51bSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0Lm1hcEtleSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKGZpbmFsVXJpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNvbXBsZXRpb25Qcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LnBvcnROdW1iZXIgPSBwb3J0TnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMuc2V0KGJvdW5kUG9ydE9iamVjdC5tYXBLZXksIGJvdW5kUG9ydE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBvcnROdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZFBvcnRzLnNldChib3VuZFBvcnRPYmplY3QubWFwS2V5LCBib3VuZFBvcnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlLnRoZW4ocG9ydE51bSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5wb3J0TnVtYmVyID0gcG9ydE51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcG9ydE51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVnaXN0ZXJJbmplY3RvclRvQ2hhbm5lbHooKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkoJ2luamVjdG9yJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwsIHNvIEFQSSBzdGFiaWxpdHkgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIG1pbm9yIHZlcnNpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICogQHBhcmFtIGNoYW5uZWx6UmVmXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBleHBlcmltZW50YWxDcmVhdGVDb25uZWN0aW9uSW5qZWN0b3JXaXRoQ2hhbm5lbHpSZWYoY3JlZGVudGlhbHMsIGNoYW5uZWx6UmVmLCBvd25zQ2hhbm5lbHpSZWYgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzID09PSBudWxsIHx8ICEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjcmVkcyBtdXN0IGJlIGEgU2VydmVyQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuY3JlYXRlSHR0cDJTZXJ2ZXIoY3JlZGVudGlhbHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbnNTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVycy5zZXQoc2VydmVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWY6IGNoYW5uZWx6UmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25zOiBzZXNzaW9uc1NldCxcclxuICAgICAgICAgICAgICAgICAgICBvd25zQ2hhbm5lbHpSZWZcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RDb25uZWN0aW9uOiAoY29ubmVjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuZW1pdCgnY29ubmVjdGlvbicsIGNvbm5lY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhaW46IChncmFjZVRpbWVNcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnNTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zU2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGdyYWNlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlcnZlcihzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnNTZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uSW5qZWN0b3IoY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjcmVkZW50aWFscyA9PT0gbnVsbCB8fCAhKGNyZWRlbnRpYWxzIGluc3RhbmNlb2Ygc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY3JlZHMgbXVzdCBiZSBhIFNlcnZlckNyZWRlbnRpYWxzIG9iamVjdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSB0aGlzLnJlZ2lzdGVySW5qZWN0b3JUb0NoYW5uZWx6KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBlcmltZW50YWxDcmVhdGVDb25uZWN0aW9uSW5qZWN0b3JXaXRoQ2hhbm5lbHpSZWYoY3JlZGVudGlhbHMsIGNoYW5uZWx6UmVmLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbG9zZVNlcnZlcihzZXJ2ZXIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdDbG9zaW5nIHNlcnZlciB3aXRoIGFkZHJlc3MgJyArIEpTT04uc3RyaW5naWZ5KHNlcnZlci5hZGRyZXNzKCkpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoc2VydmVyKTtcclxuICAgICAgICAgICAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm8gJiYgc2VydmVySW5mby5vd25zQ2hhbm5lbHpSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHNlcnZlckluZm8uY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHNlcnZlckluZm8uY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh0dHAyU2VydmVycy5kZWxldGUoc2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsb3NlU2Vzc2lvbihzZXNzaW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ2xvc2luZyBzZXNzaW9uIGluaXRpYXRlZCBieSAnICsgKChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcykpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSB0aGlzLnNlc3Npb25zLmdldChzZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ2FsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25JbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHNlc3Npb25JbmZvLnJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoc2Vzc2lvbkluZm8ucmVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xvc2VDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKGNsb3NlQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBsZXRlVW5iaW5kKGJvdW5kUG9ydE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgYm91bmRQb3J0T2JqZWN0Lmxpc3RlbmluZ1NlcnZlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KHNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlcnZlcihzZXJ2ZXIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0Lmxpc3RlbmluZ1NlcnZlcnMuZGVsZXRlKHNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlcnZlckluZm8uc2Vzc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFBvcnRzLmRlbGV0ZShib3VuZFBvcnRPYmplY3QubWFwS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5iaW5kIGEgcHJldmlvdXNseSBib3VuZCBwb3J0LCBvciBjYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgYmluZEFzeW5jXHJcbiAgICAgICAgICAgICAqIG9wZXJhdGlvbi4gSWYgcG9ydCAwIHdhcyBib3VuZCwgb25seSB0aGUgYWN0dWFsIGJvdW5kIHBvcnQgY2FuIGJlXHJcbiAgICAgICAgICAgICAqIHVuYm91bmQuIEZvciBleGFtcGxlLCBpZiBiaW5kQXN5bmMgd2FzIGNhbGxlZCB3aXRoIFwibG9jYWxob3N0OjBcIiBhbmQgdGhlXHJcbiAgICAgICAgICAgICAqIGJvdW5kIHBvcnQgcmVzdWx0IHdhcyA1NDMyMSwgaXQgY2FuIGJlIHVuYm91bmQgYXMgXCJsb2NhbGhvc3Q6NTQzMjFcIi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHBvcnRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHVuYmluZChwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCd1bmJpbmQgcG9ydD0nICsgcG9ydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0VXJpID0gdGhpcy5ub3JtYWxpemVQb3J0KHBvcnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KShwb3J0VXJpLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChzcGxpdFBvcnQgPT09IG51bGwgfHwgc3BsaXRQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdFBvcnQucG9ydCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bmJpbmQgcG9ydCAwJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZFBvcnRPYmplY3QgPSB0aGlzLmJvdW5kUG9ydHMuZ2V0KCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBvcnRVcmkpKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZFBvcnRPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCd1bmJpbmRpbmcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUG9ydE9iamVjdC5tYXBLZXkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIG9yaWdpbmFsbHkgYm91bmQgYXMgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKGJvdW5kUG9ydE9iamVjdC5vcmlnaW5hbFVyaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiaW5kIG9wZXJhdGlvbiBpcyBwZW5kaW5nLCB0aGUgY2FuY2VsbGVkIGZsYWcgd2lsbCB0cmlnZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIHVuYmluZCBvcGVyYXRpb24gbGF0ZXIuICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kUG9ydE9iamVjdC5jb21wbGV0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZFBvcnRPYmplY3QuY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVVbmJpbmQoYm91bmRQb3J0T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdyYWNlZnVsbHkgY2xvc2UgYWxsIGNvbm5lY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCBhIHByZXZpb3VzbHkgYm91bmQgcG9ydC5cclxuICAgICAgICAgICAgICogQWZ0ZXIgdGhlIGdyYWNlIHRpbWUsIGZvcmNlZnVsbHkgY2xvc2UgYWxsIHJlbWFpbmluZyBvcGVuIGNvbm5lY3Rpb25zLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBJZiBwb3J0IDAgd2FzIGJvdW5kLCBvbmx5IHRoZSBhY3R1YWwgYm91bmQgcG9ydCBjYW4gYmVcclxuICAgICAgICAgICAgICogZHJhaW5lZC4gRm9yIGV4YW1wbGUsIGlmIGJpbmRBc3luYyB3YXMgY2FsbGVkIHdpdGggXCJsb2NhbGhvc3Q6MFwiIGFuZCB0aGVcclxuICAgICAgICAgICAgICogYm91bmQgcG9ydCByZXN1bHQgd2FzIDU0MzIxLCBpdCBjYW4gYmUgZHJhaW5lZCBhcyBcImxvY2FsaG9zdDo1NDMyMVwiLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gcG9ydFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZ3JhY2VUaW1lTXNcclxuICAgICAgICAgICAgICogQHJldHVybnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGRyYWluKHBvcnQsIGdyYWNlVGltZU1zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnZHJhaW4gcG9ydD0nICsgcG9ydCArICcgZ3JhY2VUaW1lTXM9JyArIGdyYWNlVGltZU1zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRVcmkgPSB0aGlzLm5vcm1hbGl6ZVBvcnQocG9ydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBvcnRVcmkucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHNwbGl0UG9ydCA9PT0gbnVsbCB8fCBzcGxpdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwbGl0UG9ydC5wb3J0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRyYWluIHBvcnQgMCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRQb3J0T2JqZWN0ID0gdGhpcy5ib3VuZFBvcnRzLmdldCgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShwb3J0VXJpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kUG9ydE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFNlc3Npb25zID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBodHRwMlNlcnZlciBvZiBib3VuZFBvcnRPYmplY3QubGlzdGVuaW5nU2VydmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gdGhpcy5odHRwMlNlcnZlcnMuZ2V0KGh0dHAyU2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyRW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIHNlcnZlckVudHJ5LnNlc3Npb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxTZXNzaW9ucy5hZGQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU2Vzc2lvbihzZXNzaW9uLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBBZnRlciB0aGUgZ3JhY2UgdGltZSBlbmRzLCBzZW5kIGFub3RoZXIgZ29hd2F5IHRvIGFsbCByZW1haW5pbmcgc2Vzc2lvbnNcclxuICAgICAgICAgICAgICAgICAqIHdpdGggdGhlIENBTkNFTCBjb2RlLiAqL1xyXG4gICAgICAgICAgICAgICAgKF9jID0gKF9iID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXNzaW9uIG9mIGFsbFNlc3Npb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIGdyYWNlVGltZU1zKSkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JjZVNodXRkb3duKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBib3VuZFBvcnRPYmplY3Qgb2YgdGhpcy5ib3VuZFBvcnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQb3J0T2JqZWN0LmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kUG9ydHMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgaXQgaXMgc3RpbGwgcnVubmluZy5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VydmVyIG9mIHRoaXMuaHR0cDJTZXJ2ZXJzLmtleXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXJ2ZXIoc2VydmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBkZXN0cm95IGFueSBhdmFpbGFibGUgc2Vzc2lvbnMuIEl0J3MgcG9zc2libGUgdGhhdCBvbmUgb3IgbW9yZVxyXG4gICAgICAgICAgICAgICAgLy8gdHJ5U2h1dGRvd24oKSBjYWxscyBhcmUgaW4gcHJvZ3Jlc3MuIERvbid0IHdhaXQgb24gdGhlbSB0byBmaW5pc2guXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhc3QgTkdIVFRQMl9DQU5DRUwgdG8gYW55IGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHNlZW0gdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvZ25pemUgZGVzdHJveShjb2RlKSBhcyBhIHZhbGlkIHNpZ25hdHVyZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveShodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5zZXQobmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmM6IGhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbmFtZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5yZWdpc3RlcihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciBuZWVkZWQgYXMgb2YgdmVyc2lvbiAxLjEwLnhcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHN0YXJ0KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaHR0cDJTZXJ2ZXJzLnNpemUgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBbLi4udGhpcy5odHRwMlNlcnZlcnMua2V5cygpXS5ldmVyeShzZXJ2ZXIgPT4gIXNlcnZlci5saXN0ZW5pbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgbXVzdCBiZSBib3VuZCBpbiBvcmRlciB0byBzdGFydCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VydmVyIGlzIGFscmVhZHkgc3RhcnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnlTaHV0ZG93bihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdDaGVja3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzLS07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzZXJ2ZXJLZXksIHNlcnZlcl0gb2YgdGhpcy5odHRwMlNlcnZlcnMuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoZWNrcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN0cmluZyA9IHNlcnZlci5jaGFubmVselJlZi5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1dhaXRpbmcgZm9yIHNlcnZlciAnICsgc2VydmVyU3RyaW5nICsgJyB0byBjbG9zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXJ2ZXIoc2VydmVyS2V5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1NlcnZlciAnICsgc2VydmVyU3RyaW5nICsgJyBmaW5pc2hlZCBjbG9zaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2VydmVyLnNlc3Npb25zLmtleXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hlY2tzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TdHJpbmcgPSAoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1dhaXRpbmcgZm9yIHNlc3Npb24gJyArIHNlc3Npb25TdHJpbmcgKyAnIHRvIGNsb3NlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTZXNzaW9uKHNlc3Npb24sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1Nlc3Npb24gJyArIHNlc3Npb25TdHJpbmcgKyAnIGZpbmlzaGVkIGNsb3NpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRIdHRwMlBvcnQoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIHNlcnZlci4gVGhlIHJldHVybmVkIHZhbHVlIGlzXHJcbiAgICAgICAgICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgc2VydmVyLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VHlwZSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgICAgICAgICAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vZ3JwYycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlc3BvbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfVU5TVVBQT1JURURfTUVESUFfVFlQRSxcclxuICAgICAgICAgICAgICAgICAgICB9LCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfcmV0cmlldmVIYW5kbGVyKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlckNhbGxUcmFjZSgnUmVjZWl2ZWQgY2FsbCB0byBtZXRob2QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBhdCBhZGRyZXNzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQ2FsbFRyYWNlKCdObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIG1ldGhvZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcuIFNlbmRpbmcgVU5JTVBMRU1FTlRFRCBzdGF0dXMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfcmVzcG9uZFdpdGhFcnJvcihlcnIsIHN0cmVhbSwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oeyAnZ3JwYy1zdGF0dXMnOiAoX2IgPSBlcnIuY29kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnZ3JwYy1tZXNzYWdlJzogZXJyLmRldGFpbHMsIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSywgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nIH0sIChfYyA9IGVyci5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSHR0cDJIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlc3BvbmQodHJhaWxlcnNUb1NlbmQsIHsgZW5kU3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX2NoYW5uZWx6SGFuZGxlcihleHRyYUludGVyY2VwdG9ycywgc3RyZWFtLCBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgaGFuZGxpbmcgaWRsZSB0aW1lb3V0XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RyZWFtT3BlbmVkKHN0cmVhbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc3RyZWFtLnNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZFdpdGhFcnJvcihnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UocGF0aCksIHN0cmVhbSwgY2hhbm5lbHpTZXNzaW9uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEV2ZW50VHJhY2tlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVselNlc3Npb25JbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLm1lc3NhZ2VzUmVjZWl2ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kOiBzdWNjZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWx6U2Vzc2lvbkluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgc2VydmVyX2ludGVyY2VwdG9yc18xLmdldFNlcnZlckludGVyY2VwdGluZ0NhbGwpKFsuLi5leHRyYUludGVyY2VwdG9ycywgLi4udGhpcy5pbnRlcmNlcHRvcnNdLCBzdHJlYW0sIGhlYWRlcnMsIGNhbGxFdmVudFRyYWNrZXIsIGhhbmRsZXIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gbnVsbCB8fCBjaGFubmVselNlc3Npb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdHJlYW1IYW5kbGVyKGV4dHJhSW50ZXJjZXB0b3JzLCBzdHJlYW0sIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvciBoYW5kbGluZyBpZGxlIHRpbWVvdXRcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdHJlYW1PcGVuZWQoc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92ZXJpZnlDb250ZW50VHlwZShzdHJlYW0sIGhlYWRlcnMpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGhlYWRlcnNbSFRUUDJfSEVBREVSX1BBVEhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3JldHJpZXZlSGFuZGxlcihwYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRXaXRoRXJyb3IoZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKHBhdGgpLCBzdHJlYW0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgc2VydmVyX2ludGVyY2VwdG9yc18xLmdldFNlcnZlckludGVyY2VwdGluZ0NhbGwpKFsuLi5leHRyYUludGVyY2VwdG9ycywgLi4udGhpcy5pbnRlcmNlcHRvcnNdLCBzdHJlYW0sIGhlYWRlcnMsIG51bGwsIGhhbmRsZXIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5rbm93biBoYW5kbGVyIHR5cGU6ICR7aGFuZGxlci50eXBlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVW5hcnkoY2FsbCwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY2xpZW50U3RyZWFtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsaWVudFN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzZXJ2ZXJTdHJlYW0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQmlkaVN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zZXR1cEhhbmRsZXJzKGh0dHAyU2VydmVyLCBleHRyYUludGVyY2VwdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcnZlckFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9IHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuY2hhbm5lbHpFbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jaGFubmVsekhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uSGFuZGxlciA9IHRoaXMuY2hhbm5lbHpFbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jaGFubmVselNlc3Npb25IYW5kbGVyKGh0dHAyU2VydmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fc2Vzc2lvbkhhbmRsZXIoaHR0cDJTZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3N0cmVhbScsIGhhbmRsZXIuYmluZCh0aGlzLCBleHRyYUludGVyY2VwdG9ycykpO1xyXG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIub24oJ3Nlc3Npb24nLCBzZXNzaW9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3Nlc3Npb25IYW5kbGVyKGh0dHAyU2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlc3Npb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXNzaW9ucy5hZGQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuZW5hYmxlSWRsZVRpbWVvdXQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zICE9PSBVTkxJTUlURURfQ09OTkVDVElPTl9BR0VfTVMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYSByYW5kb20gaml0dGVyIHdpdGhpbiBhICsvLTEwJSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSB0aGlzLm1heENvbm5lY3Rpb25BZ2VNcyAvIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogaml0dGVyTWFnbml0dWRlICogMiAtIGppdHRlck1hZ25pdHVkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFnZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBtYXggY29ubmVjdGlvbiBhZ2U6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nb2F3YXkoaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1IsIH4oMSA8PCAzMSksIGtNYXhBZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ29hd2F5IGNhbid0IGJlIHNlbnQgYmVjYXVzZSB0aGUgc2Vzc2lvbiBpcyBhbHJlYWR5IGNsb3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFsbG93IGEgZ3JhY2UgcGVyaW9kIGFmdGVyIHNlbmRpbmcgdGhlIEdPQVdBWSBiZWZvcmUgZm9yY2libHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFnZUdyYWNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gY29ubmVjdGlvbkFnZUdyYWNlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgKyBqaXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBjb25uZWN0aW9uQWdlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGNvbm5lY3Rpb25BZ2VUaW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFyS2VlcGFsaXZlVGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBhbGl2ZVRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoa2VlcGFsaXZlVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5TZW5kUGluZyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghc2Vzc2lvbi5kZXN0cm95ZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zIDwgS0VFUEFMSVZFX01BWF9USU1FX01TICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZW5kUGluZzsgLy8gaG9pc3RlZCBmb3IgdXNlIGluIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRQaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRQaW5nID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwaW5nU2VuZEVycm9yID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaW5nU2VudFN1Y2Nlc3NmdWxseSA9IHNlc3Npb24ucGluZygoZXJyLCBkdXJhdGlvbiwgcGF5bG9hZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNsb3NlZEJ5U2VydmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBpbmdTZW50U3VjY2Vzc2Z1bGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9ICdQaW5nIHJldHVybmVkIGZhbHNlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluZ1NlbmRFcnJvciA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICcnKSB8fCAnVW5rbm93biBlcnJvcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpbmdTZW5kRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1Bpbmcgc2VuZCBmYWlsZWQ6ICcgKyBwaW5nU2VuZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0Nvbm5lY3Rpb24gZHJvcHBlZCBkdWUgdG8gcGluZyBzZW5kIGVycm9yOiAnICsgcGluZ1NlbmRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IGtlZXBhbGl2ZSB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGtlZXBhbGl2ZVRpbWVyLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChrZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkNsb3NlZEJ5U2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKGBDb25uZWN0aW9uIGRyb3BwZWQgYnkgY2xpZW50ICR7KF9iID0gc2Vzc2lvbi5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdGVBZGRyZXNzfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlVGltZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWdlVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWRsZVRpbWVvdXRPYmoudGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25JZGxlVGltZW91dHMuZGVsZXRlKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcikpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9jaGFubmVselNlc3Npb25IYW5kbGVyKGh0dHAyU2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNlc3Npb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSgoX2MgPSAoX2IgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW90ZUFkZHJlc3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICd1bmtub3duJywgdGhpcy5nZXRDaGFubmVselNlc3Npb25JbmZvLmJpbmQodGhpcywgc2Vzc2lvbiksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNoYW5uZWx6UmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1UcmFja2VyOiBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuaHR0cDJTZXJ2ZXJzLmdldChodHRwMlNlcnZlcikpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zZXNzaW9ucy5hZGQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbiwgY2hhbm5lbHpTZXNzaW9uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50QWRkcmVzcyA9IGAke3Nlc3Npb24uc29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c2Vzc2lvbi5zb2NrZXQucmVtb3RlUG9ydH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGVzdGFibGlzaGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ29ubmVjdGlvbiBlc3RhYmxpc2hlZCBieSBjbGllbnQgJyArIGNsaWVudEFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGFubmVselJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2VlcGFsaXZlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVUaW1lb3V0T2JqID0gdGhpcy5lbmFibGVJZGxlVGltZW91dChzZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgIT09IFVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhIHJhbmRvbSBqaXR0ZXIgd2l0aGluIGEgKy8tMTAlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGppdHRlck1hZ25pdHVkZSA9IHRoaXMubWF4Q29ubmVjdGlvbkFnZU1zIC8gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiBqaXR0ZXJNYWduaXR1ZGUgKiAyIC0gaml0dGVyTWFnbml0dWRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQWdlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IG1heCBjb25uZWN0aW9uIGFnZSBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nb2F3YXkoaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1IsIH4oMSA8PCAzMSksIGtNYXhBZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ29hd2F5IGNhbid0IGJlIHNlbnQgYmVjYXVzZSB0aGUgc2Vzc2lvbiBpcyBhbHJlYWR5IGNsb3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFsbG93IGEgZ3JhY2UgcGVyaW9kIGFmdGVyIHNlbmRpbmcgdGhlIEdPQVdBWSBiZWZvcmUgZm9yY2libHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyAhPT0gVU5MSU1JVEVEX0NPTk5FQ1RJT05fQUdFX01TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkFnZUdyYWNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlR3JhY2VNcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gY29ubmVjdGlvbkFnZUdyYWNlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNvbm5lY3Rpb25BZ2VHcmFjZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5tYXhDb25uZWN0aW9uQWdlTXMgKyBqaXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2UgPSBjb25uZWN0aW9uQWdlVGltZXIudW5yZWYpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKGNvbm5lY3Rpb25BZ2VUaW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFyS2VlcGFsaXZlVGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBhbGl2ZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5TZW5kUGluZyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghc2Vzc2lvbi5kZXN0cm95ZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zIDwgS0VFUEFMSVZFX01BWF9USU1FX01TICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZW5kUGluZzsgLy8gaG9pc3RlZCBmb3IgdXNlIGluIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFBpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBrZWVwYWxpdmVUaW1lb3V0LnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRQaW5nID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuU2VuZFBpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwaW5nU2VuZEVycm9yID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaW5nU2VudFN1Y2Nlc3NmdWxseSA9IHNlc3Npb24ucGluZygoZXJyLCBkdXJhdGlvbiwgcGF5bG9hZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBkdWUgdG8gZXJyb3Igb2YgYSBwaW5nIGZyYW1lICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyByZXR1cm4gaW4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwaW5nU2VudFN1Y2Nlc3NmdWxseSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPSAnUGluZyByZXR1cm5lZCBmYWxzZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdycGMvZ3JwYy1ub2RlIzIxMzlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnJykgfHwgJ1Vua25vd24gZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHNlbmQgZmFpbGVkOiAnICsgcGluZ1NlbmRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGR1ZSB0byBwaW5nIHNlbmQgZXJyb3I6ICcgKyBwaW5nU2VuZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5rZWVwQWxpdmVzU2VudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSBrZWVwYWxpdmUgdGltZW91dCBmcm9tICcgKyBjbGllbnRBZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25DbG9zZWRCeVNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0ga2VlcGFsaXZlVGltZW91dC51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoa2VlcGFsaXZlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5vbignY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uQ2xvc2VkQnlTZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGRyb3BwZWQgYnkgY2xpZW50ICcgKyBjbGllbnRBZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGFubmVselJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikoY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkFnZVRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFnZVRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkFnZUdyYWNlVGltZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uQWdlR3JhY2VUaW1lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGxlVGltZW91dE9iaiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkbGVUaW1lb3V0T2JqLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWRsZVRpbWVvdXRzLmRlbGV0ZShzZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmh0dHAyU2VydmVycy5nZXQoaHR0cDJTZXJ2ZXIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Vzc2lvbnMuZGVsZXRlKHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5hYmxlSWRsZVRpbWVvdXQoc2Vzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb25JZGxlVGltZW91dCA+PSBNQVhfQ09OTkVDVElPTl9JRExFX01TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW1zOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJZGxlOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U6IHRoaXMub25TdHJlYW1DbG9zZS5iaW5kKHRoaXMsIHNlc3Npb24pLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQodGhpcy5vbklkbGVUaW1lb3V0LCB0aGlzLnNlc3Npb25JZGxlVGltZW91dCwgdGhpcywgc2Vzc2lvbiksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgKF9jID0gKF9iID0gaWRsZVRpbWVvdXRPYmoudGltZW91dCkudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5zZXQoc2Vzc2lvbiwgaWRsZVRpbWVvdXRPYmopO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IHNlc3Npb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdFbmFibGUgaWRsZSB0aW1lb3V0IGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3RlQWRkcmVzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3RlUG9ydCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRsZVRpbWVvdXRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25JZGxlVGltZW91dChjdHgsIHNlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc29ja2V0IH0gPSBzZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkluZm8gPSBjdHguc2Vzc2lvbklkbGVUaW1lb3V0cy5nZXQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBjYWxsZWQgd2hpbGUgd2UgaGF2ZSBhY3RpdmVTdHJlYW1zIC0gdGltZXIgd2lsbCBub3QgYmUgcmVzY2hlZHVsZWRcclxuICAgICAgICAgICAgICAgIC8vIHVudGlsIGxhc3QgYWN0aXZlIHN0cmVhbSBpcyBjbG9zZWQsIHRoZW4gaXQgd2lsbCBjYWxsIC5yZWZyZXNoKCkgb24gdGhlIHRpbWVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgcGFydCBpcyB0byBub3QgY2xlYXJUaW1lb3V0KHRpbWVyKSBvciBpdCBiZWNvbWVzIHVudXNhYmxlXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgZnV0dXJlIHJlZnJlc2hlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25JbmZvICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby5hY3RpdmVTdHJlYW1zID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzZXNzaW9uSW5mby5sYXN0SWRsZSA+PSBjdHguc2Vzc2lvbklkbGVUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFjZSgnU2Vzc2lvbiBpZGxlIHRpbWVvdXQgdHJpZ2dlcmVkIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlQWRkcmVzcykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlUG9ydCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBsYXN0IGlkbGUgYXQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby5sYXN0SWRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVNlc3Npb24oc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby50aW1lb3V0LnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25TdHJlYW1PcGVuZWQoc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gc3RyZWFtLnNlc3Npb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dE9iaiA9IHRoaXMuc2Vzc2lvbklkbGVUaW1lb3V0cy5nZXQoc2Vzc2lvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVvdXRPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGxlVGltZW91dE9iai5hY3RpdmVTdHJlYW1zICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgaWRsZVRpbWVvdXRPYmoub25DbG9zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25TdHJlYW1DbG9zZShzZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZVRpbWVvdXRPYmogPSB0aGlzLnNlc3Npb25JZGxlVGltZW91dHMuZ2V0KHNlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lb3V0T2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmouYWN0aXZlU3RyZWFtcyAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZGxlVGltZW91dE9iai5hY3RpdmVTdHJlYW1zID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0T2JqLmxhc3RJZGxlID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRPYmoudGltZW91dC5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1Nlc3Npb24gb25TdHJlYW1DbG9zZScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHNlc3Npb24uc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3RlQWRkcmVzcykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBzZXNzaW9uLnNvY2tldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlbW90ZVBvcnQpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYXQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGxlVGltZW91dE9iai5sYXN0SWRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgX3N0YXJ0X2RlY29yYXRvcnMgPSBbZGVwcmVjYXRlKCdDYWxsaW5nIHN0YXJ0KCkgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS4gSXQgY2FuIGJlIHNhZmVseSBvbWl0dGVkLicpXTtcclxuICAgICAgICAgICAgX19lc0RlY29yYXRlKF9hLCBudWxsLCBfc3RhcnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInN0YXJ0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzdGFydFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnN0YXJ0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xyXG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2EsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xyXG4gICAgICAgIH0pKCksXHJcbiAgICAgICAgX2E7XHJcbn0pKCk7XHJcbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyKSB7XHJcbiAgICBsZXQgc3RyZWFtO1xyXG4gICAgZnVuY3Rpb24gcmVzcG9uZChlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncykge1xyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKCgwLCBzZXJ2ZXJfY2FsbF8xLnNlcnZlckVycm9yVG9TdGF0dXMpKGVyciwgdHJhaWxlcikpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UodmFsdWUsICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogdHJhaWxlciAhPT0gbnVsbCAmJiB0cmFpbGVyICE9PSB2b2lkIDAgPyB0cmFpbGVyIDogbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVxdWVzdE1ldGFkYXRhO1xyXG4gICAgbGV0IHJlcXVlc3RNZXNzYWdlID0gbnVsbDtcclxuICAgIGNhbGwuc3RhcnQoe1xyXG4gICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RNZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgYSBzZWNvbmQgcmVxdWVzdCBtZXNzYWdlIGZvciBzZXJ2ZXIgc3RyZWFtaW5nIG1ldGhvZCAke2hhbmRsZXIucGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdE1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICBjYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVELFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBubyByZXF1ZXN0IG1lc3NhZ2UgZm9yIHNlcnZlciBzdHJlYW1pbmcgbWV0aG9kICR7aGFuZGxlci5wYXRofWAsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCByZXF1ZXN0TWV0YWRhdGEsIHJlcXVlc3RNZXNzYWdlKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlcnZlciBtZXRob2QgaGFuZGxlciB0aHJldyBlcnJvciAke2Vyci5tZXNzYWdlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DYW5jZWwoKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcikge1xyXG4gICAgbGV0IHN0cmVhbTtcclxuICAgIGZ1bmN0aW9uIHJlc3BvbmQoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cygoMCwgc2VydmVyX2NhbGxfMS5zZXJ2ZXJFcnJvclRvU3RhdHVzKShlcnIsIHRyYWlsZXIpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKHZhbHVlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWlsZXIgIT09IG51bGwgJiYgdHJhaWxlciAhPT0gdm9pZCAwID8gdHJhaWxlciA6IG51bGwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2FsbC5zdGFydCh7XHJcbiAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyRHVwbGV4U3RyZWFtSW1wbChoYW5kbGVyLnBhdGgsIGNhbGwsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFNlcnZlciBtZXRob2QgaGFuZGxlciB0aHJldyBlcnJvciAke2Vyci5tZXNzYWdlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25SZWNlaXZlSGFsZkNsb3NlKCkge1xyXG4gICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2FuY2VsKCkge1xyXG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVNlcnZlclN0cmVhbWluZyhjYWxsLCBoYW5kbGVyKSB7XHJcbiAgICBsZXQgc3RyZWFtO1xyXG4gICAgbGV0IHJlcXVlc3RNZXRhZGF0YTtcclxuICAgIGxldCByZXF1ZXN0TWVzc2FnZSA9IG51bGw7XHJcbiAgICBjYWxsLnN0YXJ0KHtcclxuICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0TWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIGEgc2Vjb25kIHJlcXVlc3QgbWVzc2FnZSBmb3Igc2VydmVyIHN0cmVhbWluZyBtZXRob2QgJHtoYW5kbGVyLnBhdGh9YCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3RNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgY2FsbC5zdGFydFJlYWQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcclxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0TWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kU3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbm8gcmVxdWVzdCBtZXNzYWdlIGZvciBzZXJ2ZXIgc3RyZWFtaW5nIG1ldGhvZCAke2hhbmRsZXIucGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyZWFtID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsKGhhbmRsZXIucGF0aCwgY2FsbCwgcmVxdWVzdE1ldGFkYXRhLCByZXF1ZXN0TWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZXJ2ZXIgbWV0aG9kIGhhbmRsZXIgdGhyZXcgZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2FuY2VsKCkge1xyXG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUJpZGlTdHJlYW1pbmcoY2FsbCwgaGFuZGxlcikge1xyXG4gICAgbGV0IHN0cmVhbTtcclxuICAgIGNhbGwuc3RhcnQoe1xyXG4gICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlckR1cGxleFN0cmVhbUltcGwoaGFuZGxlci5wYXRoLCBjYWxsLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZ1bmMoc3RyZWFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLnNlbmRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZXJ2ZXIgbWV0aG9kIGhhbmRsZXIgdGhyZXcgZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uUmVjZWl2ZUhhbGZDbG9zZSgpIHtcclxuICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNhbmNlbCgpIHtcclxuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.validateRetryThrottling = validateRetryThrottling;\r\nexports.validateServiceConfig = validateServiceConfig;\r\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\r\n/* This file implements gRFC A2 and the service config spec:\r\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\r\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\r\n * function here takes an object with unknown structure and returns its\r\n * specific object type if the input has the right structure, and throws an\r\n * error otherwise. */\r\n/* The any type is purposely used here. All functions validate their input at\r\n * runtime */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\n/**\r\n * Recognizes a number with up to 9 digits after the decimal point, followed by\r\n * an \"s\", representing a number of seconds.\r\n */\r\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\r\n/**\r\n * Client language name used for determining whether this client matches a\r\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\r\n */\r\nconst CLIENT_LANGUAGE_STRING = 'node';\r\nfunction validateName(obj) {\r\n    // In this context, and unset field and '' are considered the same\r\n    if ('service' in obj && obj.service !== '') {\r\n        if (typeof obj.service !== 'string') {\r\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\r\n        }\r\n        if ('method' in obj && obj.method !== '') {\r\n            if (typeof obj.method !== 'string') {\r\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\r\n            }\r\n            return {\r\n                service: obj.service,\r\n                method: obj.method,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                service: obj.service,\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        if ('method' in obj && obj.method !== undefined) {\r\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\r\n        }\r\n        return {};\r\n    }\r\n}\r\nfunction validateRetryPolicy(obj) {\r\n    if (!('maxAttempts' in obj) ||\r\n        !Number.isInteger(obj.maxAttempts) ||\r\n        obj.maxAttempts < 2) {\r\n        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\r\n    }\r\n    if (!('initialBackoff' in obj) ||\r\n        typeof obj.initialBackoff !== 'string' ||\r\n        !DURATION_REGEX.test(obj.initialBackoff)) {\r\n        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');\r\n    }\r\n    if (!('maxBackoff' in obj) ||\r\n        typeof obj.maxBackoff !== 'string' ||\r\n        !DURATION_REGEX.test(obj.maxBackoff)) {\r\n        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');\r\n    }\r\n    if (!('backoffMultiplier' in obj) ||\r\n        typeof obj.backoffMultiplier !== 'number' ||\r\n        obj.backoffMultiplier <= 0) {\r\n        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\r\n    }\r\n    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\r\n        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\r\n    }\r\n    if (obj.retryableStatusCodes.length === 0) {\r\n        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\r\n    }\r\n    for (const value of obj.retryableStatusCodes) {\r\n        if (typeof value === 'number') {\r\n            if (!Object.values(constants_1.Status).includes(value)) {\r\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\r\n            }\r\n        }\r\n        else if (typeof value === 'string') {\r\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\r\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\r\n        }\r\n    }\r\n    return {\r\n        maxAttempts: obj.maxAttempts,\r\n        initialBackoff: obj.initialBackoff,\r\n        maxBackoff: obj.maxBackoff,\r\n        backoffMultiplier: obj.backoffMultiplier,\r\n        retryableStatusCodes: obj.retryableStatusCodes,\r\n    };\r\n}\r\nfunction validateHedgingPolicy(obj) {\r\n    if (!('maxAttempts' in obj) ||\r\n        !Number.isInteger(obj.maxAttempts) ||\r\n        obj.maxAttempts < 2) {\r\n        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\r\n    }\r\n    if ('hedgingDelay' in obj &&\r\n        (typeof obj.hedgingDelay !== 'string' ||\r\n            !DURATION_REGEX.test(obj.hedgingDelay))) {\r\n        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\r\n    }\r\n    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\r\n        for (const value of obj.nonFatalStatusCodes) {\r\n            if (typeof value === 'number') {\r\n                if (!Object.values(constants_1.Status).includes(value)) {\r\n                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');\r\n                }\r\n            }\r\n            else if (typeof value === 'string') {\r\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\r\n                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');\r\n            }\r\n        }\r\n    }\r\n    const result = {\r\n        maxAttempts: obj.maxAttempts,\r\n    };\r\n    if (obj.hedgingDelay) {\r\n        result.hedgingDelay = obj.hedgingDelay;\r\n    }\r\n    if (obj.nonFatalStatusCodes) {\r\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\r\n    }\r\n    return result;\r\n}\r\nfunction validateMethodConfig(obj) {\r\n    var _a;\r\n    const result = {\r\n        name: [],\r\n    };\r\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\r\n        throw new Error('Invalid method config: invalid name array');\r\n    }\r\n    for (const name of obj.name) {\r\n        result.name.push(validateName(name));\r\n    }\r\n    if ('waitForReady' in obj) {\r\n        if (typeof obj.waitForReady !== 'boolean') {\r\n            throw new Error('Invalid method config: invalid waitForReady');\r\n        }\r\n        result.waitForReady = obj.waitForReady;\r\n    }\r\n    if ('timeout' in obj) {\r\n        if (typeof obj.timeout === 'object') {\r\n            if (!('seconds' in obj.timeout) ||\r\n                !(typeof obj.timeout.seconds === 'number')) {\r\n                throw new Error('Invalid method config: invalid timeout.seconds');\r\n            }\r\n            if (!('nanos' in obj.timeout) ||\r\n                !(typeof obj.timeout.nanos === 'number')) {\r\n                throw new Error('Invalid method config: invalid timeout.nanos');\r\n            }\r\n            result.timeout = obj.timeout;\r\n        }\r\n        else if (typeof obj.timeout === 'string' &&\r\n            DURATION_REGEX.test(obj.timeout)) {\r\n            const timeoutParts = obj.timeout\r\n                .substring(0, obj.timeout.length - 1)\r\n                .split('.');\r\n            result.timeout = {\r\n                seconds: timeoutParts[0] | 0,\r\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\r\n            };\r\n        }\r\n        else {\r\n            throw new Error('Invalid method config: invalid timeout');\r\n        }\r\n    }\r\n    if ('maxRequestBytes' in obj) {\r\n        if (typeof obj.maxRequestBytes !== 'number') {\r\n            throw new Error('Invalid method config: invalid maxRequestBytes');\r\n        }\r\n        result.maxRequestBytes = obj.maxRequestBytes;\r\n    }\r\n    if ('maxResponseBytes' in obj) {\r\n        if (typeof obj.maxResponseBytes !== 'number') {\r\n            throw new Error('Invalid method config: invalid maxRequestBytes');\r\n        }\r\n        result.maxResponseBytes = obj.maxResponseBytes;\r\n    }\r\n    if ('retryPolicy' in obj) {\r\n        if ('hedgingPolicy' in obj) {\r\n            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\r\n        }\r\n        else {\r\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\r\n        }\r\n    }\r\n    else if ('hedgingPolicy' in obj) {\r\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\r\n    }\r\n    return result;\r\n}\r\nfunction validateRetryThrottling(obj) {\r\n    if (!('maxTokens' in obj) ||\r\n        typeof obj.maxTokens !== 'number' ||\r\n        obj.maxTokens <= 0 ||\r\n        obj.maxTokens > 1000) {\r\n        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\r\n    }\r\n    if (!('tokenRatio' in obj) ||\r\n        typeof obj.tokenRatio !== 'number' ||\r\n        obj.tokenRatio <= 0) {\r\n        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\r\n    }\r\n    return {\r\n        maxTokens: +obj.maxTokens.toFixed(3),\r\n        tokenRatio: +obj.tokenRatio.toFixed(3),\r\n    };\r\n}\r\nfunction validateLoadBalancingConfig(obj) {\r\n    if (!(typeof obj === 'object' && obj !== null)) {\r\n        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);\r\n    }\r\n    const keys = Object.keys(obj);\r\n    if (keys.length > 1) {\r\n        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);\r\n    }\r\n    if (keys.length === 0) {\r\n        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');\r\n    }\r\n    return {\r\n        [keys[0]]: obj[keys[0]],\r\n    };\r\n}\r\nfunction validateServiceConfig(obj) {\r\n    const result = {\r\n        loadBalancingConfig: [],\r\n        methodConfig: [],\r\n    };\r\n    if ('loadBalancingPolicy' in obj) {\r\n        if (typeof obj.loadBalancingPolicy === 'string') {\r\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\r\n        }\r\n    }\r\n    if ('loadBalancingConfig' in obj) {\r\n        if (Array.isArray(obj.loadBalancingConfig)) {\r\n            for (const config of obj.loadBalancingConfig) {\r\n                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\r\n        }\r\n    }\r\n    if ('methodConfig' in obj) {\r\n        if (Array.isArray(obj.methodConfig)) {\r\n            for (const methodConfig of obj.methodConfig) {\r\n                result.methodConfig.push(validateMethodConfig(methodConfig));\r\n            }\r\n        }\r\n    }\r\n    if ('retryThrottling' in obj) {\r\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\r\n    }\r\n    // Validate method name uniqueness\r\n    const seenMethodNames = [];\r\n    for (const methodConfig of result.methodConfig) {\r\n        for (const name of methodConfig.name) {\r\n            for (const seenName of seenMethodNames) {\r\n                if (name.service === seenName.service &&\r\n                    name.method === seenName.method) {\r\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\r\n                }\r\n            }\r\n            seenMethodNames.push(name);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction validateCanaryConfig(obj) {\r\n    if (!('serviceConfig' in obj)) {\r\n        throw new Error('Invalid service config choice: missing service config');\r\n    }\r\n    const result = {\r\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\r\n    };\r\n    if ('clientLanguage' in obj) {\r\n        if (Array.isArray(obj.clientLanguage)) {\r\n            result.clientLanguage = [];\r\n            for (const lang of obj.clientLanguage) {\r\n                if (typeof lang === 'string') {\r\n                    result.clientLanguage.push(lang);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid clientLanguage');\r\n        }\r\n    }\r\n    if ('clientHostname' in obj) {\r\n        if (Array.isArray(obj.clientHostname)) {\r\n            result.clientHostname = [];\r\n            for (const lang of obj.clientHostname) {\r\n                if (typeof lang === 'string') {\r\n                    result.clientHostname.push(lang);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid service config choice: invalid clientHostname');\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid clientHostname');\r\n        }\r\n    }\r\n    if ('percentage' in obj) {\r\n        if (typeof obj.percentage === 'number' &&\r\n            0 <= obj.percentage &&\r\n            obj.percentage <= 100) {\r\n            result.percentage = obj.percentage;\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid percentage');\r\n        }\r\n    }\r\n    // Validate that no unexpected fields are present\r\n    const allowedFields = [\r\n        'clientLanguage',\r\n        'percentage',\r\n        'clientHostname',\r\n        'serviceConfig',\r\n    ];\r\n    for (const field in obj) {\r\n        if (!allowedFields.includes(field)) {\r\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction validateAndSelectCanaryConfig(obj, percentage) {\r\n    if (!Array.isArray(obj)) {\r\n        throw new Error('Invalid service config list');\r\n    }\r\n    for (const config of obj) {\r\n        const validatedConfig = validateCanaryConfig(config);\r\n        /* For each field, we check if it is present, then only discard the\r\n         * config if the field value does not match the current client */\r\n        if (typeof validatedConfig.percentage === 'number' &&\r\n            percentage > validatedConfig.percentage) {\r\n            continue;\r\n        }\r\n        if (Array.isArray(validatedConfig.clientHostname)) {\r\n            let hostnameMatched = false;\r\n            for (const hostname of validatedConfig.clientHostname) {\r\n                if (hostname === os.hostname()) {\r\n                    hostnameMatched = true;\r\n                }\r\n            }\r\n            if (!hostnameMatched) {\r\n                continue;\r\n            }\r\n        }\r\n        if (Array.isArray(validatedConfig.clientLanguage)) {\r\n            let languageMatched = false;\r\n            for (const language of validatedConfig.clientLanguage) {\r\n                if (language === CLIENT_LANGUAGE_STRING) {\r\n                    languageMatched = true;\r\n                }\r\n            }\r\n            if (!languageMatched) {\r\n                continue;\r\n            }\r\n        }\r\n        return validatedConfig.serviceConfig;\r\n    }\r\n    throw new Error('No matching service config found');\r\n}\r\n/**\r\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\r\n * and select a service config with selection fields that all match this client. Most of these steps\r\n * can fail with an error; the caller must handle any errors thrown this way.\r\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\r\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\r\n * @return The service configuration to use, given the percentage value, or null if the service config\r\n *     data has a valid format but none of the options match the current client.\r\n */\r\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\r\n    for (const record of txtRecord) {\r\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\r\n            /* Treat the list of strings in this record as a single string and remove\r\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\r\n            const recordString = record.join('').substring('grpc_config='.length);\r\n            const recordJson = JSON.parse(recordString);\r\n            return validateAndSelectCanaryConfig(recordJson, percentage);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxtQkFBbUI7QUFDekg7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLG1CQUFtQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsS0FBSztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYSxHQUFHLFlBQVk7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanM/YjIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy52YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyA9IHZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nO1xyXG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcclxuZXhwb3J0cy5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyA9IGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnO1xyXG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTItc2VydmljZS1jb25maWdzLWluLWRucy5tZFxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9zZXJ2aWNlX2NvbmZpZy5tZC4gRWFjaFxyXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xyXG4gKiBzcGVjaWZpYyBvYmplY3QgdHlwZSBpZiB0aGUgaW5wdXQgaGFzIHRoZSByaWdodCBzdHJ1Y3R1cmUsIGFuZCB0aHJvd3MgYW5cclxuICogZXJyb3Igb3RoZXJ3aXNlLiAqL1xyXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxyXG4gKiBydW50aW1lICovXHJcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG4vKipcclxuICogUmVjb2duaXplcyBhIG51bWJlciB3aXRoIHVwIHRvIDkgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBmb2xsb3dlZCBieVxyXG4gKiBhbiBcInNcIiwgcmVwcmVzZW50aW5nIGEgbnVtYmVyIG9mIHNlY29uZHMuXHJcbiAqL1xyXG5jb25zdCBEVVJBVElPTl9SRUdFWCA9IC9eXFxkKyhcXC5cXGR7MSw5fSk/cyQvO1xyXG4vKipcclxuICogQ2xpZW50IGxhbmd1YWdlIG5hbWUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIGNsaWVudCBtYXRjaGVzIGFcclxuICogYFNlcnZpY2VDb25maWdDYW5hcnlDb25maWdgJ3MgYGNsaWVudExhbmd1YWdlYCBsaXN0LlxyXG4gKi9cclxuY29uc3QgQ0xJRU5UX0xBTkdVQUdFX1NUUklORyA9ICdub2RlJztcclxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKG9iaikge1xyXG4gICAgLy8gSW4gdGhpcyBjb250ZXh0LCBhbmQgdW5zZXQgZmllbGQgYW5kICcnIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXHJcbiAgICBpZiAoJ3NlcnZpY2UnIGluIG9iaiAmJiBvYmouc2VydmljZSAhPT0gJycpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai5zZXJ2aWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBpbnZhbGlkIHNlcnZpY2U6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgnbWV0aG9kJyBpbiBvYmogJiYgb2JqLm1ldGhvZCAhPT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmoubWV0aG9kICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2Q6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBvYmoubWV0aG9kLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICgnbWV0aG9kJyBpbiBvYmogJiYgb2JqLm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IG1ldGhvZCBzZXQgd2l0aCBlbXB0eSBvciB1bnNldCBzZXJ2aWNlYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJ5UG9saWN5KG9iaikge1xyXG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XHJcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIob2JqLm1heEF0dGVtcHRzKSB8fFxyXG4gICAgICAgIG9iai5tYXhBdHRlbXB0cyA8IDIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlciBhdCBsZWFzdCAyJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgnaW5pdGlhbEJhY2tvZmYnIGluIG9iaikgfHxcclxuICAgICAgICB0eXBlb2Ygb2JqLmluaXRpYWxCYWNrb2ZmICE9PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5pbml0aWFsQmFja29mZikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IGluaXRpYWxCYWNrb2ZmIG11c3QgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBvZiBhIHBvc2l0aXZlIGludGVnZXIgb3IgZGVjaW1hbCBmb2xsb3dlZCBieSBzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgnbWF4QmFja29mZicgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmoubWF4QmFja29mZikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBvciBkZWNpbWFsIGZvbGxvd2VkIGJ5IHMnKTtcclxuICAgIH1cclxuICAgIGlmICghKCdiYWNrb2ZmTXVsdGlwbGllcicgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmouYmFja29mZk11bHRpcGxpZXIgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgb2JqLmJhY2tvZmZNdWx0aXBsaWVyIDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IGJhY2tvZmZNdWx0aXBsaWVyIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIH1cclxuICAgIGlmICghKCdyZXRyeWFibGVTdGF0dXNDb2RlcycgaW4gb2JqICYmIEFycmF5LmlzQXJyYXkob2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgbXVzdCBiZSBub24tZW1wdHknKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG5vdCBpbiBzdGF0dXMgY29kZSByYW5nZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYXhBdHRlbXB0czogb2JqLm1heEF0dGVtcHRzLFxyXG4gICAgICAgIGluaXRpYWxCYWNrb2ZmOiBvYmouaW5pdGlhbEJhY2tvZmYsXHJcbiAgICAgICAgbWF4QmFja29mZjogb2JqLm1heEJhY2tvZmYsXHJcbiAgICAgICAgYmFja29mZk11bHRpcGxpZXI6IG9iai5iYWNrb2ZmTXVsdGlwbGllcixcclxuICAgICAgICByZXRyeWFibGVTdGF0dXNDb2Rlczogb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqKSB7XHJcbiAgICBpZiAoISgnbWF4QXR0ZW1wdHMnIGluIG9iaikgfHxcclxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvYmoubWF4QXR0ZW1wdHMpIHx8XHJcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBtYXhBdHRlbXB0cyBtdXN0IGJlIGFuIGludGVnZXIgYXQgbGVhc3QgMicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCdoZWRnaW5nRGVsYXknIGluIG9iaiAmJlxyXG4gICAgICAgICh0eXBlb2Ygb2JqLmhlZGdpbmdEZWxheSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLmhlZGdpbmdEZWxheSkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IGhlZGdpbmdEZWxheSBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcclxuICAgIH1cclxuICAgIGlmICgnbm9uRmF0YWxTdGF0dXNDb2RlcycgaW4gb2JqICYmIEFycmF5LmlzQXJyYXkob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGluIHN0YXR1cyBjb2RlIHJhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgYSBzdGF0dXMgY29kZSBuYW1lJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXHJcbiAgICB9O1xyXG4gICAgaWYgKG9iai5oZWRnaW5nRGVsYXkpIHtcclxuICAgICAgICByZXN1bHQuaGVkZ2luZ0RlbGF5ID0gb2JqLmhlZGdpbmdEZWxheTtcclxuICAgIH1cclxuICAgIGlmIChvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xyXG4gICAgICAgIHJlc3VsdC5ub25GYXRhbFN0YXR1c0NvZGVzID0gb2JqLm5vbkZhdGFsU3RhdHVzQ29kZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIG5hbWU6IFtdLFxyXG4gICAgfTtcclxuICAgIGlmICghKCduYW1lJyBpbiBvYmopIHx8ICFBcnJheS5pc0FycmF5KG9iai5uYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBvYmoubmFtZSkge1xyXG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcclxuICAgIH1cclxuICAgIGlmICgnd2FpdEZvclJlYWR5JyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB3YWl0Rm9yUmVhZHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9iaikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmICghKCdzZWNvbmRzJyBpbiBvYmoudGltZW91dCkgfHxcclxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0LnNlY29uZHMgPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoJ25hbm9zJyBpbiBvYmoudGltZW91dCkgfHxcclxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQubmFub3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgIERVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLnRpbWVvdXQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQYXJ0cyA9IG9iai50aW1lb3V0XHJcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIG9iai50aW1lb3V0Lmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSB7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiB0aW1lb3V0UGFydHNbMF0gfCAwLFxyXG4gICAgICAgICAgICAgICAgbmFub3M6ICgoX2EgPSB0aW1lb3V0UGFydHNbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIHwgMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoJ21heFJlcXVlc3RCeXRlcycgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVxdWVzdEJ5dGVzICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0Lm1heFJlcXVlc3RCeXRlcyA9IG9iai5tYXhSZXF1ZXN0Qnl0ZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoJ21heFJlc3BvbnNlQnl0ZXMnIGluIG9iaikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlc3BvbnNlQnl0ZXMgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQubWF4UmVzcG9uc2VCeXRlcyA9IG9iai5tYXhSZXNwb25zZUJ5dGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKCdyZXRyeVBvbGljeScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IHJldHJ5UG9saWN5IGFuZCBoZWRnaW5nUG9saWN5IGNhbm5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnJldHJ5UG9saWN5ID0gdmFsaWRhdGVSZXRyeVBvbGljeShvYmoucmV0cnlQb2xpY3kpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcclxuICAgICAgICByZXN1bHQuaGVkZ2luZ1BvbGljeSA9IHZhbGlkYXRlSGVkZ2luZ1BvbGljeShvYmouaGVkZ2luZ1BvbGljeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nKG9iaikge1xyXG4gICAgaWYgKCEoJ21heFRva2VucycgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmoubWF4VG9rZW5zICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgIG9iai5tYXhUb2tlbnMgPD0gMCB8fFxyXG4gICAgICAgIG9iai5tYXhUb2tlbnMgPiAxMDAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogbWF4VG9rZW5zIG11c3QgYmUgYSBudW1iZXIgaW4gKDAsIDEwMDBdJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgndG9rZW5SYXRpbycgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmoudG9rZW5SYXRpbyAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICBvYmoudG9rZW5SYXRpbyA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogdG9rZW5SYXRpbyBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1heFRva2VuczogK29iai5tYXhUb2tlbnMudG9GaXhlZCgzKSxcclxuICAgICAgICB0b2tlblJhdGlvOiArb2JqLnRva2VuUmF0aW8udG9GaXhlZCgzKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKG9iaikge1xyXG4gICAgaWYgKCEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnOiB1bmV4cGVjdGVkIHR5cGUgJHt0eXBlb2Ygb2JqfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxvYWRCYWxhbmNpbmdDb25maWc6IHVuZXhwZWN0ZWQgbXVsdGlwbGUga2V5cyAke2tleXN9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZCBiYWxhbmNpbmcgcG9saWN5IG5hbWUgcmVxdWlyZWQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgW2tleXNbMF1dOiBvYmpba2V5c1swXV0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcclxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxyXG4gICAgfTtcclxuICAgIGlmICgnbG9hZEJhbGFuY2luZ1BvbGljeScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdQb2xpY3kgPSBvYmoubG9hZEJhbGFuY2luZ1BvbGljeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nUG9saWN5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nQ29uZmlnJyBpbiBvYmopIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nQ29uZmlnLnB1c2godmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKGNvbmZpZykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgnbWV0aG9kQ29uZmlnJyBpbiBvYmopIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiBvYmoubWV0aG9kQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQubWV0aG9kQ29uZmlnLnB1c2godmFsaWRhdGVNZXRob2RDb25maWcobWV0aG9kQ29uZmlnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoJ3JldHJ5VGhyb3R0bGluZycgaW4gb2JqKSB7XHJcbiAgICAgICAgcmVzdWx0LnJldHJ5VGhyb3R0bGluZyA9IHZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nKG9iai5yZXRyeVRocm90dGxpbmcpO1xyXG4gICAgfVxyXG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xyXG4gICAgY29uc3Qgc2Vlbk1ldGhvZE5hbWVzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiByZXN1bHQubWV0aG9kQ29uZmlnKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vlbk5hbWUgb2Ygc2Vlbk1ldGhvZE5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZWVuTmFtZS5zZXJ2aWNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogZHVwbGljYXRlIG5hbWUgJHtuYW1lLnNlcnZpY2V9LyR7bmFtZS5tZXRob2R9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2Vlbk1ldGhvZE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhvYmopIHtcclxuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogbWlzc2luZyBzZXJ2aWNlIGNvbmZpZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNlcnZpY2VDb25maWc6IHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmouc2VydmljZUNvbmZpZyksXHJcbiAgICB9O1xyXG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudExhbmd1YWdlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZS5wdXNoKGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdjbGllbnRIb3N0bmFtZScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudEhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRIb3N0bmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdwZXJjZW50YWdlJyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAwIDw9IG9iai5wZXJjZW50YWdlICYmXHJcbiAgICAgICAgICAgIG9iai5wZXJjZW50YWdlIDw9IDEwMCkge1xyXG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxyXG4gICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtcclxuICAgICAgICAnY2xpZW50TGFuZ3VhZ2UnLFxyXG4gICAgICAgICdwZXJjZW50YWdlJyxcclxuICAgICAgICAnY2xpZW50SG9zdG5hbWUnLFxyXG4gICAgICAgICdzZXJ2aWNlQ29uZmlnJyxcclxuICAgIF07XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG9iaikge1xyXG4gICAgICAgIGlmICghYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcob2JqLCBwZXJjZW50YWdlKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBsaXN0Jyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRDb25maWcgPSB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhjb25maWcpO1xyXG4gICAgICAgIC8qIEZvciBlYWNoIGZpZWxkLCB3ZSBjaGVjayBpZiBpdCBpcyBwcmVzZW50LCB0aGVuIG9ubHkgZGlzY2FyZCB0aGVcclxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9zdG5hbWUgPT09IG9zLmhvc3RuYW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpKSB7XHJcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZU1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSA9PT0gQ0xJRU5UX0xBTkdVQUdFX1NUUklORykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZU1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWF0Y2hpbmcgc2VydmljZSBjb25maWcgZm91bmQnKTtcclxufVxyXG4vKipcclxuICogRmluZCB0aGUgXCJncnBjX2NvbmZpZ1wiIHJlY29yZCBhbW9uZyB0aGUgVFhUIHJlY29yZHMsIHBhcnNlIGl0cyB2YWx1ZSBhcyBKU09OLCB2YWxpZGF0ZSBpdHMgY29udGVudHMsXHJcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcclxuICogY2FuIGZhaWwgd2l0aCBhbiBlcnJvcjsgdGhlIGNhbGxlciBtdXN0IGhhbmRsZSBhbnkgZXJyb3JzIHRocm93biB0aGlzIHdheS5cclxuICogQHBhcmFtIHR4dFJlY29yZCBUaGUgVFhUIHJlY29yZCBhcnJheSB0aGF0IGlzIG91dHB1dCBmcm9tIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGRucy5yZXNvbHZlVHh0XHJcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcclxuICogQHJldHVybiBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIHVzZSwgZ2l2ZW4gdGhlIHBlcmNlbnRhZ2UgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHNlcnZpY2UgY29uZmlnXHJcbiAqICAgICBkYXRhIGhhcyBhIHZhbGlkIGZvcm1hdCBidXQgbm9uZSBvZiB0aGUgb3B0aW9ucyBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHBlcmNlbnRhZ2UpIHtcclxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHR4dFJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcclxuICAgICAgICAgICAgLyogVHJlYXQgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGlzIHJlY29yZCBhcyBhIHNpbmdsZSBzdHJpbmcgYW5kIHJlbW92ZVxyXG4gICAgICAgICAgICAgKiBcImdycGNfY29uZmlnPVwiIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIHJlc3Qgc2hvdWxkIGJlIGEgSlNPTiBzdHJpbmcgKi9cclxuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCByZWNvcmRKc29uID0gSlNPTi5wYXJzZShyZWNvcmRTdHJpbmcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcocmVjb3JkSnNvbiwgcGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StatusBuilder = void 0;\r\n/**\r\n * A builder for gRPC status objects.\r\n */\r\nclass StatusBuilder {\r\n    constructor() {\r\n        this.code = null;\r\n        this.details = null;\r\n        this.metadata = null;\r\n    }\r\n    /**\r\n     * Adds a status code to the builder.\r\n     */\r\n    withCode(code) {\r\n        this.code = code;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds details to the builder.\r\n     */\r\n    withDetails(details) {\r\n        this.details = details;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds metadata to the builder.\r\n     */\r\n    withMetadata(metadata) {\r\n        this.metadata = metadata;\r\n        return this;\r\n    }\r\n    /**\r\n     * Builds the status object.\r\n     */\r\n    build() {\r\n        const status = {};\r\n        if (this.code !== null) {\r\n            status.code = this.code;\r\n        }\r\n        if (this.details !== null) {\r\n            status.details = this.details;\r\n        }\r\n        if (this.metadata !== null) {\r\n            status.metadata = this.metadata;\r\n        }\r\n        return status;\r\n    }\r\n}\r\nexports.StatusBuilder = StatusBuilder;\r\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcz9kZGNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiBBIGJ1aWxkZXIgZm9yIGdSUEMgc3RhdHVzIG9iamVjdHMuXHJcbiAqL1xyXG5jbGFzcyBTdGF0dXNCdWlsZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN0YXR1cyBjb2RlIHRvIHRoZSBidWlsZGVyLlxyXG4gICAgICovXHJcbiAgICB3aXRoQ29kZShjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBkZXRhaWxzIHRvIHRoZSBidWlsZGVyLlxyXG4gICAgICovXHJcbiAgICB3aXRoRGV0YWlscyhkZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBtZXRhZGF0YSB0byB0aGUgYnVpbGRlci5cclxuICAgICAqL1xyXG4gICAgd2l0aE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgdGhlIHN0YXR1cyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSB0aGlzLmNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRldGFpbHMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSB0aGlzLmRldGFpbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gU3RhdHVzQnVpbGRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StreamDecoder = void 0;\r\nvar ReadState;\r\n(function (ReadState) {\r\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\r\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\r\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\r\n})(ReadState || (ReadState = {}));\r\nclass StreamDecoder {\r\n    constructor(maxReadMessageLength) {\r\n        this.maxReadMessageLength = maxReadMessageLength;\r\n        this.readState = ReadState.NO_DATA;\r\n        this.readCompressFlag = Buffer.alloc(1);\r\n        this.readPartialSize = Buffer.alloc(4);\r\n        this.readSizeRemaining = 4;\r\n        this.readMessageSize = 0;\r\n        this.readPartialMessage = [];\r\n        this.readMessageRemaining = 0;\r\n    }\r\n    write(data) {\r\n        let readHead = 0;\r\n        let toRead;\r\n        const result = [];\r\n        while (readHead < data.length) {\r\n            switch (this.readState) {\r\n                case ReadState.NO_DATA:\r\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\r\n                    readHead += 1;\r\n                    this.readState = ReadState.READING_SIZE;\r\n                    this.readPartialSize.fill(0);\r\n                    this.readSizeRemaining = 4;\r\n                    this.readMessageSize = 0;\r\n                    this.readMessageRemaining = 0;\r\n                    this.readPartialMessage = [];\r\n                    break;\r\n                case ReadState.READING_SIZE:\r\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\r\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\r\n                    this.readSizeRemaining -= toRead;\r\n                    readHead += toRead;\r\n                    // readSizeRemaining >=0 here\r\n                    if (this.readSizeRemaining === 0) {\r\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\r\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\r\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\r\n                        }\r\n                        this.readMessageRemaining = this.readMessageSize;\r\n                        if (this.readMessageRemaining > 0) {\r\n                            this.readState = ReadState.READING_MESSAGE;\r\n                        }\r\n                        else {\r\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\r\n                            this.readState = ReadState.NO_DATA;\r\n                            result.push(message);\r\n                        }\r\n                    }\r\n                    break;\r\n                case ReadState.READING_MESSAGE:\r\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\r\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\r\n                    this.readMessageRemaining -= toRead;\r\n                    readHead += toRead;\r\n                    // readMessageRemaining >=0 here\r\n                    if (this.readMessageRemaining === 0) {\r\n                        // At this point, we have read a full message\r\n                        const framedMessageBuffers = [\r\n                            this.readCompressFlag,\r\n                            this.readPartialSize,\r\n                        ].concat(this.readPartialMessage);\r\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\r\n                        this.readState = ReadState.NO_DATA;\r\n                        result.push(framedMessage);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error('Unexpected read state');\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.StreamDecoder = StreamDecoder;\r\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixzQkFBc0IsS0FBSywwQkFBMEI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0cmVhbS1kZWNvZGVyLmpzPzU0NGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IHZvaWQgMDtcclxudmFyIFJlYWRTdGF0ZTtcclxuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcclxuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJOT19EQVRBXCJdID0gMF0gPSBcIk5PX0RBVEFcIjtcclxuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX1NJWkVcIl0gPSAxXSA9IFwiUkVBRElOR19TSVpFXCI7XHJcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19NRVNTQUdFXCJdID0gMl0gPSBcIlJFQURJTkdfTUVTU0FHRVwiO1xyXG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XHJcbmNsYXNzIFN0cmVhbURlY29kZXIge1xyXG4gICAgY29uc3RydWN0b3IobWF4UmVhZE1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RoID0gbWF4UmVhZE1lc3NhZ2VMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcclxuICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcgPSBCdWZmZXIuYWxsb2MoMSk7XHJcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUgPSBCdWZmZXIuYWxsb2MoNCk7XHJcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XHJcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlID0gW107XHJcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XHJcbiAgICB9XHJcbiAgICB3cml0ZShkYXRhKSB7XHJcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcclxuICAgICAgICBsZXQgdG9SZWFkO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yZWFkU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLk5PX0RBVEE6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZFNpemVSZW1haW5pbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29weSh0aGlzLnJlYWRQYXJ0aWFsU2l6ZSwgNCAtIHRoaXMucmVhZFNpemVSZW1haW5pbmcsIHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gdG9SZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRTaXplUmVtYWluaW5nID49MCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5yZWFkVUludDMyQkUoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RoICE9PSAtMSAmJiB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA+IHRoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7dGhpcy5yZWFkTWVzc2FnZVNpemV9IHZzICR7dGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aH0pYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IHRoaXMucmVhZE1lc3NhZ2VTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlYWRDb21wcmVzc0ZsYWcsIHRoaXMucmVhZFBhcnRpYWxTaXplXSwgNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U6XHJcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UucHVzaChkYXRhLnNsaWNlKHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgLT0gdG9SZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkTWVzc2FnZVJlbWFpbmluZyA+PTAgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgcmVhZCBhIGZ1bGwgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlQnVmZmVycyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KGZyYW1lZE1lc3NhZ2VCdWZmZXJzLCB0aGlzLnJlYWRNZXNzYWdlU2l6ZSArIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZWRNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZWFkIHN0YXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSBTdHJlYW1EZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW0tZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EndpointMap = void 0;\r\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\r\nexports.subchannelAddressEqual = subchannelAddressEqual;\r\nexports.subchannelAddressToString = subchannelAddressToString;\r\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\r\nexports.endpointEqual = endpointEqual;\r\nexports.endpointToString = endpointToString;\r\nexports.endpointHasAddress = endpointHasAddress;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nfunction isTcpSubchannelAddress(address) {\r\n    return 'port' in address;\r\n}\r\nfunction subchannelAddressEqual(address1, address2) {\r\n    if (!address1 && !address2) {\r\n        return true;\r\n    }\r\n    if (!address1 || !address2) {\r\n        return false;\r\n    }\r\n    if (isTcpSubchannelAddress(address1)) {\r\n        return (isTcpSubchannelAddress(address2) &&\r\n            address1.host === address2.host &&\r\n            address1.port === address2.port);\r\n    }\r\n    else {\r\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\r\n    }\r\n}\r\nfunction subchannelAddressToString(address) {\r\n    if (isTcpSubchannelAddress(address)) {\r\n        if ((0, net_1.isIPv6)(address.host)) {\r\n            return '[' + address.host + ']:' + address.port;\r\n        }\r\n        else {\r\n            return address.host + ':' + address.port;\r\n        }\r\n    }\r\n    else {\r\n        return address.path;\r\n    }\r\n}\r\nconst DEFAULT_PORT = 443;\r\nfunction stringToSubchannelAddress(addressString, port) {\r\n    if ((0, net_1.isIP)(addressString)) {\r\n        return {\r\n            host: addressString,\r\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            path: addressString,\r\n        };\r\n    }\r\n}\r\nfunction endpointEqual(endpoint1, endpoint2) {\r\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < endpoint1.addresses.length; i++) {\r\n        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction endpointToString(endpoint) {\r\n    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');\r\n}\r\nfunction endpointHasAddress(endpoint, expectedAddress) {\r\n    for (const address of endpoint.addresses) {\r\n        if (subchannelAddressEqual(address, expectedAddress)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction endpointEqualUnordered(endpoint1, endpoint2) {\r\n    if (endpoint1.addresses.length !== endpoint2.addresses.length) {\r\n        return false;\r\n    }\r\n    for (const address1 of endpoint1.addresses) {\r\n        let matchFound = false;\r\n        for (const address2 of endpoint2.addresses) {\r\n            if (subchannelAddressEqual(address1, address2)) {\r\n                matchFound = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matchFound) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nclass EndpointMap {\r\n    constructor() {\r\n        this.map = new Set();\r\n    }\r\n    get size() {\r\n        return this.map.size;\r\n    }\r\n    getForSubchannelAddress(address) {\r\n        for (const entry of this.map) {\r\n            if (endpointHasAddress(entry.key, address)) {\r\n                return entry.value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Delete any entries in this map with keys that are not in endpoints\r\n     * @param endpoints\r\n     */\r\n    deleteMissing(endpoints) {\r\n        const removedValues = [];\r\n        for (const entry of this.map) {\r\n            let foundEntry = false;\r\n            for (const endpoint of endpoints) {\r\n                if (endpointEqualUnordered(endpoint, entry.key)) {\r\n                    foundEntry = true;\r\n                }\r\n            }\r\n            if (!foundEntry) {\r\n                removedValues.push(entry.value);\r\n                this.map.delete(entry);\r\n            }\r\n        }\r\n        return removedValues;\r\n    }\r\n    get(endpoint) {\r\n        for (const entry of this.map) {\r\n            if (endpointEqualUnordered(endpoint, entry.key)) {\r\n                return entry.value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    set(endpoint, mapEntry) {\r\n        for (const entry of this.map) {\r\n            if (endpointEqualUnordered(endpoint, entry.key)) {\r\n                entry.value = mapEntry;\r\n                return;\r\n            }\r\n        }\r\n        this.map.add({ key: endpoint, value: mapEntry });\r\n    }\r\n    delete(endpoint) {\r\n        for (const entry of this.map) {\r\n            if (endpointEqualUnordered(endpoint, entry.key)) {\r\n                this.map.delete(entry);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    has(endpoint) {\r\n        for (const entry of this.map) {\r\n            if (endpointEqualUnordered(endpoint, entry.key)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    clear() {\r\n        this.map.clear();\r\n    }\r\n    *keys() {\r\n        for (const entry of this.map) {\r\n            yield entry.key;\r\n        }\r\n    }\r\n    *values() {\r\n        for (const entry of this.map) {\r\n            yield entry.value;\r\n        }\r\n    }\r\n    *entries() {\r\n        for (const entry of this.map) {\r\n            yield [entry.key, entry.value];\r\n        }\r\n    }\r\n}\r\nexports.EndpointMap = EndpointMap;\r\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/MzI5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5FbmRwb2ludE1hcCA9IHZvaWQgMDtcclxuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcclxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbDtcclxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZztcclxuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcztcclxuZXhwb3J0cy5lbmRwb2ludEVxdWFsID0gZW5kcG9pbnRFcXVhbDtcclxuZXhwb3J0cy5lbmRwb2ludFRvU3RyaW5nID0gZW5kcG9pbnRUb1N0cmluZztcclxuZXhwb3J0cy5lbmRwb2ludEhhc0FkZHJlc3MgPSBlbmRwb2ludEhhc0FkZHJlc3M7XHJcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcclxuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICByZXR1cm4gJ3BvcnQnIGluIGFkZHJlc3M7XHJcbn1cclxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChhZGRyZXNzMSwgYWRkcmVzczIpIHtcclxuICAgIGlmICghYWRkcmVzczEgJiYgIWFkZHJlc3MyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFkZHJlc3MxIHx8ICFhZGRyZXNzMikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MxKSkge1xyXG4gICAgICAgIHJldHVybiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiZcclxuICAgICAgICAgICAgYWRkcmVzczEuaG9zdCA9PT0gYWRkcmVzczIuaG9zdCAmJlxyXG4gICAgICAgICAgICBhZGRyZXNzMS5wb3J0ID09PSBhZGRyZXNzMi5wb3J0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiYgYWRkcmVzczEucGF0aCA9PT0gYWRkcmVzczIucGF0aDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcclxuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICAgICAgaWYgKCgwLCBuZXRfMS5pc0lQdjYpKGFkZHJlc3MuaG9zdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbJyArIGFkZHJlc3MuaG9zdCArICddOicgKyBhZGRyZXNzLnBvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhZGRyZXNzLnBhdGg7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xyXG5mdW5jdGlvbiBzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3NTdHJpbmcsIHBvcnQpIHtcclxuICAgIGlmICgoMCwgbmV0XzEuaXNJUCkoYWRkcmVzc1N0cmluZykpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBob3N0OiBhZGRyZXNzU3RyaW5nLFxyXG4gICAgICAgICAgICBwb3J0OiBwb3J0ICE9PSBudWxsICYmIHBvcnQgIT09IHZvaWQgMCA/IHBvcnQgOiBERUZBVUxUX1BPUlQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBhdGg6IGFkZHJlc3NTdHJpbmcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRwb2ludEVxdWFsKGVuZHBvaW50MSwgZW5kcG9pbnQyKSB7XHJcbiAgICBpZiAoZW5kcG9pbnQxLmFkZHJlc3Nlcy5sZW5ndGggIT09IGVuZHBvaW50Mi5hZGRyZXNzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRwb2ludDEuYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGVuZHBvaW50MS5hZGRyZXNzZXNbaV0sIGVuZHBvaW50Mi5hZGRyZXNzZXNbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBlbmRwb2ludFRvU3RyaW5nKGVuZHBvaW50KSB7XHJcbiAgICByZXR1cm4gKCdbJyArIGVuZHBvaW50LmFkZHJlc3Nlcy5tYXAoc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykuam9pbignLCAnKSArICddJyk7XHJcbn1cclxuZnVuY3Rpb24gZW5kcG9pbnRIYXNBZGRyZXNzKGVuZHBvaW50LCBleHBlY3RlZEFkZHJlc3MpIHtcclxuICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBlbmRwb2ludC5hZGRyZXNzZXMpIHtcclxuICAgICAgICBpZiAoc3ViY2hhbm5lbEFkZHJlc3NFcXVhbChhZGRyZXNzLCBleHBlY3RlZEFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmRwb2ludEVxdWFsVW5vcmRlcmVkKGVuZHBvaW50MSwgZW5kcG9pbnQyKSB7XHJcbiAgICBpZiAoZW5kcG9pbnQxLmFkZHJlc3Nlcy5sZW5ndGggIT09IGVuZHBvaW50Mi5hZGRyZXNzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBhZGRyZXNzMSBvZiBlbmRwb2ludDEuYWRkcmVzc2VzKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoRm91bmQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3MyIG9mIGVuZHBvaW50Mi5hZGRyZXNzZXMpIHtcclxuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1hdGNoRm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmNsYXNzIEVuZHBvaW50TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XHJcbiAgICB9XHJcbiAgICBnZXRGb3JTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRIYXNBZGRyZXNzKGVudHJ5LmtleSwgYWRkcmVzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW55IGVudHJpZXMgaW4gdGhpcyBtYXAgd2l0aCBrZXlzIHRoYXQgYXJlIG5vdCBpbiBlbmRwb2ludHNcclxuICAgICAqIEBwYXJhbSBlbmRwb2ludHNcclxuICAgICAqL1xyXG4gICAgZGVsZXRlTWlzc2luZyhlbmRwb2ludHMpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkVmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBsZXQgZm91bmRFbnRyeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIGVuZHBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50RXF1YWxVbm9yZGVyZWQoZW5kcG9pbnQsIGVudHJ5LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEVudHJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRWYWx1ZXMucHVzaChlbnRyeS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdmVkVmFsdWVzO1xyXG4gICAgfVxyXG4gICAgZ2V0KGVuZHBvaW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQoZW5kcG9pbnQsIG1hcEVudHJ5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSBtYXBFbnRyeTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcC5hZGQoeyBrZXk6IGVuZHBvaW50LCB2YWx1ZTogbWFwRW50cnkgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoZW5kcG9pbnQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmRwb2ludEVxdWFsVW5vcmRlcmVkKGVuZHBvaW50LCBlbnRyeS5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzKGVuZHBvaW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRFcXVhbFVub3JkZXJlZChlbmRwb2ludCwgZW50cnkua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcclxuICAgIH1cclxuICAgICprZXlzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5tYXApIHtcclxuICAgICAgICAgICAgeWllbGQgZW50cnkua2V5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgICp2YWx1ZXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICB5aWVsZCBlbnRyeS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqZW50cmllcygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FbmRwb2ludE1hcCA9IEVuZHBvaW50TWFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Http2SubchannelCall = void 0;\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst TRACER_NAME = 'subchannel_call';\r\n/**\r\n * Should do approximately the same thing as util.getSystemErrorName but the\r\n * TypeScript types don't have that function for some reason so I just made my\r\n * own.\r\n * @param errno\r\n */\r\nfunction getSystemErrorName(errno) {\r\n    for (const [name, num] of Object.entries(os.constants.errno)) {\r\n        if (num === errno) {\r\n            return name;\r\n        }\r\n    }\r\n    return 'Unknown system error ' + errno;\r\n}\r\nfunction mapHttpStatusCode(code) {\r\n    const details = `Received HTTP status code ${code}`;\r\n    let mappedStatusCode;\r\n    switch (code) {\r\n        // TODO(murgatroid99): handle 100 and 101\r\n        case 400:\r\n            mappedStatusCode = constants_1.Status.INTERNAL;\r\n            break;\r\n        case 401:\r\n            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\r\n            break;\r\n        case 403:\r\n            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\r\n            break;\r\n        case 404:\r\n            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\r\n            break;\r\n        case 429:\r\n        case 502:\r\n        case 503:\r\n        case 504:\r\n            mappedStatusCode = constants_1.Status.UNAVAILABLE;\r\n            break;\r\n        default:\r\n            mappedStatusCode = constants_1.Status.UNKNOWN;\r\n    }\r\n    return {\r\n        code: mappedStatusCode,\r\n        details: details,\r\n        metadata: new metadata_1.Metadata()\r\n    };\r\n}\r\nclass Http2SubchannelCall {\r\n    constructor(http2Stream, callEventTracker, listener, transport, callId) {\r\n        var _a;\r\n        this.http2Stream = http2Stream;\r\n        this.callEventTracker = callEventTracker;\r\n        this.listener = listener;\r\n        this.transport = transport;\r\n        this.callId = callId;\r\n        this.isReadFilterPending = false;\r\n        this.isPushPending = false;\r\n        this.canPush = false;\r\n        /**\r\n         * Indicates that an 'end' event has come from the http2 stream, so there\r\n         * will be no more data events.\r\n         */\r\n        this.readsClosed = false;\r\n        this.statusOutput = false;\r\n        this.unpushedReadMessages = [];\r\n        // This is populated (non-null) if and only if the call has ended\r\n        this.finalStatus = null;\r\n        this.internalError = null;\r\n        this.serverEndedCall = false;\r\n        this.connectionDropped = false;\r\n        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\r\n        http2Stream.on('response', (headers, flags) => {\r\n            let headersString = '';\r\n            for (const header of Object.keys(headers)) {\r\n                headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\r\n            }\r\n            this.trace('Received server headers:\\n' + headersString);\r\n            this.httpStatusCode = headers[':status'];\r\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\r\n                this.handleTrailers(headers);\r\n            }\r\n            else {\r\n                let metadata;\r\n                try {\r\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n                }\r\n                catch (error) {\r\n                    this.endCall({\r\n                        code: constants_1.Status.UNKNOWN,\r\n                        details: error.message,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    });\r\n                    return;\r\n                }\r\n                this.listener.onReceiveMetadata(metadata);\r\n            }\r\n        });\r\n        http2Stream.on('trailers', (headers) => {\r\n            this.handleTrailers(headers);\r\n        });\r\n        http2Stream.on('data', (data) => {\r\n            /* If the status has already been output, allow the http2 stream to\r\n             * drain without processing the data. */\r\n            if (this.statusOutput) {\r\n                return;\r\n            }\r\n            this.trace('receive HTTP/2 data frame of length ' + data.length);\r\n            let messages;\r\n            try {\r\n                messages = this.decoder.write(data);\r\n            }\r\n            catch (e) {\r\n                /* Some servers send HTML error pages along with HTTP status codes.\r\n                 * When the client attempts to parse this as a length-delimited\r\n                 * message, the parsed message size is greater than the default limit,\r\n                 * resulting in a message decoding error. In that situation, the HTTP\r\n                 * error code information is more useful to the user than the\r\n                 * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,\r\n                 * we delay processing the HTTP status until after the stream ends, to\r\n                 * prioritize reporting the gRPC status from trailers if it is present,\r\n                 * but when there is a message parsing error we end the stream early\r\n                 * before processing trailers. */\r\n                if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {\r\n                    const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\r\n                    this.cancelWithStatus(mappedStatus.code, mappedStatus.details);\r\n                }\r\n                else {\r\n                    this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\r\n                }\r\n                return;\r\n            }\r\n            for (const message of messages) {\r\n                this.trace('parsed message of length ' + message.length);\r\n                this.callEventTracker.addMessageReceived();\r\n                this.tryPush(message);\r\n            }\r\n        });\r\n        http2Stream.on('end', () => {\r\n            this.readsClosed = true;\r\n            this.maybeOutputStatus();\r\n        });\r\n        http2Stream.on('close', () => {\r\n            this.serverEndedCall = true;\r\n            /* Use process.next tick to ensure that this code happens after any\r\n             * \"error\" event that may be emitted at about the same time, so that\r\n             * we can bubble up the error message from that event. */\r\n            process.nextTick(() => {\r\n                var _a;\r\n                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\r\n                /* If we have a final status with an OK status code, that means that\r\n                 * we have received all of the messages and we have processed the\r\n                 * trailers and the call completed successfully, so it doesn't matter\r\n                 * how the stream ends after that */\r\n                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\r\n                    return;\r\n                }\r\n                let code;\r\n                let details = '';\r\n                switch (http2Stream.rstCode) {\r\n                    case http2.constants.NGHTTP2_NO_ERROR:\r\n                        /* If we get a NO_ERROR code and we already have a status, the\r\n                         * stream completed properly and we just haven't fully processed\r\n                         * it yet */\r\n                        if (this.finalStatus !== null) {\r\n                            return;\r\n                        }\r\n                        if (this.httpStatusCode && this.httpStatusCode !== 200) {\r\n                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);\r\n                            code = mappedStatus.code;\r\n                            details = mappedStatus.details;\r\n                        }\r\n                        else {\r\n                            code = constants_1.Status.INTERNAL;\r\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;\r\n                        }\r\n                        break;\r\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\r\n                        code = constants_1.Status.UNAVAILABLE;\r\n                        details = 'Stream refused by server';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_CANCEL:\r\n                        /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL\r\n                         * code from connection drops. We want to prioritize reporting\r\n                         * an unavailable status when that happens. */\r\n                        if (this.connectionDropped) {\r\n                            code = constants_1.Status.UNAVAILABLE;\r\n                            details = 'Connection dropped';\r\n                        }\r\n                        else {\r\n                            code = constants_1.Status.CANCELLED;\r\n                            details = 'Call cancelled';\r\n                        }\r\n                        break;\r\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\r\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\r\n                        details = 'Bandwidth exhausted or memory limit exceeded';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\r\n                        code = constants_1.Status.PERMISSION_DENIED;\r\n                        details = 'Protocol not secure enough';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\r\n                        code = constants_1.Status.INTERNAL;\r\n                        if (this.internalError === null) {\r\n                            /* This error code was previously handled in the default case, and\r\n                             * there are several instances of it online, so I wanted to\r\n                             * preserve the original error message so that people find existing\r\n                             * information in searches, but also include the more recognizable\r\n                             * \"Internal server error\" message. */\r\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\r\n                        }\r\n                        else {\r\n                            if (this.internalError.code === 'ECONNRESET' ||\r\n                                this.internalError.code === 'ETIMEDOUT') {\r\n                                code = constants_1.Status.UNAVAILABLE;\r\n                                details = this.internalError.message;\r\n                            }\r\n                            else {\r\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\r\n                                 * here for continuity with errors reported online, but the\r\n                                 * error message at the end will probably be more relevant in\r\n                                 * most cases. */\r\n                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\r\n                            }\r\n                        }\r\n                        break;\r\n                    default:\r\n                        code = constants_1.Status.INTERNAL;\r\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\r\n                }\r\n                // This is a no-op if trailers were received at all.\r\n                // This is OK, because status codes emitted here correspond to more\r\n                // catastrophic issues that prevent us from receiving trailers in the\r\n                // first place.\r\n                this.endCall({\r\n                    code,\r\n                    details,\r\n                    metadata: new metadata_1.Metadata(),\r\n                    rstCode: http2Stream.rstCode,\r\n                });\r\n            });\r\n        });\r\n        http2Stream.on('error', (err) => {\r\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\r\n             * from bubbling up. However, errors here should all correspond to\r\n             * \"close\" events, where we will handle the error more granularly */\r\n            /* Specifically looking for stream errors that were *not* constructed\r\n             * from a RST_STREAM response here:\r\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\r\n             */\r\n            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\r\n                this.trace('Node error event: message=' +\r\n                    err.message +\r\n                    ' code=' +\r\n                    err.code +\r\n                    ' errno=' +\r\n                    getSystemErrorName(err.errno) +\r\n                    ' syscall=' +\r\n                    err.syscall);\r\n                this.internalError = err;\r\n            }\r\n            this.callEventTracker.onStreamEnd(false);\r\n        });\r\n    }\r\n    getDeadlineInfo() {\r\n        return [`remote_addr=${this.getPeer()}`];\r\n    }\r\n    onDisconnect() {\r\n        this.connectionDropped = true;\r\n        /* Give the call an event loop cycle to finish naturally before reporting\r\n         * the disconnection as an error. */\r\n        setImmediate(() => {\r\n            this.endCall({\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: 'Connection dropped',\r\n                metadata: new metadata_1.Metadata(),\r\n            });\r\n        });\r\n    }\r\n    outputStatus() {\r\n        /* Precondition: this.finalStatus !== null */\r\n        if (!this.statusOutput) {\r\n            this.statusOutput = true;\r\n            this.trace('ended with status: code=' +\r\n                this.finalStatus.code +\r\n                ' details=\"' +\r\n                this.finalStatus.details +\r\n                '\"');\r\n            this.callEventTracker.onCallEnd(this.finalStatus);\r\n            /* We delay the actual action of bubbling up the status to insulate the\r\n             * cleanup code in this class from any errors that may be thrown in the\r\n             * upper layers as a result of bubbling up the status. In particular,\r\n             * if the status is not OK, the \"error\" event may be emitted\r\n             * synchronously at the top level, which will result in a thrown error if\r\n             * the user does not handle that event. */\r\n            process.nextTick(() => {\r\n                this.listener.onReceiveStatus(this.finalStatus);\r\n            });\r\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\r\n             * ensure that the stream closure completes. The call stream already does\r\n             * not push more messages after the status is output, so the messages go\r\n             * nowhere either way. */\r\n            this.http2Stream.resume();\r\n        }\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\r\n    }\r\n    /**\r\n     * On first call, emits a 'status' event with the given StatusObject.\r\n     * Subsequent calls are no-ops.\r\n     * @param status The status of the call.\r\n     */\r\n    endCall(status) {\r\n        /* If the status is OK and a new status comes in (e.g. from a\r\n         * deserialization failure), that new status takes priority */\r\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\r\n            this.finalStatus = status;\r\n            this.maybeOutputStatus();\r\n        }\r\n        this.destroyHttp2Stream();\r\n    }\r\n    maybeOutputStatus() {\r\n        if (this.finalStatus !== null) {\r\n            /* The combination check of readsClosed and that the two message buffer\r\n             * arrays are empty checks that there all incoming data has been fully\r\n             * processed */\r\n            if (this.finalStatus.code !== constants_1.Status.OK ||\r\n                (this.readsClosed &&\r\n                    this.unpushedReadMessages.length === 0 &&\r\n                    !this.isReadFilterPending &&\r\n                    !this.isPushPending)) {\r\n                this.outputStatus();\r\n            }\r\n        }\r\n    }\r\n    push(message) {\r\n        this.trace('pushing to reader message of length ' +\r\n            (message instanceof Buffer ? message.length : null));\r\n        this.canPush = false;\r\n        this.isPushPending = true;\r\n        process.nextTick(() => {\r\n            this.isPushPending = false;\r\n            /* If we have already output the status any later messages should be\r\n             * ignored, and can cause out-of-order operation errors higher up in the\r\n             * stack. Checking as late as possible here to avoid any race conditions.\r\n             */\r\n            if (this.statusOutput) {\r\n                return;\r\n            }\r\n            this.listener.onReceiveMessage(message);\r\n            this.maybeOutputStatus();\r\n        });\r\n    }\r\n    tryPush(messageBytes) {\r\n        if (this.canPush) {\r\n            this.http2Stream.pause();\r\n            this.push(messageBytes);\r\n        }\r\n        else {\r\n            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\r\n            this.unpushedReadMessages.push(messageBytes);\r\n        }\r\n    }\r\n    handleTrailers(headers) {\r\n        this.serverEndedCall = true;\r\n        this.callEventTracker.onStreamEnd(true);\r\n        let headersString = '';\r\n        for (const header of Object.keys(headers)) {\r\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\r\n        }\r\n        this.trace('Received server trailers:\\n' + headersString);\r\n        let metadata;\r\n        try {\r\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n        }\r\n        catch (e) {\r\n            metadata = new metadata_1.Metadata();\r\n        }\r\n        const metadataMap = metadata.getMap();\r\n        let status;\r\n        if (typeof metadataMap['grpc-status'] === 'string') {\r\n            const receivedStatus = Number(metadataMap['grpc-status']);\r\n            this.trace('received status code ' + receivedStatus + ' from server');\r\n            metadata.remove('grpc-status');\r\n            let details = '';\r\n            if (typeof metadataMap['grpc-message'] === 'string') {\r\n                try {\r\n                    details = decodeURI(metadataMap['grpc-message']);\r\n                }\r\n                catch (e) {\r\n                    details = metadataMap['grpc-message'];\r\n                }\r\n                metadata.remove('grpc-message');\r\n                this.trace('received status details string \"' + details + '\" from server');\r\n            }\r\n            status = {\r\n                code: receivedStatus,\r\n                details: details,\r\n                metadata: metadata\r\n            };\r\n        }\r\n        else if (this.httpStatusCode) {\r\n            status = mapHttpStatusCode(this.httpStatusCode);\r\n            status.metadata = metadata;\r\n        }\r\n        else {\r\n            status = {\r\n                code: constants_1.Status.UNKNOWN,\r\n                details: 'No status information received',\r\n                metadata: metadata\r\n            };\r\n        }\r\n        // This is a no-op if the call was already ended when handling headers.\r\n        this.endCall(status);\r\n    }\r\n    destroyHttp2Stream() {\r\n        var _a;\r\n        // The http2 stream could already have been destroyed if cancelWithStatus\r\n        // is called in response to an internal http2 error.\r\n        if (this.http2Stream.destroyed) {\r\n            return;\r\n        }\r\n        /* If the server ended the call, sending an RST_STREAM is redundant, so we\r\n         * just half close on the client side instead to finish closing the stream.\r\n         */\r\n        if (this.serverEndedCall) {\r\n            this.http2Stream.end();\r\n        }\r\n        else {\r\n            /* If the call has ended with an OK status, communicate that when closing\r\n             * the stream, partly to avoid a situation in which we detect an error\r\n             * RST_STREAM as a result after we have the status */\r\n            let code;\r\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\r\n                code = http2.constants.NGHTTP2_NO_ERROR;\r\n            }\r\n            else {\r\n                code = http2.constants.NGHTTP2_CANCEL;\r\n            }\r\n            this.trace('close http2 stream with code ' + code);\r\n            this.http2Stream.close(code);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\r\n    }\r\n    getStatus() {\r\n        return this.finalStatus;\r\n    }\r\n    getPeer() {\r\n        return this.transport.getPeerName();\r\n    }\r\n    getCallNumber() {\r\n        return this.callId;\r\n    }\r\n    startRead() {\r\n        /* If the stream has ended with an error, we should not emit any more\r\n         * messages and we should communicate that the stream has ended */\r\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\r\n            this.readsClosed = true;\r\n            this.maybeOutputStatus();\r\n            return;\r\n        }\r\n        this.canPush = true;\r\n        if (this.unpushedReadMessages.length > 0) {\r\n            const nextMessage = this.unpushedReadMessages.shift();\r\n            this.push(nextMessage);\r\n            return;\r\n        }\r\n        /* Only resume reading from the http2Stream if we don't have any pending\r\n         * messages to emit */\r\n        this.http2Stream.resume();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        const cb = (error) => {\r\n            /* nextTick here ensures that no stream action can be taken in the call\r\n             * stack of the write callback, in order to hopefully work around\r\n             * https://github.com/nodejs/node/issues/49147 */\r\n            process.nextTick(() => {\r\n                var _a;\r\n                let code = constants_1.Status.UNAVAILABLE;\r\n                if ((error === null || error === void 0 ? void 0 : error.code) ===\r\n                    'ERR_STREAM_WRITE_AFTER_END') {\r\n                    code = constants_1.Status.INTERNAL;\r\n                }\r\n                if (error) {\r\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\r\n                }\r\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\r\n            });\r\n        };\r\n        this.trace('sending data chunk of length ' + message.length);\r\n        this.callEventTracker.addMessageSent();\r\n        try {\r\n            this.http2Stream.write(message, cb);\r\n        }\r\n        catch (error) {\r\n            this.endCall({\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: `Write failed with error ${error.message}`,\r\n                metadata: new metadata_1.Metadata(),\r\n            });\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('end() called');\r\n        this.trace('calling end() on HTTP/2 stream');\r\n        this.http2Stream.end();\r\n    }\r\n}\r\nexports.Http2SubchannelCall = Http2SubchannelCall;\r\n//# sourceMappingURL=subchannel-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUscUJBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUscUJBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUIsc0NBQXNDLDJCQUEyQjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUE0RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzP2ZmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ2FsbCA9IHZvaWQgMDtcclxuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbF9jYWxsJztcclxuLyoqXHJcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcclxuICogVHlwZVNjcmlwdCB0eXBlcyBkb24ndCBoYXZlIHRoYXQgZnVuY3Rpb24gZm9yIHNvbWUgcmVhc29uIHNvIEkganVzdCBtYWRlIG15XHJcbiAqIG93bi5cclxuICogQHBhcmFtIGVycm5vXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTeXN0ZW1FcnJvck5hbWUoZXJybm8pIHtcclxuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xyXG4gICAgICAgIGlmIChudW0gPT09IGVycm5vKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnVW5rbm93biBzeXN0ZW0gZXJyb3IgJyArIGVycm5vO1xyXG59XHJcbmZ1bmN0aW9uIG1hcEh0dHBTdGF0dXNDb2RlKGNvZGUpIHtcclxuICAgIGNvbnN0IGRldGFpbHMgPSBgUmVjZWl2ZWQgSFRUUCBzdGF0dXMgY29kZSAke2NvZGV9YDtcclxuICAgIGxldCBtYXBwZWRTdGF0dXNDb2RlO1xyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBoYW5kbGUgMTAwIGFuZCAxMDFcclxuICAgICAgICBjYXNlIDQwMDpcclxuICAgICAgICAgICAgbWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0MDE6XHJcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgbWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5QRVJNSVNTSU9OX0RFTklFRDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0MDQ6XHJcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0Mjk6XHJcbiAgICAgICAgY2FzZSA1MDI6XHJcbiAgICAgICAgY2FzZSA1MDM6XHJcbiAgICAgICAgY2FzZSA1MDQ6XHJcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIG1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTjtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29kZTogbWFwcGVkU3RhdHVzQ29kZSxcclxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxyXG4gICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpXHJcbiAgICB9O1xyXG59XHJcbmNsYXNzIEh0dHAyU3ViY2hhbm5lbENhbGwge1xyXG4gICAgY29uc3RydWN0b3IoaHR0cDJTdHJlYW0sIGNhbGxFdmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0cmFuc3BvcnQsIGNhbGxJZCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtID0gaHR0cDJTdHJlYW07XHJcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgICAgICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XHJcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYW4gJ2VuZCcgZXZlbnQgaGFzIGNvbWUgZnJvbSB0aGUgaHR0cDIgc3RyZWFtLCBzbyB0aGVyZVxyXG4gICAgICAgICAqIHdpbGwgYmUgbm8gbW9yZSBkYXRhIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgLy8gVGhpcyBpcyBwb3B1bGF0ZWQgKG5vbi1udWxsKSBpZiBhbmQgb25seSBpZiB0aGUgY2FsbCBoYXMgZW5kZWRcclxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmludGVybmFsRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VydmVyRW5kZWRDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRHJvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IG1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoID0gKF9hID0gdHJhbnNwb3J0LmdldE9wdGlvbnMoKVsnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xyXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIobWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGgpO1xyXG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdyZXNwb25zZScsIChoZWFkZXJzLCBmbGFncykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgaGVhZGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XHJcbiAgICAgICAgICAgIHRoaXMuaHR0cFN0YXR1c0NvZGUgPSBoZWFkZXJzWyc6c3RhdHVzJ107XHJcbiAgICAgICAgICAgIGlmIChmbGFncyAmIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0ZMQUdfRU5EX1NUUkVBTSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBodHRwMlN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBoYXMgYWxyZWFkeSBiZWVuIG91dHB1dCwgYWxsb3cgdGhlIGh0dHAyIHN0cmVhbSB0b1xyXG4gICAgICAgICAgICAgKiBkcmFpbiB3aXRob3V0IHByb2Nlc3NpbmcgdGhlIGRhdGEuICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGxldCBtZXNzYWdlcztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBTb21lIHNlcnZlcnMgc2VuZCBIVE1MIGVycm9yIHBhZ2VzIGFsb25nIHdpdGggSFRUUCBzdGF0dXMgY29kZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBXaGVuIHRoZSBjbGllbnQgYXR0ZW1wdHMgdG8gcGFyc2UgdGhpcyBhcyBhIGxlbmd0aC1kZWxpbWl0ZWRcclxuICAgICAgICAgICAgICAgICAqIG1lc3NhZ2UsIHRoZSBwYXJzZWQgbWVzc2FnZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZGVmYXVsdCBsaW1pdCxcclxuICAgICAgICAgICAgICAgICAqIHJlc3VsdGluZyBpbiBhIG1lc3NhZ2UgZGVjb2RpbmcgZXJyb3IuIEluIHRoYXQgc2l0dWF0aW9uLCB0aGUgSFRUUFxyXG4gICAgICAgICAgICAgICAgICogZXJyb3IgY29kZSBpbmZvcm1hdGlvbiBpcyBtb3JlIHVzZWZ1bCB0byB0aGUgdXNlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICAgICAgICogUkVTT1VSQ0VfRVhIQVVTVEVEIGVycm9yIGlzLCBzbyB3ZSByZXBvcnQgdGhhdCBpbnN0ZWFkLiBOb3JtYWxseSxcclxuICAgICAgICAgICAgICAgICAqIHdlIGRlbGF5IHByb2Nlc3NpbmcgdGhlIEhUVFAgc3RhdHVzIHVudGlsIGFmdGVyIHRoZSBzdHJlYW0gZW5kcywgdG9cclxuICAgICAgICAgICAgICAgICAqIHByaW9yaXRpemUgcmVwb3J0aW5nIHRoZSBnUlBDIHN0YXR1cyBmcm9tIHRyYWlsZXJzIGlmIGl0IGlzIHByZXNlbnQsXHJcbiAgICAgICAgICAgICAgICAgKiBidXQgd2hlbiB0aGVyZSBpcyBhIG1lc3NhZ2UgcGFyc2luZyBlcnJvciB3ZSBlbmQgdGhlIHN0cmVhbSBlYXJseVxyXG4gICAgICAgICAgICAgICAgICogYmVmb3JlIHByb2Nlc3NpbmcgdHJhaWxlcnMuICovXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5odHRwU3RhdHVzQ29kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaHR0cFN0YXR1c0NvZGUgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFN0YXR1cyA9IG1hcEh0dHBTdGF0dXNDb2RlKHRoaXMuaHR0cFN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhtYXBwZWRTdGF0dXMuY29kZSwgbWFwcGVkU3RhdHVzLmRldGFpbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdwYXJzZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5UHVzaChtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlckVuZGVkQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qIFVzZSBwcm9jZXNzLm5leHQgdGljayB0byBlbnN1cmUgdGhhdCB0aGlzIGNvZGUgaGFwcGVucyBhZnRlciBhbnlcclxuICAgICAgICAgICAgICogXCJlcnJvclwiIGV2ZW50IHRoYXQgbWF5IGJlIGVtaXR0ZWQgYXQgYWJvdXQgdGhlIHNhbWUgdGltZSwgc28gdGhhdFxyXG4gICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIGh0dHAyU3RyZWFtLnJzdENvZGUpO1xyXG4gICAgICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhIGZpbmFsIHN0YXR1cyB3aXRoIGFuIE9LIHN0YXR1cyBjb2RlLCB0aGF0IG1lYW5zIHRoYXRcclxuICAgICAgICAgICAgICAgICAqIHdlIGhhdmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBtZXNzYWdlcyBhbmQgd2UgaGF2ZSBwcm9jZXNzZWQgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcclxuICAgICAgICAgICAgICAgICAqIGhvdyB0aGUgc3RyZWFtIGVuZHMgYWZ0ZXIgdGhhdCAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb2RlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaHR0cDJTdHJlYW0ucnN0Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHN0cmVhbSBjb21wbGV0ZWQgcHJvcGVybHkgYW5kIHdlIGp1c3QgaGF2ZW4ndCBmdWxseSBwcm9jZXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgeWV0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaHR0cFN0YXR1c0NvZGUgJiYgdGhpcy5odHRwU3RhdHVzQ29kZSAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRTdGF0dXMgPSBtYXBIdHRwU3RhdHVzQ29kZSh0aGlzLmh0dHBTdGF0dXNDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBtYXBwZWRTdGF0dXMuY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtYXBwZWRTdGF0dXMuZGV0YWlscztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gKENhbGwgZW5kZWQgd2l0aG91dCBnUlBDIHN0YXR1cylgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnU3RyZWFtIHJlZnVzZWQgYnkgc2VydmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJ1ZyByZXBvcnRzIGluZGljYXRlIHRoYXQgTm9kZSBzeW50aGVzaXplcyBhIE5HSFRUUDJfQ0FOQ0VMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvZGUgZnJvbSBjb25uZWN0aW9uIGRyb3BzLiBXZSB3YW50IHRvIHByaW9yaXRpemUgcmVwb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFuIHVuYXZhaWxhYmxlIHN0YXR1cyB3aGVuIHRoYXQgaGFwcGVucy4gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkRyb3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0Nvbm5lY3Rpb24gZHJvcHBlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0JhbmR3aWR0aCBleGhhdXN0ZWQgb3IgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTlRFUk5BTF9FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBlcnJvciBjb2RlIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW4gdGhlIGRlZmF1bHQgY2FzZSwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlc2VydmUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2Ugc28gdGhhdCBwZW9wbGUgZmluZCBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gc2VhcmNoZXMsIGJ1dCBhbHNvIGluY2x1ZGUgdGhlIG1vcmUgcmVjb2duaXphYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gKEludGVybmFsIHNlcnZlciBlcnJvcilgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBcIlJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlIC4uLlwiIGVycm9yIGlzIHByZXNlcnZlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGhlcmUgZm9yIGNvbnRpbnVpdHkgd2l0aCBlcnJvcnMgcmVwb3J0ZWQgb25saW5lLCBidXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1vc3QgY2FzZXMuICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IHRyaWdnZXJlZCBieSBpbnRlcm5hbCBjbGllbnQgZXJyb3I6ICR7dGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIHRyYWlsZXJzIHdlcmUgcmVjZWl2ZWQgYXQgYWxsLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSywgYmVjYXVzZSBzdGF0dXMgY29kZXMgZW1pdHRlZCBoZXJlIGNvcnJlc3BvbmQgdG8gbW9yZVxyXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgaGVyZSB0byBzdG9wIFwiVW5jYXVnaHQgRXJyb3JcIiBleGNlcHRpb25zXHJcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xyXG4gICAgICAgICAgICAgKiBcImNsb3NlXCIgZXZlbnRzLCB3aGVyZSB3ZSB3aWxsIGhhbmRsZSB0aGUgZXJyb3IgbW9yZSBncmFudWxhcmx5ICovXHJcbiAgICAgICAgICAgIC8qIFNwZWNpZmljYWxseSBsb29raW5nIGZvciBzdHJlYW0gZXJyb3JzIHRoYXQgd2VyZSAqbm90KiBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxyXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi84Yjg2MjBkNTgwMzE0MDUwMTc1OTgzNDAyZGZkZGYyNjc0ZThlMjJhL2xpYi9pbnRlcm5hbC9odHRwMi9jb3JlLmpzI0wyMjY3XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTm9kZSBlcnJvciBldmVudDogbWVzc2FnZT0nICtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlICtcclxuICAgICAgICAgICAgICAgICAgICAnIGVycm5vPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcclxuICAgICAgICAgICAgICAgICAgICAnIHN5c2NhbGw9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZChmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREZWFkbGluZUluZm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtgcmVtb3RlX2FkZHI9JHt0aGlzLmdldFBlZXIoKX1gXTtcclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdCgpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Ecm9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAvKiBHaXZlIHRoZSBjYWxsIGFuIGV2ZW50IGxvb3AgY3ljbGUgdG8gZmluaXNoIG5hdHVyYWxseSBiZWZvcmUgcmVwb3J0aW5nXHJcbiAgICAgICAgICogdGhlIGRpc2Nvbm5lY3Rpb24gYXMgYW4gZXJyb3IuICovXHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3V0cHV0U3RhdHVzKCkge1xyXG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xyXG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNPdXRwdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuY29kZSArXHJcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuZGV0YWlscyArXHJcbiAgICAgICAgICAgICAgICAnXCInKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uQ2FsbEVuZCh0aGlzLmZpbmFsU3RhdHVzKTtcclxuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcclxuICAgICAgICAgICAgICogY2xlYW51cCBjb2RlIGluIHRoaXMgY2xhc3MgZnJvbSBhbnkgZXJyb3JzIHRoYXQgbWF5IGJlIHRocm93biBpbiB0aGVcclxuICAgICAgICAgICAgICogdXBwZXIgbGF5ZXJzIGFzIGEgcmVzdWx0IG9mIGJ1YmJsaW5nIHVwIHRoZSBzdGF0dXMuIEluIHBhcnRpY3VsYXIsXHJcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXHJcbiAgICAgICAgICAgICAqIHN5bmNocm9ub3VzbHkgYXQgdGhlIHRvcCBsZXZlbCwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSB0aHJvd24gZXJyb3IgaWZcclxuICAgICAgICAgICAgICogdGhlIHVzZXIgZG9lcyBub3QgaGFuZGxlIHRoYXQgZXZlbnQuICovXHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5maW5hbFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXHJcbiAgICAgICAgICAgICAqIGVuc3VyZSB0aGF0IHRoZSBzdHJlYW0gY2xvc3VyZSBjb21wbGV0ZXMuIFRoZSBjYWxsIHN0cmVhbSBhbHJlYWR5IGRvZXNcclxuICAgICAgICAgICAgICogbm90IHB1c2ggbW9yZSBtZXNzYWdlcyBhZnRlciB0aGUgc3RhdHVzIGlzIG91dHB1dCwgc28gdGhlIG1lc3NhZ2VzIGdvXHJcbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cclxuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5yZXN1bWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxJZCArICddICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT24gZmlyc3QgY2FsbCwgZW1pdHMgYSAnc3RhdHVzJyBldmVudCB3aXRoIHRoZSBnaXZlbiBTdGF0dXNPYmplY3QuXHJcbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXHJcbiAgICAgKiBAcGFyYW0gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIGNhbGwuXHJcbiAgICAgKi9cclxuICAgIGVuZENhbGwoc3RhdHVzKSB7XHJcbiAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBpcyBPSyBhbmQgYSBuZXcgc3RhdHVzIGNvbWVzIGluIChlLmcuIGZyb20gYVxyXG4gICAgICAgICAqIGRlc2VyaWFsaXphdGlvbiBmYWlsdXJlKSwgdGhhdCBuZXcgc3RhdHVzIHRha2VzIHByaW9yaXR5ICovXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlc3Ryb3lIdHRwMlN0cmVhbSgpO1xyXG4gICAgfVxyXG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLyogVGhlIGNvbWJpbmF0aW9uIGNoZWNrIG9mIHJlYWRzQ2xvc2VkIGFuZCB0aGF0IHRoZSB0d28gbWVzc2FnZSBidWZmZXJcclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxyXG4gICAgICAgICAgICAgKiBwcm9jZXNzZWQgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVzaFBlbmRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHVzaChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXHJcbiAgICAgICAgICAgIChtZXNzYWdlIGluc3RhbmNlb2YgQnVmZmVyID8gbWVzc2FnZS5sZW5ndGggOiBudWxsKSk7XHJcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgICAqIGlnbm9yZWQsIGFuZCBjYW4gY2F1c2Ugb3V0LW9mLW9yZGVyIG9wZXJhdGlvbiBlcnJvcnMgaGlnaGVyIHVwIGluIHRoZVxyXG4gICAgICAgICAgICAgKiBzdGFjay4gQ2hlY2tpbmcgYXMgbGF0ZSBhcyBwb3NzaWJsZSBoZXJlIHRvIGF2b2lkIGFueSByYWNlIGNvbmRpdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNPdXRwdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyeVB1c2gobWVzc2FnZUJ5dGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChtZXNzYWdlQnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgndW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZUJ5dGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcclxuICAgICAgICB0aGlzLnNlcnZlckVuZGVkQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xyXG4gICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIHRyYWlsZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcclxuICAgICAgICBsZXQgbWV0YWRhdGE7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5nZXRNYXAoKTtcclxuICAgICAgICBsZXQgc3RhdHVzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtc3RhdHVzJyk7XHJcbiAgICAgICAgICAgIGxldCBkZXRhaWxzID0gJyc7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0dXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiByZWNlaXZlZFN0YXR1cyxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5odHRwU3RhdHVzQ29kZSkge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSBtYXBIdHRwU3RhdHVzQ29kZSh0aGlzLmh0dHBTdGF0dXNDb2RlKTtcclxuICAgICAgICAgICAgc3RhdHVzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBzdGF0dXMgaW5mb3JtYXRpb24gcmVjZWl2ZWQnLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXHJcbiAgICAgICAgdGhpcy5lbmRDYWxsKHN0YXR1cyk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIFRoZSBodHRwMiBzdHJlYW0gY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gZGVzdHJveWVkIGlmIGNhbmNlbFdpdGhTdGF0dXNcclxuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXHJcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTdHJlYW0uZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogSWYgdGhlIHNlcnZlciBlbmRlZCB0aGUgY2FsbCwgc2VuZGluZyBhbiBSU1RfU1RSRUFNIGlzIHJlZHVuZGFudCwgc28gd2VcclxuICAgICAgICAgKiBqdXN0IGhhbGYgY2xvc2Ugb24gdGhlIGNsaWVudCBzaWRlIGluc3RlYWQgdG8gZmluaXNoIGNsb3NpbmcgdGhlIHN0cmVhbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJFbmRlZENhbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5lbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcclxuICAgICAgICAgICAgICogdGhlIHN0cmVhbSwgcGFydGx5IHRvIGF2b2lkIGEgc2l0dWF0aW9uIGluIHdoaWNoIHdlIGRldGVjdCBhbiBlcnJvclxyXG4gICAgICAgICAgICAgKiBSU1RfU1RSRUFNIGFzIGEgcmVzdWx0IGFmdGVyIHdlIGhhdmUgdGhlIHN0YXR1cyAqL1xyXG4gICAgICAgICAgICBsZXQgY29kZTtcclxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjbG9zZSBodHRwMiBzdHJlYW0gd2l0aCBjb2RlICcgKyBjb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5jbG9zZShjb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xyXG4gICAgICAgIHRoaXMuZW5kQ2FsbCh7IGNvZGU6IHN0YXR1cywgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTdGF0dXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxTdGF0dXM7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5nZXRQZWVyTmFtZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQ7XHJcbiAgICB9XHJcbiAgICBzdGFydFJlYWQoKSB7XHJcbiAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2Ugc2hvdWxkIG5vdCBlbWl0IGFueSBtb3JlXHJcbiAgICAgICAgICogbWVzc2FnZXMgYW5kIHdlIHNob3VsZCBjb21tdW5pY2F0ZSB0aGF0IHRoZSBzdHJlYW0gaGFzIGVuZGVkICovXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChuZXh0TWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogT25seSByZXN1bWUgcmVhZGluZyBmcm9tIHRoZSBodHRwMlN0cmVhbSBpZiB3ZSBkb24ndCBoYXZlIGFueSBwZW5kaW5nXHJcbiAgICAgICAgICogbWVzc2FnZXMgdG8gZW1pdCAqL1xyXG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY2IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgLyogbmV4dFRpY2sgaGVyZSBlbnN1cmVzIHRoYXQgbm8gc3RyZWFtIGFjdGlvbiBjYW4gYmUgdGFrZW4gaW4gdGhlIGNhbGxcclxuICAgICAgICAgICAgICogc3RhY2sgb2YgdGhlIHdyaXRlIGNhbGxiYWNrLCBpbiBvcmRlciB0byBob3BlZnVsbHkgd29yayBhcm91bmRcclxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTE0NyAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgICAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgYFdyaXRlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2EgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250ZXh0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdzZW5kaW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLmFkZE1lc3NhZ2VTZW50KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS53cml0ZShtZXNzYWdlLCBjYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuZENhbGwoe1xyXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbGZDbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdlbmQoKSBjYWxsZWQnKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjYWxsaW5nIGVuZCgpIG9uIEhUVFAvMiBzdHJlYW0nKTtcclxuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmVuZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ2FsbCA9IEh0dHAyU3ViY2hhbm5lbENhbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseSubchannelWrapper = void 0;\r\nclass BaseSubchannelWrapper {\r\n    constructor(child) {\r\n        this.child = child;\r\n        this.healthy = true;\r\n        this.healthListeners = new Set();\r\n        child.addHealthStateWatcher(childHealthy => {\r\n            /* A change to the child health state only affects this wrapper's overall\r\n             * health state if this wrapper is reporting healthy. */\r\n            if (this.healthy) {\r\n                this.updateHealthListeners();\r\n            }\r\n        });\r\n    }\r\n    updateHealthListeners() {\r\n        for (const listener of this.healthListeners) {\r\n            listener(this.isHealthy());\r\n        }\r\n    }\r\n    getConnectivityState() {\r\n        return this.child.getConnectivityState();\r\n    }\r\n    addConnectivityStateListener(listener) {\r\n        this.child.addConnectivityStateListener(listener);\r\n    }\r\n    removeConnectivityStateListener(listener) {\r\n        this.child.removeConnectivityStateListener(listener);\r\n    }\r\n    startConnecting() {\r\n        this.child.startConnecting();\r\n    }\r\n    getAddress() {\r\n        return this.child.getAddress();\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        this.child.throttleKeepalive(newKeepaliveTime);\r\n    }\r\n    ref() {\r\n        this.child.ref();\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n    }\r\n    getChannelzRef() {\r\n        return this.child.getChannelzRef();\r\n    }\r\n    isHealthy() {\r\n        return this.healthy && this.child.isHealthy();\r\n    }\r\n    addHealthStateWatcher(listener) {\r\n        this.healthListeners.add(listener);\r\n    }\r\n    removeHealthStateWatcher(listener) {\r\n        this.healthListeners.delete(listener);\r\n    }\r\n    setHealthy(healthy) {\r\n        if (healthy !== this.healthy) {\r\n            this.healthy = healthy;\r\n            /* A change to this wrapper's health state only affects the overall\r\n             * reported health state if the child is healthy. */\r\n            if (this.child.isHealthy()) {\r\n                this.updateHealthListeners();\r\n            }\r\n        }\r\n    }\r\n    getRealSubchannel() {\r\n        return this.child.getRealSubchannel();\r\n    }\r\n    realSubchannelEquals(other) {\r\n        return this.getRealSubchannel() === other.getRealSubchannel();\r\n    }\r\n    getCallCredentials() {\r\n        return this.child.getCallCredentials();\r\n    }\r\n}\r\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\r\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtaW50ZXJmYWNlLmpzPzBmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xyXG5jbGFzcyBCYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGQpIHtcclxuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XHJcbiAgICAgICAgdGhpcy5oZWFsdGh5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmhlYWx0aExpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBjaGlsZC5hZGRIZWFsdGhTdGF0ZVdhdGNoZXIoY2hpbGRIZWFsdGh5ID0+IHtcclxuICAgICAgICAgICAgLyogQSBjaGFuZ2UgdG8gdGhlIGNoaWxkIGhlYWx0aCBzdGF0ZSBvbmx5IGFmZmVjdHMgdGhpcyB3cmFwcGVyJ3Mgb3ZlcmFsbFxyXG4gICAgICAgICAgICAgKiBoZWFsdGggc3RhdGUgaWYgdGhpcyB3cmFwcGVyIGlzIHJlcG9ydGluZyBoZWFsdGh5LiAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFsdGh5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVIZWFsdGhMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmhlYWx0aExpc3RlbmVycykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmlzSGVhbHRoeSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWRkcmVzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRBZGRyZXNzKCk7XHJcbiAgICB9XHJcbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcclxuICAgIH1cclxuICAgIHJlZigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xyXG4gICAgfVxyXG4gICAgdW5yZWYoKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcclxuICAgIH1cclxuICAgIGlzSGVhbHRoeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFsdGh5ICYmIHRoaXMuY2hpbGQuaXNIZWFsdGh5KCk7XHJcbiAgICB9XHJcbiAgICBhZGRIZWFsdGhTdGF0ZVdhdGNoZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmhlYWx0aExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSGVhbHRoU3RhdGVXYXRjaGVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5oZWFsdGhMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHNldEhlYWx0aHkoaGVhbHRoeSkge1xyXG4gICAgICAgIGlmIChoZWFsdGh5ICE9PSB0aGlzLmhlYWx0aHkpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5ID0gaGVhbHRoeTtcclxuICAgICAgICAgICAgLyogQSBjaGFuZ2UgdG8gdGhpcyB3cmFwcGVyJ3MgaGVhbHRoIHN0YXRlIG9ubHkgYWZmZWN0cyB0aGUgb3ZlcmFsbFxyXG4gICAgICAgICAgICAgKiByZXBvcnRlZCBoZWFsdGggc3RhdGUgaWYgdGhlIGNoaWxkIGlzIGhlYWx0aHkuICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkLmlzSGVhbHRoeSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhlYWx0aExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcclxuICAgIH1cclxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcclxuICAgIH1cclxuICAgIGdldENhbGxDcmVkZW50aWFscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDYWxsQ3JlZGVudGlhbHMoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IEJhc2VTdWJjaGFubmVsV3JhcHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SubchannelPool = void 0;\r\nexports.getSubchannelPool = getSubchannelPool;\r\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\r\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\r\n// 10 seconds in milliseconds. This value is arbitrary.\r\n/**\r\n * The amount of time in between checks for dropping subchannels that have no\r\n * other references\r\n */\r\nconst REF_CHECK_INTERVAL = 10000;\r\nclass SubchannelPool {\r\n    /**\r\n     * A pool of subchannels use for making connections. Subchannels with the\r\n     * exact same parameters will be reused.\r\n     */\r\n    constructor() {\r\n        this.pool = Object.create(null);\r\n        /**\r\n         * A timer of a task performing a periodic subchannel cleanup.\r\n         */\r\n        this.cleanupTimer = null;\r\n    }\r\n    /**\r\n     * Unrefs all unused subchannels and cancels the cleanup task if all\r\n     * subchannels have been unrefed.\r\n     */\r\n    unrefUnusedSubchannels() {\r\n        let allSubchannelsUnrefed = true;\r\n        /* These objects are created with Object.create(null), so they do not\r\n         * have a prototype, which means that for (... in ...) loops over them\r\n         * do not need to be filtered */\r\n        // eslint-disable-disable-next-line:forin\r\n        for (const channelTarget in this.pool) {\r\n            const subchannelObjArray = this.pool[channelTarget];\r\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\r\n            if (refedSubchannels.length > 0) {\r\n                allSubchannelsUnrefed = false;\r\n            }\r\n            /* For each subchannel in the pool, try to unref it if it has\r\n             * exactly one ref (which is the ref from the pool itself). If that\r\n             * does happen, remove the subchannel from the pool */\r\n            this.pool[channelTarget] = refedSubchannels;\r\n        }\r\n        /* Currently we do not delete keys with empty values. If that results\r\n         * in significant memory usage we should change it. */\r\n        // Cancel the cleanup task if all subchannels have been unrefed.\r\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\r\n            clearInterval(this.cleanupTimer);\r\n            this.cleanupTimer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Ensures that the cleanup task is spawned.\r\n     */\r\n    ensureCleanupTask() {\r\n        var _a, _b;\r\n        if (this.cleanupTimer === null) {\r\n            this.cleanupTimer = setInterval(() => {\r\n                this.unrefUnusedSubchannels();\r\n            }, REF_CHECK_INTERVAL);\r\n            // Unref because this timer should not keep the event loop running.\r\n            // Call unref only if it exists to address electron/electron#21162\r\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    }\r\n    /**\r\n     * Get a subchannel if one already exists with exactly matching parameters.\r\n     * Otherwise, create and save a subchannel with those parameters.\r\n     * @param channelTarget\r\n     * @param subchannelTarget\r\n     * @param channelArguments\r\n     * @param channelCredentials\r\n     */\r\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\r\n        this.ensureCleanupTask();\r\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\r\n        if (channelTarget in this.pool) {\r\n            const subchannelObjArray = this.pool[channelTarget];\r\n            for (const subchannelObj of subchannelObjArray) {\r\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&\r\n                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&\r\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\r\n                    return subchannelObj.subchannel;\r\n                }\r\n            }\r\n        }\r\n        // If we get here, no matching subchannel was found\r\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\r\n        if (!(channelTarget in this.pool)) {\r\n            this.pool[channelTarget] = [];\r\n        }\r\n        this.pool[channelTarget].push({\r\n            subchannelAddress: subchannelTarget,\r\n            channelArguments,\r\n            channelCredentials,\r\n            subchannel,\r\n        });\r\n        subchannel.ref();\r\n        return subchannel;\r\n    }\r\n}\r\nexports.SubchannelPool = SubchannelPool;\r\nconst globalSubchannelPool = new SubchannelPool();\r\n/**\r\n * Get either the global subchannel pool, or a new subchannel pool.\r\n * @param global\r\n */\r\nfunction getSubchannelPool(global) {\r\n    if (global) {\r\n        return globalSubchannelPool;\r\n    }\r\n    else {\r\n        return new SubchannelPool();\r\n    }\r\n}\r\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QiwwQkFBMEIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtcG9vbC5qcz81ZGQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN1YmNoYW5uZWxQb29sID0gdm9pZCAwO1xyXG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XHJcbmNvbnN0IGNoYW5uZWxfb3B0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1vcHRpb25zXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XHJcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cclxuLyoqXHJcbiAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIGNoZWNrcyBmb3IgZHJvcHBpbmcgc3ViY2hhbm5lbHMgdGhhdCBoYXZlIG5vXHJcbiAqIG90aGVyIHJlZmVyZW5jZXNcclxuICovXHJcbmNvbnN0IFJFRl9DSEVDS19JTlRFUlZBTCA9IDEwMDAwO1xyXG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XHJcbiAgICAvKipcclxuICAgICAqIEEgcG9vbCBvZiBzdWJjaGFubmVscyB1c2UgZm9yIG1ha2luZyBjb25uZWN0aW9ucy4gU3ViY2hhbm5lbHMgd2l0aCB0aGVcclxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRpbWVyIG9mIGEgdGFzayBwZXJmb3JtaW5nIGEgcGVyaW9kaWMgc3ViY2hhbm5lbCBjbGVhbnVwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5yZWZzIGFsbCB1bnVzZWQgc3ViY2hhbm5lbHMgYW5kIGNhbmNlbHMgdGhlIGNsZWFudXAgdGFzayBpZiBhbGxcclxuICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxyXG4gICAgICovXHJcbiAgICB1bnJlZlVudXNlZFN1YmNoYW5uZWxzKCkge1xyXG4gICAgICAgIGxldCBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxyXG4gICAgICAgICAqIGhhdmUgYSBwcm90b3R5cGUsIHdoaWNoIG1lYW5zIHRoYXQgZm9yICguLi4gaW4gLi4uKSBsb29wcyBvdmVyIHRoZW1cclxuICAgICAgICAgKiBkbyBub3QgbmVlZCB0byBiZSBmaWx0ZXJlZCAqL1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXHJcbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKHZhbHVlID0+ICF2YWx1ZS5zdWJjaGFubmVsLnVucmVmSWZPbmVSZWYoKSk7XHJcbiAgICAgICAgICAgIGlmIChyZWZlZFN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIEZvciBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIHBvb2wsIHRyeSB0byB1bnJlZiBpdCBpZiBpdCBoYXNcclxuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxyXG4gICAgICAgICAgICAgKiBkb2VzIGhhcHBlbiwgcmVtb3ZlIHRoZSBzdWJjaGFubmVsIGZyb20gdGhlIHBvb2wgKi9cclxuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gcmVmZWRTdWJjaGFubmVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogQ3VycmVudGx5IHdlIGRvIG5vdCBkZWxldGUga2V5cyB3aXRoIGVtcHR5IHZhbHVlcy4gSWYgdGhhdCByZXN1bHRzXHJcbiAgICAgICAgICogaW4gc2lnbmlmaWNhbnQgbWVtb3J5IHVzYWdlIHdlIHNob3VsZCBjaGFuZ2UgaXQuICovXHJcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxyXG4gICAgICAgIGlmIChhbGxTdWJjaGFubmVsc1VucmVmZWQgJiYgdGhpcy5jbGVhbnVwVGltZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgY2xlYW51cCB0YXNrIGlzIHNwYXduZWQuXHJcbiAgICAgKi9cclxuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XHJcbiAgICAgICAgICAgIH0sIFJFRl9DSEVDS19JTlRFUlZBTCk7XHJcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cclxuICAgICAgICAgICAgLy8gQ2FsbCB1bnJlZiBvbmx5IGlmIGl0IGV4aXN0cyB0byBhZGRyZXNzIGVsZWN0cm9uL2VsZWN0cm9uIzIxMTYyXHJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2xlYW51cFRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBPdGhlcndpc2UsIGNyZWF0ZSBhbmQgc2F2ZSBhIHN1YmNoYW5uZWwgd2l0aCB0aG9zZSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXRcclxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbEFyZ3VtZW50c1xyXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFsc1xyXG4gICAgICovXHJcbiAgICBnZXRPckNyZWF0ZVN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDbGVhbnVwVGFzaygpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShjaGFubmVsVGFyZ2V0VXJpKTtcclxuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxPYmogb2Ygc3ViY2hhbm5lbE9iakFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwpKHN1YmNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbEFkZHJlc3MpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWxfb3B0aW9uc18xLmNoYW5uZWxPcHRpb25zRXF1YWwpKGNoYW5uZWxBcmd1bWVudHMsIHN1YmNoYW5uZWxPYmouY2hhbm5lbEFyZ3VtZW50cykgJiZcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbE9iai5zdWJjaGFubmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBtYXRjaGluZyBzdWJjaGFubmVsIHdhcyBmb3VuZFxyXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzLCBuZXcgdHJhbnNwb3J0XzEuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXRVcmkpKTtcclxuICAgICAgICBpZiAoIShjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XS5wdXNoKHtcclxuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3M6IHN1YmNoYW5uZWxUYXJnZXQsXHJcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXHJcbiAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgc3ViY2hhbm5lbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xyXG4gICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSBTdWJjaGFubmVsUG9vbDtcclxuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcclxuLyoqXHJcbiAqIEdldCBlaXRoZXIgdGhlIGdsb2JhbCBzdWJjaGFubmVsIHBvb2wsIG9yIGEgbmV3IHN1YmNoYW5uZWwgcG9vbC5cclxuICogQHBhcmFtIGdsb2JhbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3ViY2hhbm5lbFBvb2woZ2xvYmFsKSB7XHJcbiAgICBpZiAoZ2xvYmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFN1YmNoYW5uZWxQb29sO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJjaGFubmVsUG9vbCgpO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtcG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Subchannel = void 0;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst TRACER_NAME = 'subchannel';\r\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\r\n * have a constant for the max signed 32 bit integer, so this is a simple way\r\n * to calculate it */\r\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\r\nclass Subchannel {\r\n    /**\r\n     * A class representing a connection to a single backend.\r\n     * @param channelTarget The target string for the channel as a whole\r\n     * @param subchannelAddress The address for the backend that this subchannel\r\n     *     will connect to\r\n     * @param options The channel options, plus any specific subchannel options\r\n     *     for this subchannel\r\n     * @param credentials The channel credentials used to establish this\r\n     *     connection\r\n     */\r\n    constructor(channelTarget, subchannelAddress, options, credentials, connector) {\r\n        var _a;\r\n        this.channelTarget = channelTarget;\r\n        this.subchannelAddress = subchannelAddress;\r\n        this.options = options;\r\n        this.connector = connector;\r\n        /**\r\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\r\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\r\n         */\r\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The underlying http2 session used to make requests.\r\n         */\r\n        this.transport = null;\r\n        /**\r\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\r\n         * CONNECTING instead of IDLE when the backoff timeout ends.\r\n         */\r\n        this.continueConnecting = false;\r\n        /**\r\n         * A list of listener functions that will be called whenever the connectivity\r\n         * state changes. Will be modified by `addConnectivityStateListener` and\r\n         * `removeConnectivityStateListener`\r\n         */\r\n        this.stateListeners = new Set();\r\n        /**\r\n         * Tracks channels and subchannel pools with references to this subchannel\r\n         */\r\n        this.refcount = 0;\r\n        // Channelz info\r\n        this.channelzEnabled = true;\r\n        const backoffOptions = {\r\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\r\n            this.handleBackoffTimer();\r\n        }, backoffOptions);\r\n        this.backoffTimeout.unref();\r\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\r\n        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\r\n        if (options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n            this.channelzTrace = new channelz_1.ChannelzTraceStub();\r\n            this.callTracker = new channelz_1.ChannelzCallTrackerStub();\r\n            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\r\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\r\n        }\r\n        else {\r\n            this.channelzTrace = new channelz_1.ChannelzTrace();\r\n            this.callTracker = new channelz_1.ChannelzCallTracker();\r\n            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\r\n        }\r\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\r\n        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\r\n        this.trace('Subchannel constructed with options ' +\r\n            JSON.stringify(options, undefined, 2));\r\n        this.secureConnector = credentials._createSecureConnector(channelTarget, options);\r\n    }\r\n    getChannelzInfo() {\r\n        return {\r\n            state: this.connectivityState,\r\n            trace: this.channelzTrace,\r\n            callTracker: this.callTracker,\r\n            children: this.childrenTracker.getChildLists(),\r\n            target: this.subchannelAddressString,\r\n        };\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    refTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    handleBackoffTimer() {\r\n        if (this.continueConnecting) {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\r\n        }\r\n        else {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\r\n        }\r\n    }\r\n    /**\r\n     * Start a backoff timer with the current nextBackoff timeout\r\n     */\r\n    startBackoff() {\r\n        this.backoffTimeout.runOnce();\r\n    }\r\n    stopBackoff() {\r\n        this.backoffTimeout.stop();\r\n        this.backoffTimeout.reset();\r\n    }\r\n    startConnectingInternal() {\r\n        let options = this.options;\r\n        if (options['grpc.keepalive_time_ms']) {\r\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\r\n            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });\r\n        }\r\n        this.connector\r\n            .connect(this.subchannelAddress, this.secureConnector, options)\r\n            .then(transport => {\r\n            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\r\n                this.transport = transport;\r\n                if (this.channelzEnabled) {\r\n                    this.childrenTracker.refChild(transport.getChannelzRef());\r\n                }\r\n                transport.addDisconnectListener(tooManyPings => {\r\n                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\r\n                    if (tooManyPings && this.keepaliveTime > 0) {\r\n                        this.keepaliveTime *= 2;\r\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                /* If we can't transition from CONNECTING to READY here, we will\r\n                 * not be using this transport, so release its resources. */\r\n                transport.shutdown();\r\n            }\r\n        }, error => {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\r\n        });\r\n    }\r\n    /**\r\n     * Initiate a state transition from any element of oldStates to the new\r\n     * state. If the current connectivityState is not in oldStates, do nothing.\r\n     * @param oldStates The set of states to transition from\r\n     * @param newState The state to transition to\r\n     * @returns True if the state changed, false otherwise\r\n     */\r\n    transitionToState(oldStates, newState, errorMessage) {\r\n        var _a, _b;\r\n        if (oldStates.indexOf(this.connectivityState) === -1) {\r\n            return false;\r\n        }\r\n        if (errorMessage) {\r\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\r\n                ' -> ' +\r\n                connectivity_state_1.ConnectivityState[newState] +\r\n                ' with error \"' + errorMessage + '\"');\r\n        }\r\n        else {\r\n            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\r\n                ' -> ' +\r\n                connectivity_state_1.ConnectivityState[newState]);\r\n        }\r\n        if (this.channelzEnabled) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\r\n        }\r\n        const previousState = this.connectivityState;\r\n        this.connectivityState = newState;\r\n        switch (newState) {\r\n            case connectivity_state_1.ConnectivityState.READY:\r\n                this.stopBackoff();\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.CONNECTING:\r\n                this.startBackoff();\r\n                this.startConnectingInternal();\r\n                this.continueConnecting = false;\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\r\n                if (this.channelzEnabled && this.transport) {\r\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\r\n                }\r\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\r\n                this.transport = null;\r\n                /* If the backoff timer has already ended by the time we get to the\r\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\r\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\r\n                if (!this.backoffTimeout.isRunning()) {\r\n                    process.nextTick(() => {\r\n                        this.handleBackoffTimer();\r\n                    });\r\n                }\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.IDLE:\r\n                if (this.channelzEnabled && this.transport) {\r\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\r\n                }\r\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\r\n                this.transport = null;\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\r\n        }\r\n        for (const listener of this.stateListeners) {\r\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\r\n        }\r\n        return true;\r\n    }\r\n    ref() {\r\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\r\n        this.refcount += 1;\r\n    }\r\n    unref() {\r\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\r\n        this.refcount -= 1;\r\n        if (this.refcount === 0) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\r\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n            this.secureConnector.destroy();\r\n            process.nextTick(() => {\r\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\r\n            });\r\n        }\r\n    }\r\n    unrefIfOneRef() {\r\n        if (this.refcount === 1) {\r\n            this.unref();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createCall(metadata, host, method, listener) {\r\n        if (!this.transport) {\r\n            throw new Error('Cannot create call, subchannel not READY');\r\n        }\r\n        let statsTracker;\r\n        if (this.channelzEnabled) {\r\n            this.callTracker.addCallStarted();\r\n            this.streamTracker.addCallStarted();\r\n            statsTracker = {\r\n                onCallEnd: status => {\r\n                    if (status.code === constants_1.Status.OK) {\r\n                        this.callTracker.addCallSucceeded();\r\n                    }\r\n                    else {\r\n                        this.callTracker.addCallFailed();\r\n                    }\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            statsTracker = {};\r\n        }\r\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\r\n    }\r\n    /**\r\n     * If the subchannel is currently IDLE, start connecting and switch to the\r\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\r\n     * the next time it would transition to IDLE, start connecting again instead.\r\n     * Otherwise, do nothing.\r\n     */\r\n    startConnecting() {\r\n        process.nextTick(() => {\r\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\r\n             * because the state is not currently IDLE, check if it is\r\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\r\n             * connecting after the backoff timer ends. Otherwise do nothing */\r\n            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\r\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                    this.continueConnecting = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Get the subchannel's current connectivity state.\r\n     */\r\n    getConnectivityState() {\r\n        return this.connectivityState;\r\n    }\r\n    /**\r\n     * Add a listener function to be called whenever the subchannel's\r\n     * connectivity state changes.\r\n     * @param listener\r\n     */\r\n    addConnectivityStateListener(listener) {\r\n        this.stateListeners.add(listener);\r\n    }\r\n    /**\r\n     * Remove a listener previously added with `addConnectivityStateListener`\r\n     * @param listener A reference to a function previously passed to\r\n     *     `addConnectivityStateListener`\r\n     */\r\n    removeConnectivityStateListener(listener) {\r\n        this.stateListeners.delete(listener);\r\n    }\r\n    /**\r\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\r\n     */\r\n    resetBackoff() {\r\n        process.nextTick(() => {\r\n            this.backoffTimeout.reset();\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\r\n        });\r\n    }\r\n    getAddress() {\r\n        return this.subchannelAddressString;\r\n    }\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    isHealthy() {\r\n        return true;\r\n    }\r\n    addHealthStateWatcher(listener) {\r\n        // Do nothing with the listener\r\n    }\r\n    removeHealthStateWatcher(listener) {\r\n        // Do nothing with the listener\r\n    }\r\n    getRealSubchannel() {\r\n        return this;\r\n    }\r\n    realSubchannelEquals(other) {\r\n        return other.getRealSubchannel() === this;\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        if (newKeepaliveTime > this.keepaliveTime) {\r\n            this.keepaliveTime = newKeepaliveTime;\r\n        }\r\n    }\r\n    getCallCredentials() {\r\n        return this.secureConnector.getCallCredentials();\r\n    }\r\n}\r\nexports.Subchannel = Subchannel;\r\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsaURBQWlEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLG1EQUFtRCxLQUFLLDhCQUE4QiwwRUFBMEUsb0JBQW9CO0FBQ3pRO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxSkFBcUosTUFBTTtBQUMzSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxTQUFTO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcz9kNTJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN1YmNoYW5uZWwgPSB2b2lkIDA7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzdWJjaGFubmVsJztcclxuLyogc2V0SW50ZXJ2YWwgYW5kIHNldFRpbWVvdXQgb25seSBhY2NlcHQgc2lnbmVkIDMyIGJpdCBpbnRlZ2Vycy4gSlMgZG9lc24ndFxyXG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxyXG4gKiB0byBjYWxjdWxhdGUgaXQgKi9cclxuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcclxuY2xhc3MgU3ViY2hhbm5lbCB7XHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBiYWNrZW5kLlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcclxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsQWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIGJhY2tlbmQgdGhhdCB0aGlzIHN1YmNoYW5uZWxcclxuICAgICAqICAgICB3aWxsIGNvbm5lY3QgdG9cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xyXG4gICAgICogICAgIGZvciB0aGlzIHN1YmNoYW5uZWxcclxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY2hhbm5lbCBjcmVkZW50aWFscyB1c2VkIHRvIGVzdGFibGlzaCB0aGlzXHJcbiAgICAgKiAgICAgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgY3JlZGVudGlhbHMsIGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuIEludmFyaWFudDogYHNlc3Npb25gID09PSBgbnVsbGBcclxuICAgICAgICAgKiBpZiBhbmQgb25seSBpZiBgY29ubmVjdGl2aXR5U3RhdGVgIGlzIElETEUgb3IgVFJBTlNJRU5UX0ZBSUxVUkUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgaHR0cDIgc2Vzc2lvbiB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBzdWJjaGFubmVsIHNob3VsZCB0cmFuc2l0aW9uIGZyb20gVFJBTlNJRU5UX0ZBSUxVUkUgdG9cclxuICAgICAgICAgKiBDT05ORUNUSU5HIGluc3RlYWQgb2YgSURMRSB3aGVuIHRoZSBiYWNrb2ZmIHRpbWVvdXQgZW5kcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ubmVjdGl2aXR5XHJcbiAgICAgICAgICogc3RhdGUgY2hhbmdlcy4gV2lsbCBiZSBtb2RpZmllZCBieSBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmAgYW5kXHJcbiAgICAgICAgICogYHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFja3MgY2hhbm5lbHMgYW5kIHN1YmNoYW5uZWwgcG9vbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVmY291bnQgPSAwO1xyXG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cclxuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogb3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXHJcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XHJcbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSAoX2EgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xyXG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2VTdHViKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyU3R1YigpO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyU3R1YigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyU3R1YigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XHJcbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1N1YmNoYW5uZWwgY3JlYXRlZCcpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ1N1YmNoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xyXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcclxuICAgICAgICB0aGlzLnNlY3VyZUNvbm5lY3RvciA9IGNyZWRlbnRpYWxzLl9jcmVhdGVTZWN1cmVDb25uZWN0b3IoY2hhbm5lbFRhcmdldCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXRDaGFubmVsekluZm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXHJcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXHJcbiAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgIHRleHQpO1xyXG4gICAgfVxyXG4gICAgcmVmVHJhY2UodGV4dCkge1xyXG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnc3ViY2hhbm5lbF9yZWZjb3VudCcsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgIHRleHQpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQmFja29mZlRpbWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRpbnVlQ29ubmVjdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGEgYmFja29mZiB0aW1lciB3aXRoIHRoZSBjdXJyZW50IG5leHRCYWNrb2ZmIHRpbWVvdXRcclxuICAgICAqL1xyXG4gICAgc3RhcnRCYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xyXG4gICAgfVxyXG4gICAgc3RvcEJhY2tvZmYoKSB7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkge1xyXG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZEtlZXBhbGl2ZVRpbWUgPSBNYXRoLm1pbih0aGlzLmtlZXBhbGl2ZVRpbWUsIEtFRVBBTElWRV9NQVhfVElNRV9NUyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7ICdncnBjLmtlZXBhbGl2ZV90aW1lX21zJzogYWRqdXN0ZWRLZWVwYWxpdmVUaW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RvclxyXG4gICAgICAgICAgICAuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLnNlY3VyZUNvbm5lY3Rvciwgb3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4odHJhbnNwb3J0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQodHJhbnNwb3J0LmdldENoYW5uZWx6UmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0b29NYW55UGluZ3MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb01hbnlQaW5ncyAmJiB0aGlzLmtlZXBhbGl2ZVRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBDb25uZWN0aW9uIHRvICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy5jaGFubmVsVGFyZ2V0KX0gYXQgJHt0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nfSByZWplY3RlZCBieSBzZXJ2ZXIgYmVjYXVzZSBvZiBleGNlc3MgcGluZ3MuIEluY3JlYXNpbmcgcGluZyBpbnRlcnZhbCB0byAke3RoaXMua2VlcGFsaXZlVGltZX0gbXNgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qIElmIHdlIGNhbid0IHRyYW5zaXRpb24gZnJvbSBDT05ORUNUSU5HIHRvIFJFQURZIGhlcmUsIHdlIHdpbGxcclxuICAgICAgICAgICAgICAgICAqIG5vdCBiZSB1c2luZyB0aGlzIHRyYW5zcG9ydCwgc28gcmVsZWFzZSBpdHMgcmVzb3VyY2VzLiAqL1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgYCR7ZXJyb3J9YCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XHJcbiAgICAgKiBzdGF0ZS4gSWYgdGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5U3RhdGUgaXMgbm90IGluIG9sZFN0YXRlcywgZG8gbm90aGluZy5cclxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZXMgVGhlIHNldCBvZiBzdGF0ZXMgdG8gdHJhbnNpdGlvbiBmcm9tXHJcbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0YXRlIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xyXG4gICAgICAgICAgICAgICAgJyAtPiAnICtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSArXHJcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgXCInICsgZXJyb3JNZXNzYWdlICsgJ1wiJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcclxuICAgICAgICAgICAgICAgICcgLT4gJyArXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBzdGF0ZSwgd2Ugd2FudCB0byBpbW1lZGlhdGVseSB0cmFuc2l0aW9uIG91dCBvZlxyXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogdW5rbm93biBDb25uZWN0aXZpdHlTdGF0ZSAke25ld1N0YXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIHRoaXMua2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZWYoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgncmVmY291bnQgJyArIHRoaXMucmVmY291bnQgKyAnIC0+ICcgKyAodGhpcy5yZWZjb3VudCArIDEpKTtcclxuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XHJcbiAgICB9XHJcbiAgICB1bnJlZigpIHtcclxuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50IC0gMSkpO1xyXG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU2h1dHRpbmcgZG93bicpO1xyXG4gICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyZUNvbm5lY3Rvci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdW5yZWZJZk9uZVJlZigpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnVucmVmKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgY2FsbCwgc3ViY2hhbm5lbCBub3QgUkVBRFknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXRzVHJhY2tlcjtcclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcclxuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge1xyXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRzVHJhY2tlciA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3RhdHNUcmFja2VyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudGx5IElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYW5kIHN3aXRjaCB0byB0aGVcclxuICAgICAqIENPTk5FQ1RJTkcgc3RhdGUuIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnQgaW4gVFJBTlNJRU5UX0ZBSUxVUkUsXHJcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxyXG4gICAgICogT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgIC8qIEZpcnN0LCB0cnkgdG8gdHJhbnNpdGlvbiBmcm9tIElETEUgdG8gY29ubmVjdGluZy4gSWYgdGhhdCBkb2Vzbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXHJcbiAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xyXG4gICAgICAgICAgICAgKiBjb25uZWN0aW5nIGFmdGVyIHRoZSBiYWNrb2ZmIHRpbWVyIGVuZHMuIE90aGVyd2lzZSBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YmNoYW5uZWwnc1xyXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEEgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cclxuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cclxuICAgICAqL1xyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XHJcbiAgICB9XHJcbiAgICBpc0hlYWx0aHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBhZGRIZWFsdGhTdGF0ZVdhdGNoZXIobGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggdGhlIGxpc3RlbmVyXHJcbiAgICB9XHJcbiAgICByZW1vdmVIZWFsdGhTdGF0ZVdhdGNoZXIobGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggdGhlIGxpc3RlbmVyXHJcbiAgICB9XHJcbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IHRoaXM7XHJcbiAgICB9XHJcbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XHJcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDYWxsQ3JlZGVudGlhbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VjdXJlQ29ubmVjdG9yLmdldENhbGxDcmVkZW50aWFscygpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3ViY2hhbm5lbCA9IFN1YmNoYW5uZWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CIPHER_SUITES = void 0;\r\nexports.getDefaultRootsData = getDefaultRootsData;\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\r\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\r\nlet defaultRootsData = null;\r\nfunction getDefaultRootsData() {\r\n    if (DEFAULT_ROOTS_FILE_PATH) {\r\n        if (defaultRootsData === null) {\r\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\r\n        }\r\n        return defaultRootsData;\r\n    }\r\n    return null;\r\n}\r\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanM/YWJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gdm9pZCAwO1xyXG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBnZXREZWZhdWx0Um9vdHNEYXRhO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gcHJvY2Vzcy5lbnYuR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUztcclxuY29uc3QgREVGQVVMVF9ST09UU19GSUxFX1BBVEggPSBwcm9jZXNzLmVudi5HUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSDtcclxubGV0IGRlZmF1bHRSb290c0RhdGEgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0Um9vdHNEYXRhKCkge1xyXG4gICAgaWYgKERFRkFVTFRfUk9PVFNfRklMRV9QQVRIKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRSb290c0RhdGEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVmYXVsdFJvb3RzRGF0YSA9IGZzLnJlYWRGaWxlU3luYyhERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0Um9vdHNEYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGxzLWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2023 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Http2SubchannelConnector = void 0;\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\r\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\r\nconst TRACER_NAME = 'transport';\r\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\r\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\r\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\r\nconst KEEPALIVE_TIMEOUT_MS = 20000;\r\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\r\nclass Http2Transport {\r\n    constructor(session, subchannelAddress, options, \r\n    /**\r\n     * Name of the remote server, if it is not the same as the subchannel\r\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\r\n     */\r\n    remoteName) {\r\n        this.session = session;\r\n        this.options = options;\r\n        this.remoteName = remoteName;\r\n        /**\r\n         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.\r\n         */\r\n        this.keepaliveTimer = null;\r\n        /**\r\n         * Indicates that the keepalive timer ran out while there were no active\r\n         * calls, and a ping should be sent the next time a call starts.\r\n         */\r\n        this.pendingSendKeepalivePing = false;\r\n        this.activeCalls = new Set();\r\n        this.disconnectListeners = [];\r\n        this.disconnectHandled = false;\r\n        this.channelzEnabled = true;\r\n        this.keepalivesSent = 0;\r\n        this.messagesSent = 0;\r\n        this.messagesReceived = 0;\r\n        this.lastMessageSentTimestamp = null;\r\n        this.lastMessageReceivedTimestamp = null;\r\n        /* Populate subchannelAddressString and channelzRef before doing anything\r\n         * else, because they are used in the trace methods. */\r\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\r\n        if (options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();\r\n        }\r\n        else {\r\n            this.streamTracker = new channelz_1.ChannelzCallTracker();\r\n        }\r\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\r\n        // Build user-agent string.\r\n        this.userAgent = [\r\n            options['grpc.primary_user_agent'],\r\n            `grpc-node-js/${clientVersion}`,\r\n            options['grpc.secondary_user_agent'],\r\n        ]\r\n            .filter(e => e)\r\n            .join(' '); // remove falsey values first\r\n        if ('grpc.keepalive_time_ms' in options) {\r\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\r\n        }\r\n        else {\r\n            this.keepaliveTimeMs = -1;\r\n        }\r\n        if ('grpc.keepalive_timeout_ms' in options) {\r\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\r\n        }\r\n        else {\r\n            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\r\n        }\r\n        if ('grpc.keepalive_permit_without_calls' in options) {\r\n            this.keepaliveWithoutCalls =\r\n                options['grpc.keepalive_permit_without_calls'] === 1;\r\n        }\r\n        else {\r\n            this.keepaliveWithoutCalls = false;\r\n        }\r\n        session.once('close', () => {\r\n            this.trace('session closed');\r\n            this.handleDisconnect();\r\n        });\r\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\r\n            let tooManyPings = false;\r\n            /* See the last paragraph of\r\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\r\n            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\r\n                opaqueData &&\r\n                opaqueData.equals(tooManyPingsData)) {\r\n                tooManyPings = true;\r\n            }\r\n            this.trace('connection closed by GOAWAY with code ' +\r\n                errorCode +\r\n                ' and data ' +\r\n                (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\r\n            this.reportDisconnectToOwner(tooManyPings);\r\n        });\r\n        session.once('error', error => {\r\n            this.trace('connection closed with error ' + error.message);\r\n            this.handleDisconnect();\r\n        });\r\n        session.socket.once('close', (hadError) => {\r\n            this.trace('connection closed. hadError=' + hadError);\r\n            this.handleDisconnect();\r\n        });\r\n        if (logging.isTracerEnabled(TRACER_NAME)) {\r\n            session.on('remoteSettings', (settings) => {\r\n                this.trace('new settings received' +\r\n                    (this.session !== session ? ' on the old connection' : '') +\r\n                    ': ' +\r\n                    JSON.stringify(settings));\r\n            });\r\n            session.on('localSettings', (settings) => {\r\n                this.trace('local settings acknowledged by remote' +\r\n                    (this.session !== session ? ' on the old connection' : '') +\r\n                    ': ' +\r\n                    JSON.stringify(settings));\r\n            });\r\n        }\r\n        /* Start the keepalive timer last, because this can trigger trace logs,\r\n         * which should only happen after everything else is set up. */\r\n        if (this.keepaliveWithoutCalls) {\r\n            this.maybeStartKeepalivePingTimer();\r\n        }\r\n    }\r\n    getChannelzInfo() {\r\n        var _a, _b, _c;\r\n        const sessionSocket = this.session.socket;\r\n        const remoteAddress = sessionSocket.remoteAddress\r\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\r\n            : null;\r\n        const localAddress = sessionSocket.localAddress\r\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\r\n            : null;\r\n        let tlsInfo;\r\n        if (this.session.encrypted) {\r\n            const tlsSocket = sessionSocket;\r\n            const cipherInfo = tlsSocket.getCipher();\r\n            const certificate = tlsSocket.getCertificate();\r\n            const peerCertificate = tlsSocket.getPeerCertificate();\r\n            tlsInfo = {\r\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\r\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\r\n                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\r\n                remoteCertificate: peerCertificate && 'raw' in peerCertificate\r\n                    ? peerCertificate.raw\r\n                    : null,\r\n            };\r\n        }\r\n        else {\r\n            tlsInfo = null;\r\n        }\r\n        const socketInfo = {\r\n            remoteAddress: remoteAddress,\r\n            localAddress: localAddress,\r\n            security: tlsInfo,\r\n            remoteName: this.remoteName,\r\n            streamsStarted: this.streamTracker.callsStarted,\r\n            streamsSucceeded: this.streamTracker.callsSucceeded,\r\n            streamsFailed: this.streamTracker.callsFailed,\r\n            messagesSent: this.messagesSent,\r\n            messagesReceived: this.messagesReceived,\r\n            keepAlivesSent: this.keepalivesSent,\r\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\r\n            lastRemoteStreamCreatedTimestamp: null,\r\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\r\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\r\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\r\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,\r\n        };\r\n        return socketInfo;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    keepaliveTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    flowControlTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    internalsTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    /**\r\n     * Indicate to the owner of this object that this transport should no longer\r\n     * be used. That happens if the connection drops, or if the server sends a\r\n     * GOAWAY.\r\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\r\n     * indicating that the session was closed becaues the client sent too many\r\n     * pings.\r\n     * @returns\r\n     */\r\n    reportDisconnectToOwner(tooManyPings) {\r\n        if (this.disconnectHandled) {\r\n            return;\r\n        }\r\n        this.disconnectHandled = true;\r\n        this.disconnectListeners.forEach(listener => listener(tooManyPings));\r\n    }\r\n    /**\r\n     * Handle connection drops, but not GOAWAYs.\r\n     */\r\n    handleDisconnect() {\r\n        this.clearKeepaliveTimeout();\r\n        this.reportDisconnectToOwner(false);\r\n        for (const call of this.activeCalls) {\r\n            call.onDisconnect();\r\n        }\r\n        // Wait an event loop cycle before destroying the connection\r\n        setImmediate(() => {\r\n            this.session.destroy();\r\n        });\r\n    }\r\n    addDisconnectListener(listener) {\r\n        this.disconnectListeners.push(listener);\r\n    }\r\n    canSendPing() {\r\n        return (!this.session.destroyed &&\r\n            this.keepaliveTimeMs > 0 &&\r\n            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));\r\n    }\r\n    maybeSendPing() {\r\n        var _a, _b;\r\n        if (!this.canSendPing()) {\r\n            this.pendingSendKeepalivePing = true;\r\n            return;\r\n        }\r\n        if (this.keepaliveTimer) {\r\n            console.error('keepaliveTimeout is not null');\r\n            return;\r\n        }\r\n        if (this.channelzEnabled) {\r\n            this.keepalivesSent += 1;\r\n        }\r\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\r\n        this.keepaliveTimer = setTimeout(() => {\r\n            this.keepaliveTimer = null;\r\n            this.keepaliveTrace('Ping timeout passed without response');\r\n            this.handleDisconnect();\r\n        }, this.keepaliveTimeoutMs);\r\n        (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        let pingSendError = '';\r\n        try {\r\n            const pingSentSuccessfully = this.session.ping((err, duration, payload) => {\r\n                this.clearKeepaliveTimeout();\r\n                if (err) {\r\n                    this.keepaliveTrace('Ping failed with error ' + err.message);\r\n                    this.handleDisconnect();\r\n                }\r\n                else {\r\n                    this.keepaliveTrace('Received ping response');\r\n                    this.maybeStartKeepalivePingTimer();\r\n                }\r\n            });\r\n            if (!pingSentSuccessfully) {\r\n                pingSendError = 'Ping returned false';\r\n            }\r\n        }\r\n        catch (e) {\r\n            // grpc/grpc-node#2139\r\n            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';\r\n        }\r\n        if (pingSendError) {\r\n            this.keepaliveTrace('Ping send failed: ' + pingSendError);\r\n            this.handleDisconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\r\n     * out while there were no active requests, instead send a ping immediately.\r\n     * If the ping timer is already running or a ping is currently in flight,\r\n     * instead do nothing and wait for them to resolve.\r\n     */\r\n    maybeStartKeepalivePingTimer() {\r\n        var _a, _b;\r\n        if (!this.canSendPing()) {\r\n            return;\r\n        }\r\n        if (this.pendingSendKeepalivePing) {\r\n            this.pendingSendKeepalivePing = false;\r\n            this.maybeSendPing();\r\n        }\r\n        else if (!this.keepaliveTimer) {\r\n            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\r\n            this.keepaliveTimer = setTimeout(() => {\r\n                this.keepaliveTimer = null;\r\n                this.maybeSendPing();\r\n            }, this.keepaliveTimeMs);\r\n            (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        /* Otherwise, there is already either a keepalive timer or a ping pending,\r\n         * wait for those to resolve. */\r\n    }\r\n    /**\r\n     * Clears whichever keepalive timeout is currently active, if any.\r\n     */\r\n    clearKeepaliveTimeout() {\r\n        if (this.keepaliveTimer) {\r\n            clearTimeout(this.keepaliveTimer);\r\n            this.keepaliveTimer = null;\r\n        }\r\n    }\r\n    removeActiveCall(call) {\r\n        this.activeCalls.delete(call);\r\n        if (this.activeCalls.size === 0) {\r\n            this.session.unref();\r\n        }\r\n    }\r\n    addActiveCall(call) {\r\n        this.activeCalls.add(call);\r\n        if (this.activeCalls.size === 1) {\r\n            this.session.ref();\r\n            if (!this.keepaliveWithoutCalls) {\r\n                this.maybeStartKeepalivePingTimer();\r\n            }\r\n        }\r\n    }\r\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\r\n        const headers = metadata.toHttp2Headers();\r\n        headers[HTTP2_HEADER_AUTHORITY] = host;\r\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\r\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\r\n        headers[HTTP2_HEADER_METHOD] = 'POST';\r\n        headers[HTTP2_HEADER_PATH] = method;\r\n        headers[HTTP2_HEADER_TE] = 'trailers';\r\n        let http2Stream;\r\n        /* In theory, if an error is thrown by session.request because session has\r\n         * become unusable (e.g. because it has received a goaway), this subchannel\r\n         * should soon see the corresponding close or goaway event anyway and leave\r\n         * READY. But we have seen reports that this does not happen\r\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\r\n         * so for defense in depth, we just discard the session when we see an\r\n         * error here.\r\n         */\r\n        try {\r\n            http2Stream = this.session.request(headers);\r\n        }\r\n        catch (e) {\r\n            this.handleDisconnect();\r\n            throw e;\r\n        }\r\n        this.flowControlTrace('local window size: ' +\r\n            this.session.state.localWindowSize +\r\n            ' remote window size: ' +\r\n            this.session.state.remoteWindowSize);\r\n        this.internalsTrace('session.closed=' +\r\n            this.session.closed +\r\n            ' session.destroyed=' +\r\n            this.session.destroyed +\r\n            ' session.socket.destroyed=' +\r\n            this.session.socket.destroyed);\r\n        let eventTracker;\r\n        // eslint-disable-next-line prefer-const\r\n        let call;\r\n        if (this.channelzEnabled) {\r\n            this.streamTracker.addCallStarted();\r\n            eventTracker = {\r\n                addMessageSent: () => {\r\n                    var _a;\r\n                    this.messagesSent += 1;\r\n                    this.lastMessageSentTimestamp = new Date();\r\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                addMessageReceived: () => {\r\n                    var _a;\r\n                    this.messagesReceived += 1;\r\n                    this.lastMessageReceivedTimestamp = new Date();\r\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                onCallEnd: status => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\r\n                    this.removeActiveCall(call);\r\n                },\r\n                onStreamEnd: success => {\r\n                    var _a;\r\n                    if (success) {\r\n                        this.streamTracker.addCallSucceeded();\r\n                    }\r\n                    else {\r\n                        this.streamTracker.addCallFailed();\r\n                    }\r\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            eventTracker = {\r\n                addMessageSent: () => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                addMessageReceived: () => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                onCallEnd: status => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\r\n                    this.removeActiveCall(call);\r\n                },\r\n                onStreamEnd: success => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\r\n                },\r\n            };\r\n        }\r\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\r\n        this.addActiveCall(call);\r\n        return call;\r\n    }\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    getPeerName() {\r\n        return this.subchannelAddressString;\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n    shutdown() {\r\n        this.session.close();\r\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n    }\r\n}\r\nclass Http2SubchannelConnector {\r\n    constructor(channelTarget) {\r\n        this.channelTarget = channelTarget;\r\n        this.session = null;\r\n        this.isShutdown = false;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\r\n    }\r\n    createSession(secureConnectResult, address, options) {\r\n        if (this.isShutdown) {\r\n            return Promise.reject();\r\n        }\r\n        if (secureConnectResult.socket.closed) {\r\n            return Promise.reject('Connection closed before starting HTTP/2 handshake');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let remoteName = null;\r\n            let realTarget = this.channelTarget;\r\n            if ('grpc.http_connect_target' in options) {\r\n                const parsedTarget = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target']);\r\n                if (parsedTarget) {\r\n                    realTarget = parsedTarget;\r\n                    remoteName = (0, uri_parser_1.uriToString)(parsedTarget);\r\n                }\r\n            }\r\n            const scheme = secureConnectResult.secure ? 'https' : 'http';\r\n            const targetPath = (0, resolver_1.getDefaultAuthority)(realTarget);\r\n            const closeHandler = () => {\r\n                var _a;\r\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\r\n                this.session = null;\r\n                // Leave time for error event to happen before rejecting\r\n                setImmediate(() => {\r\n                    if (!reportedError) {\r\n                        reportedError = true;\r\n                        reject(`${errorMessage.trim()} (${new Date().toISOString()})`);\r\n                    }\r\n                });\r\n            };\r\n            const errorHandler = (error) => {\r\n                var _a;\r\n                (_a = this.session) === null || _a === void 0 ? void 0 : _a.destroy();\r\n                errorMessage = error.message;\r\n                this.trace('connection failed with error ' + errorMessage);\r\n                if (!reportedError) {\r\n                    reportedError = true;\r\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\r\n                }\r\n            };\r\n            const sessionOptions = {\r\n                createConnection: (authority, option) => {\r\n                    return secureConnectResult.socket;\r\n                }\r\n            };\r\n            if (options['grpc-node.flow_control_window'] !== undefined) {\r\n                sessionOptions.settings = {\r\n                    initialWindowSize: options['grpc-node.flow_control_window']\r\n                };\r\n            }\r\n            const session = http2.connect(`${scheme}://${targetPath}`, sessionOptions);\r\n            this.session = session;\r\n            let errorMessage = 'Failed to connect';\r\n            let reportedError = false;\r\n            session.unref();\r\n            session.once('remoteSettings', () => {\r\n                session.removeAllListeners();\r\n                secureConnectResult.socket.removeListener('close', closeHandler);\r\n                secureConnectResult.socket.removeListener('error', errorHandler);\r\n                resolve(new Http2Transport(session, address, options, remoteName));\r\n                this.session = null;\r\n            });\r\n            session.once('close', closeHandler);\r\n            session.once('error', errorHandler);\r\n            secureConnectResult.socket.once('close', closeHandler);\r\n            secureConnectResult.socket.once('error', errorHandler);\r\n        });\r\n    }\r\n    tcpConnect(address, options) {\r\n        return (0, http_proxy_1.getProxiedConnection)(address, options).then(proxiedSocket => {\r\n            if (proxiedSocket) {\r\n                return proxiedSocket;\r\n            }\r\n            else {\r\n                return new Promise((resolve, reject) => {\r\n                    const closeCallback = () => {\r\n                        reject(new Error('Socket closed'));\r\n                    };\r\n                    const errorCallback = (error) => {\r\n                        reject(error);\r\n                    };\r\n                    const socket = net.connect(address, () => {\r\n                        socket.removeListener('close', closeCallback);\r\n                        socket.removeListener('error', errorCallback);\r\n                        resolve(socket);\r\n                    });\r\n                    socket.once('close', closeCallback);\r\n                    socket.once('error', errorCallback);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    async connect(address, secureConnector, options) {\r\n        if (this.isShutdown) {\r\n            return Promise.reject();\r\n        }\r\n        let tcpConnection = null;\r\n        let secureConnectResult = null;\r\n        const addressString = (0, subchannel_address_1.subchannelAddressToString)(address);\r\n        try {\r\n            this.trace(addressString + ' Waiting for secureConnector to be ready');\r\n            await secureConnector.waitForReady();\r\n            this.trace(addressString + ' secureConnector is ready');\r\n            tcpConnection = await this.tcpConnect(address, options);\r\n            tcpConnection.setNoDelay();\r\n            this.trace(addressString + ' Established TCP connection');\r\n            secureConnectResult = await secureConnector.connect(tcpConnection);\r\n            this.trace(addressString + ' Established secure connection');\r\n            return this.createSession(secureConnectResult, address, options);\r\n        }\r\n        catch (e) {\r\n            tcpConnection === null || tcpConnection === void 0 ? void 0 : tcpConnection.destroy();\r\n            secureConnectResult === null || secureConnectResult === void 0 ? void 0 : secureConnectResult.socket.destroy();\r\n            throw e;\r\n        }\r\n    }\r\n    shutdown() {\r\n        var _a;\r\n        this.isShutdown = true;\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\r\n        this.session = null;\r\n    }\r\n}\r\nexports.Http2SubchannelConnector = Http2SubchannelConnector;\r\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxrRkFBZTtBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLDBHQUFxQztBQUMzRCxRQUFRLHVJQUF1STtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUIsR0FBRyx5QkFBeUI7QUFDbkY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjLEdBQUcseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLEtBQUssV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3RyYW5zcG9ydC5qcz9lOWZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMyBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IHZvaWQgMDtcclxuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XHJcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGh0dHBfcHJveHlfMSA9IHJlcXVpcmUoXCIuL2h0dHBfcHJveHlcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtY2FsbFwiKTtcclxuY29uc3QgY2FsbF9udW1iZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtbnVtYmVyXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICd0cmFuc3BvcnQnO1xyXG5jb25zdCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0X2Zsb3djdHJsJztcclxuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XHJcbmNvbnN0IHsgSFRUUDJfSEVBREVSX0FVVEhPUklUWSwgSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSwgSFRUUDJfSEVBREVSX01FVEhPRCwgSFRUUDJfSEVBREVSX1BBVEgsIEhUVFAyX0hFQURFUl9URSwgSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQsIH0gPSBodHRwMi5jb25zdGFudHM7XHJcbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX01TID0gMjAwMDA7XHJcbmNvbnN0IHRvb01hbnlQaW5nc0RhdGEgPSBCdWZmZXIuZnJvbSgndG9vX21hbnlfcGluZ3MnLCAnYXNjaWknKTtcclxuY2xhc3MgSHR0cDJUcmFuc3BvcnQge1xyXG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lIG9mIHRoZSByZW1vdGUgc2VydmVyLCBpZiBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHN1YmNoYW5uZWxcclxuICAgICAqIGFkZHJlc3MsIGkuZS4gaWYgY29ubmVjdGluZyB0aHJvdWdoIGFuIEhUVFAgQ09OTkVDVCBwcm94eS5cclxuICAgICAqL1xyXG4gICAgcmVtb3RlTmFtZSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSByZW1vdGVOYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRpbWVyIHJlZmVyZW5jZSBpbmRpY2F0aW5nIHdoZW4gdG8gc2VuZCB0aGUgbmV4dCBwaW5nIG9yIHdoZW4gdGhlIG1vc3QgcmVjZW50IHBpbmcgd2lsbCBiZSBjb25zaWRlcmVkIGxvc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGtlZXBhbGl2ZSB0aW1lciByYW4gb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlXHJcbiAgICAgICAgICogY2FsbHMsIGFuZCBhIHBpbmcgc2hvdWxkIGJlIHNlbnQgdGhlIG5leHQgdGltZSBhIGNhbGwgc3RhcnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xyXG4gICAgICAgIC8qIFBvcHVsYXRlIHN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nIGFuZCBjaGFubmVselJlZiBiZWZvcmUgZG9pbmcgYW55dGhpbmdcclxuICAgICAgICAgKiBlbHNlLCBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgaW4gdGhlIHRyYWNlIG1ldGhvZHMuICovXHJcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlclN0dWIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQpKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcclxuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cclxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IFtcclxuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnXSxcclxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcclxuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5zZWNvbmRhcnlfdXNlcl9hZ2VudCddLFxyXG4gICAgICAgIF1cclxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUpXHJcbiAgICAgICAgICAgIC5qb2luKCcgJyk7IC8vIHJlbW92ZSBmYWxzZXkgdmFsdWVzIGZpcnN0XHJcbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lX21zJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dE1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBLRUVQQUxJVkVfVElNRU9VVF9NUztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscycgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyddID09PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnc2Vzc2lvbiBjbG9zZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRvb01hbnlQaW5ncyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXHJcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cclxuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0gJiZcclxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEgJiZcclxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0b29NYW55UGluZ3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArXHJcbiAgICAgICAgICAgICAgICBlcnJvckNvZGUgK1xyXG4gICAgICAgICAgICAgICAgJyBhbmQgZGF0YSAnICtcclxuICAgICAgICAgICAgICAgIChvcGFxdWVEYXRhID09PSBudWxsIHx8IG9wYXF1ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wYXF1ZURhdGEudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydERpc2Nvbm5lY3RUb093bmVyKHRvb01hbnlQaW5ncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvciAnICsgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlc3Npb24uc29ja2V0Lm9uY2UoJ2Nsb3NlJywgKGhhZEVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkLiBoYWRFcnJvcj0nICsgaGFkRXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XHJcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ3JlbW90ZVNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCduZXcgc2V0dGluZ3MgcmVjZWl2ZWQnICtcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2Vzc2lvbi5vbignbG9jYWxTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbG9jYWwgc2V0dGluZ3MgYWNrbm93bGVkZ2VkIGJ5IHJlbW90ZScgK1xyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBTdGFydCB0aGUga2VlcGFsaXZlIHRpbWVyIGxhc3QsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlciB0cmFjZSBsb2dzLFxyXG4gICAgICAgICAqIHdoaWNoIHNob3VsZCBvbmx5IGhhcHBlbiBhZnRlciBldmVyeXRoaW5nIGVsc2UgaXMgc2V0IHVwLiAqL1xyXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGFubmVsekluZm8oKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzc1xyXG4gICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MsIHNlc3Npb25Tb2NrZXQucmVtb3RlUG9ydClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzXHJcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzLCBzZXNzaW9uU29ja2V0LmxvY2FsUG9ydClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGxldCB0bHNJbmZvO1xyXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZW5jcnlwdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHNlc3Npb25Tb2NrZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlckluZm8gPSB0bHNTb2NrZXQuZ2V0Q2lwaGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKTtcclxuICAgICAgICAgICAgdGxzSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlT3RoZXJOYW1lOiBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSA/IG51bGwgOiBjaXBoZXJJbmZvLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBsb2NhbENlcnRpZmljYXRlOiBjZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBjZXJ0aWZpY2F0ZSA/IGNlcnRpZmljYXRlLnJhdyA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZW1vdGVDZXJ0aWZpY2F0ZTogcGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xyXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzb2NrZXRJbmZvID0ge1xyXG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxyXG4gICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcclxuICAgICAgICAgICAgc2VjdXJpdHk6IHRsc0luZm8sXHJcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlTmFtZSxcclxuICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXHJcbiAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcclxuICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxyXG4gICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxyXG4gICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQsXHJcbiAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiB0aGlzLmtlZXBhbGl2ZXNTZW50LFxyXG4gICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiB0aGlzLnN0cmVhbVRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wLFxyXG4gICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxyXG4gICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiAoX2IgPSB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxyXG4gICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gc29ja2V0SW5mbztcclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgIHRleHQpO1xyXG4gICAgfVxyXG4gICAga2VlcGFsaXZlVHJhY2UodGV4dCkge1xyXG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXHJcbiAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBmbG93Q29udHJvbFRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FLCAnKCcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcclxuICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB0ZXh0KTtcclxuICAgIH1cclxuICAgIGludGVybmFsc1RyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3RyYW5zcG9ydF9pbnRlcm5hbHMnLCAnKCcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcclxuICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB0ZXh0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGUgdG8gdGhlIG93bmVyIG9mIHRoaXMgb2JqZWN0IHRoYXQgdGhpcyB0cmFuc3BvcnQgc2hvdWxkIG5vIGxvbmdlclxyXG4gICAgICogYmUgdXNlZC4gVGhhdCBoYXBwZW5zIGlmIHRoZSBjb25uZWN0aW9uIGRyb3BzLCBvciBpZiB0aGUgc2VydmVyIHNlbmRzIGFcclxuICAgICAqIEdPQVdBWS5cclxuICAgICAqIEBwYXJhbSB0b29NYW55UGluZ3MgSWYgdHJ1ZSwgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGEgR09BV0FZIHdpdGggZGF0YVxyXG4gICAgICogaW5kaWNhdGluZyB0aGF0IHRoZSBzZXNzaW9uIHdhcyBjbG9zZWQgYmVjYXVlcyB0aGUgY2xpZW50IHNlbnQgdG9vIG1hbnlcclxuICAgICAqIHBpbmdzLlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgcmVwb3J0RGlzY29ubmVjdFRvT3duZXIodG9vTWFueVBpbmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdEhhbmRsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcih0b29NYW55UGluZ3MpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGNvbm5lY3Rpb24gZHJvcHMsIGJ1dCBub3QgR09BV0FZcy5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xyXG4gICAgICAgIHRoaXMucmVwb3J0RGlzY29ubmVjdFRvT3duZXIoZmFsc2UpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmFjdGl2ZUNhbGxzKSB7XHJcbiAgICAgICAgICAgIGNhbGwub25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhaXQgYW4gZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgZGVzdHJveWluZyB0aGUgY29ubmVjdGlvblxyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGREaXNjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBjYW5TZW5kUGluZygpIHtcclxuICAgICAgICByZXR1cm4gKCF0aGlzLnNlc3Npb24uZGVzdHJveWVkICYmXHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID4gMCAmJlxyXG4gICAgICAgICAgICAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgfHwgdGhpcy5hY3RpdmVDYWxscy5zaXplID4gMCkpO1xyXG4gICAgfVxyXG4gICAgbWF5YmVTZW5kUGluZygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVUaW1lcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdrZWVwYWxpdmVUaW1lb3V0IGlzIG5vdCBudWxsJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU2VuZGluZyBwaW5nIHdpdGggdGltZW91dCAnICsgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgKyAnbXMnKTtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMpO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgICAgbGV0IHBpbmdTZW5kRXJyb3IgPSAnJztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwaW5nU2VudFN1Y2Nlc3NmdWxseSA9IHRoaXMuc2Vzc2lvbi5waW5nKChlcnIsIGR1cmF0aW9uLCBwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgZmFpbGVkIHdpdGggZXJyb3IgJyArIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1JlY2VpdmVkIHBpbmcgcmVzcG9uc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghcGluZ1NlbnRTdWNjZXNzZnVsbHkpIHtcclxuICAgICAgICAgICAgICAgIHBpbmdTZW5kRXJyb3IgPSAnUGluZyByZXR1cm5lZCBmYWxzZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gZ3JwYy9ncnBjLW5vZGUjMjEzOVxyXG4gICAgICAgICAgICBwaW5nU2VuZEVycm9yID0gKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICcnKSB8fCAnVW5rbm93biBlcnJvcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaW5nU2VuZEVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1Bpbmcgc2VuZCBmYWlsZWQ6ICcgKyBwaW5nU2VuZEVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGtlZXBhbGl2ZSBwaW5nIHRpbWVyIGlmIGFwcHJvcHJpYXRlLiBJZiB0aGUgdGltZXIgYWxyZWFkeSByYW5cclxuICAgICAqIG91dCB3aGlsZSB0aGVyZSB3ZXJlIG5vIGFjdGl2ZSByZXF1ZXN0cywgaW5zdGVhZCBzZW5kIGEgcGluZyBpbW1lZGlhdGVseS5cclxuICAgICAqIElmIHRoZSBwaW5nIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBvciBhIHBpbmcgaXMgY3VycmVudGx5IGluIGZsaWdodCxcclxuICAgICAqIGluc3RlYWQgZG8gbm90aGluZyBhbmQgd2FpdCBmb3IgdGhlbSB0byByZXNvbHZlLlxyXG4gICAgICovXHJcbiAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhblNlbmRQaW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1N0YXJ0aW5nIGtlZXBhbGl2ZSB0aW1lciBmb3IgJyArIHRoaXMua2VlcGFsaXZlVGltZU1zICsgJ21zJyk7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZU1zKTtcclxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5rZWVwYWxpdmVUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogT3RoZXJ3aXNlLCB0aGVyZSBpcyBhbHJlYWR5IGVpdGhlciBhIGtlZXBhbGl2ZSB0aW1lciBvciBhIHBpbmcgcGVuZGluZyxcclxuICAgICAgICAgKiB3YWl0IGZvciB0aG9zZSB0byByZXNvbHZlLiAqL1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgd2hpY2hldmVyIGtlZXBhbGl2ZSB0aW1lb3V0IGlzIGN1cnJlbnRseSBhY3RpdmUsIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlQWN0aXZlQ2FsbChjYWxsKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscy5kZWxldGUoY2FsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udW5yZWYoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRBY3RpdmVDYWxsKGNhbGwpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmFkZChjYWxsKTtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDYWxscy5zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZWYoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyLCBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcikge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtZXRhZGF0YS50b0h0dHAySGVhZGVycygpO1xyXG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0O1xyXG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1VTRVJfQUdFTlRdID0gdGhpcy51c2VyQWdlbnQ7XHJcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXSA9ICdhcHBsaWNhdGlvbi9ncnBjJztcclxuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xyXG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1BBVEhdID0gbWV0aG9kO1xyXG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1RFXSA9ICd0cmFpbGVycyc7XHJcbiAgICAgICAgbGV0IGh0dHAyU3RyZWFtO1xyXG4gICAgICAgIC8qIEluIHRoZW9yeSwgaWYgYW4gZXJyb3IgaXMgdGhyb3duIGJ5IHNlc3Npb24ucmVxdWVzdCBiZWNhdXNlIHNlc3Npb24gaGFzXHJcbiAgICAgICAgICogYmVjb21lIHVudXNhYmxlIChlLmcuIGJlY2F1c2UgaXQgaGFzIHJlY2VpdmVkIGEgZ29hd2F5KSwgdGhpcyBzdWJjaGFubmVsXHJcbiAgICAgICAgICogc2hvdWxkIHNvb24gc2VlIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlIG9yIGdvYXdheSBldmVudCBhbnl3YXkgYW5kIGxlYXZlXHJcbiAgICAgICAgICogUkVBRFkuIEJ1dCB3ZSBoYXZlIHNlZW4gcmVwb3J0cyB0aGF0IHRoaXMgZG9lcyBub3QgaGFwcGVuXHJcbiAgICAgICAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL25vZGVqcy1maXJlc3RvcmUvaXNzdWVzLzEwMjMjaXNzdWVjb21tZW50LTY1MzIwNDA5NilcclxuICAgICAgICAgKiBzbyBmb3IgZGVmZW5zZSBpbiBkZXB0aCwgd2UganVzdCBkaXNjYXJkIHRoZSBzZXNzaW9uIHdoZW4gd2Ugc2VlIGFuXHJcbiAgICAgICAgICogZXJyb3IgaGVyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBodHRwMlN0cmVhbSA9IHRoaXMuc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mbG93Q29udHJvbFRyYWNlKCdsb2NhbCB3aW5kb3cgc2l6ZTogJyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUgK1xyXG4gICAgICAgICAgICAnIHJlbW90ZSB3aW5kb3cgc2l6ZTogJyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKTtcclxuICAgICAgICB0aGlzLmludGVybmFsc1RyYWNlKCdzZXNzaW9uLmNsb3NlZD0nICtcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlZCArXHJcbiAgICAgICAgICAgICcgc2Vzc2lvbi5kZXN0cm95ZWQ9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95ZWQgK1xyXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQpO1xyXG4gICAgICAgIGxldCBldmVudFRyYWNrZXI7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxyXG4gICAgICAgIGxldCBjYWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcclxuICAgICAgICAgICAgZXZlbnRUcmFja2VyID0ge1xyXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uQ2FsbEVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kOiBzdWNjZXNzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnRUcmFja2VyID0ge1xyXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlQ2FsbChjYWxsKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsID0gbmV3IHN1YmNoYW5uZWxfY2FsbF8xLkh0dHAyU3ViY2hhbm5lbENhbGwoaHR0cDJTdHJlYW0sIGV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRoaXMsICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpKTtcclxuICAgICAgICB0aGlzLmFkZEFjdGl2ZUNhbGwoY2FsbCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGw7XHJcbiAgICB9XHJcbiAgICBnZXRDaGFubmVselJlZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcclxuICAgIH1cclxuICAgIGdldFBlZXJOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgZ2V0T3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlKCk7XHJcbiAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMuY2hhbm5lbFRhcmdldCkgKyAnICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVNlc3Npb24oc2VjdXJlQ29ubmVjdFJlc3VsdCwgYWRkcmVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2h1dGRvd24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldC5jbG9zZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDb25uZWN0aW9uIGNsb3NlZCBiZWZvcmUgc3RhcnRpbmcgSFRUUC8yIGhhbmRzaGFrZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVtb3RlTmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCByZWFsVGFyZ2V0ID0gdGhpcy5jaGFubmVsVGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWxUYXJnZXQgPSBwYXJzZWRUYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHBhcnNlZFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gc2VjdXJlQ29ubmVjdFJlc3VsdC5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkocmVhbFRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWF2ZSB0aW1lIGZvciBlcnJvciBldmVudCB0byBoYXBwZW4gYmVmb3JlIHJlamVjdGluZ1xyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcG9ydGVkRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChgJHtlcnJvck1lc3NhZ2UudHJpbSgpfSAoJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yICcgKyBlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXBvcnRlZEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGAke2Vycm9yTWVzc2FnZX0gKCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uOiAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zWydncnBjLW5vZGUuZmxvd19jb250cm9sX3dpbmRvdyddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHNlc3Npb25PcHRpb25zLnNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxXaW5kb3dTaXplOiBvcHRpb25zWydncnBjLW5vZGUuZmxvd19jb250cm9sX3dpbmRvdyddXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGAke3NjaGVtZX06Ly8ke3RhcmdldFBhdGh9YCwgc2Vzc2lvbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBjb25uZWN0JztcclxuICAgICAgICAgICAgbGV0IHJlcG9ydGVkRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2Vzc2lvbi51bnJlZigpO1xyXG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ3JlbW90ZVNldHRpbmdzJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgIHNlY3VyZUNvbm5lY3RSZXN1bHQuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsb3NlSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgSHR0cDJUcmFuc3BvcnQoc2Vzc2lvbiwgYWRkcmVzcywgb3B0aW9ucywgcmVtb3RlTmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQub25jZSgnY2xvc2UnLCBjbG9zZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICBzZWN1cmVDb25uZWN0UmVzdWx0LnNvY2tldC5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0Y3BDb25uZWN0KGFkZHJlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gKDAsIGh0dHBfcHJveHlfMS5nZXRQcm94aWVkQ29ubmVjdGlvbikoYWRkcmVzcywgb3B0aW9ucykudGhlbihwcm94aWVkU29ja2V0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHByb3hpZWRTb2NrZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm94aWVkU29ja2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUNhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdTb2NrZXQgY2xvc2VkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDYWxsYmFjayA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV0LmNvbm5lY3QoYWRkcmVzcywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xvc2VDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzb2NrZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmNlKCdjbG9zZScsIGNsb3NlQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmNlKCdlcnJvcicsIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNvbm5lY3QoYWRkcmVzcywgc2VjdXJlQ29ubmVjdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTaHV0ZG93bikge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRjcENvbm5lY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIGxldCBzZWN1cmVDb25uZWN0UmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBhZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgV2FpdGluZyBmb3Igc2VjdXJlQ29ubmVjdG9yIHRvIGJlIHJlYWR5Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNlY3VyZUNvbm5lY3Rvci53YWl0Rm9yUmVhZHkoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFjZShhZGRyZXNzU3RyaW5nICsgJyBzZWN1cmVDb25uZWN0b3IgaXMgcmVhZHknKTtcclxuICAgICAgICAgICAgdGNwQ29ubmVjdGlvbiA9IGF3YWl0IHRoaXMudGNwQ29ubmVjdChhZGRyZXNzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGNwQ29ubmVjdGlvbi5zZXROb0RlbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoYWRkcmVzc1N0cmluZyArICcgRXN0YWJsaXNoZWQgVENQIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgc2VjdXJlQ29ubmVjdFJlc3VsdCA9IGF3YWl0IHNlY3VyZUNvbm5lY3Rvci5jb25uZWN0KHRjcENvbm5lY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKGFkZHJlc3NTdHJpbmcgKyAnIEVzdGFibGlzaGVkIHNlY3VyZSBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNlc3Npb24oc2VjdXJlQ29ubmVjdFJlc3VsdCwgYWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRjcENvbm5lY3Rpb24gPT09IG51bGwgfHwgdGNwQ29ubmVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGNwQ29ubmVjdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHNlY3VyZUNvbm5lY3RSZXN1bHQgPT09IG51bGwgfHwgc2VjdXJlQ29ubmVjdFJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdXJlQ29ubmVjdFJlc3VsdC5zb2NrZXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSB0cnVlO1xyXG4gICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IEh0dHAyU3ViY2hhbm5lbENvbm5lY3RvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2020 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parseUri = parseUri;\r\nexports.splitHostPort = splitHostPort;\r\nexports.combineHostPort = combineHostPort;\r\nexports.uriToString = uriToString;\r\n/*\r\n * The groups correspond to URI parts as follows:\r\n * 1. scheme\r\n * 2. authority\r\n * 3. path\r\n */\r\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\r\nfunction parseUri(uriString) {\r\n    const parsedUri = URI_REGEX.exec(uriString);\r\n    if (parsedUri === null) {\r\n        return null;\r\n    }\r\n    return {\r\n        scheme: parsedUri[1],\r\n        authority: parsedUri[2],\r\n        path: parsedUri[3],\r\n    };\r\n}\r\nconst NUMBER_REGEX = /^\\d+$/;\r\nfunction splitHostPort(path) {\r\n    if (path.startsWith('[')) {\r\n        const hostEnd = path.indexOf(']');\r\n        if (hostEnd === -1) {\r\n            return null;\r\n        }\r\n        const host = path.substring(1, hostEnd);\r\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\r\n         * address should have at least one colon */\r\n        if (host.indexOf(':') === -1) {\r\n            return null;\r\n        }\r\n        if (path.length > hostEnd + 1) {\r\n            if (path[hostEnd + 1] === ':') {\r\n                const portString = path.substring(hostEnd + 2);\r\n                if (NUMBER_REGEX.test(portString)) {\r\n                    return {\r\n                        host: host,\r\n                        port: +portString,\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                host,\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        const splitPath = path.split(':');\r\n        /* Exactly one colon means that this is host:port. Zero colons means that\r\n         * there is no port. And multiple colons means that this is a bare IPv6\r\n         * address with no port */\r\n        if (splitPath.length === 2) {\r\n            if (NUMBER_REGEX.test(splitPath[1])) {\r\n                return {\r\n                    host: splitPath[0],\r\n                    port: +splitPath[1],\r\n                };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                host: path,\r\n            };\r\n        }\r\n    }\r\n}\r\nfunction combineHostPort(hostPort) {\r\n    if (hostPort.port === undefined) {\r\n        return hostPort.host;\r\n    }\r\n    else {\r\n        // Only an IPv6 host should include a colon\r\n        if (hostPort.host.includes(':')) {\r\n            return `[${hostPort.host}]:${hostPort.port}`;\r\n        }\r\n        else {\r\n            return `${hostPort.host}:${hostPort.port}`;\r\n        }\r\n    }\r\n}\r\nfunction uriToString(uri) {\r\n    let result = '';\r\n    if (uri.scheme !== undefined) {\r\n        result += uri.scheme + ':';\r\n    }\r\n    if (uri.authority !== undefined) {\r\n        result += '//' + uri.authority + '/';\r\n    }\r\n    result += uri.path;\r\n    return result;\r\n}\r\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxJQUFJLGNBQWM7QUFDdkQ7QUFDQTtBQUNBLHNCQUFzQixjQUFjLEdBQUcsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcz8yYWNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnBhcnNlVXJpID0gcGFyc2VVcmk7XHJcbmV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IHNwbGl0SG9zdFBvcnQ7XHJcbmV4cG9ydHMuY29tYmluZUhvc3RQb3J0ID0gY29tYmluZUhvc3RQb3J0O1xyXG5leHBvcnRzLnVyaVRvU3RyaW5nID0gdXJpVG9TdHJpbmc7XHJcbi8qXHJcbiAqIFRoZSBncm91cHMgY29ycmVzcG9uZCB0byBVUkkgcGFydHMgYXMgZm9sbG93czpcclxuICogMS4gc2NoZW1lXHJcbiAqIDIuIGF1dGhvcml0eVxyXG4gKiAzLiBwYXRoXHJcbiAqL1xyXG5jb25zdCBVUklfUkVHRVggPSAvXig/OihbQS1aYS16MC05Ky4tXSspOik/KD86XFwvXFwvKFteL10qKVxcLyk/KC4rKSQvO1xyXG5mdW5jdGlvbiBwYXJzZVVyaSh1cmlTdHJpbmcpIHtcclxuICAgIGNvbnN0IHBhcnNlZFVyaSA9IFVSSV9SRUdFWC5leGVjKHVyaVN0cmluZyk7XHJcbiAgICBpZiAocGFyc2VkVXJpID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjaGVtZTogcGFyc2VkVXJpWzFdLFxyXG4gICAgICAgIGF1dGhvcml0eTogcGFyc2VkVXJpWzJdLFxyXG4gICAgICAgIHBhdGg6IHBhcnNlZFVyaVszXSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XHJcbmZ1bmN0aW9uIHNwbGl0SG9zdFBvcnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnWycpKSB7XHJcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xyXG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IHBhdGguc3Vic3RyaW5nKDEsIGhvc3RFbmQpO1xyXG4gICAgICAgIC8qIE9ubHkgYW4gSVB2NiBhZGRyZXNzIHNob3VsZCBiZSBpbiBicmFja2V0ZWQgbm90YXRpb24sIGFuZCBhbiBJUHY2XHJcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cclxuICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBob3N0RW5kICsgMSkge1xyXG4gICAgICAgICAgICBpZiAocGF0aFtob3N0RW5kICsgMV0gPT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcclxuICAgICAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChwb3J0U3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtwb3J0U3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaG9zdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgLyogRXhhY3RseSBvbmUgY29sb24gbWVhbnMgdGhhdCB0aGlzIGlzIGhvc3Q6cG9ydC4gWmVybyBjb2xvbnMgbWVhbnMgdGhhdFxyXG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XHJcbiAgICAgICAgICogYWRkcmVzcyB3aXRoIG5vIHBvcnQgKi9cclxuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0OiBzcGxpdFBhdGhbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbWJpbmVIb3N0UG9ydChob3N0UG9ydCkge1xyXG4gICAgaWYgKGhvc3RQb3J0LnBvcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBob3N0UG9ydC5ob3N0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gT25seSBhbiBJUHY2IGhvc3Qgc2hvdWxkIGluY2x1ZGUgYSBjb2xvblxyXG4gICAgICAgIGlmIChob3N0UG9ydC5ob3N0LmluY2x1ZGVzKCc6JykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBbJHtob3N0UG9ydC5ob3N0fV06JHtob3N0UG9ydC5wb3J0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7aG9zdFBvcnQuaG9zdH06JHtob3N0UG9ydC5wb3J0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgaWYgKHVyaS5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xyXG4gICAgfVxyXG4gICAgaWYgKHVyaS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcclxuICAgIH1cclxuICAgIHJlc3VsdCArPSB1cmkucGF0aDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * @license\r\n * Copyright 2018 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\r\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(rsc)/./node_modules/lodash.camelcase/index.js\");\r\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\r\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(rsc)/./node_modules/protobufjs/ext/descriptor/index.js\");\r\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\");\r\nconst Long = __webpack_require__(/*! long */ \"(rsc)/./node_modules/long/umd/index.js\");\r\nexports.Long = Long;\r\nfunction isAnyExtension(obj) {\r\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\r\n}\r\nexports.isAnyExtension = isAnyExtension;\r\nvar IdempotencyLevel;\r\n(function (IdempotencyLevel) {\r\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\r\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\r\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\r\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\r\nconst descriptorOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    defaults: true,\r\n    oneofs: true,\r\n    json: true,\r\n};\r\nfunction joinName(baseName, name) {\r\n    if (baseName === '') {\r\n        return name;\r\n    }\r\n    else {\r\n        return baseName + '.' + name;\r\n    }\r\n}\r\nfunction isHandledReflectionObject(obj) {\r\n    return (obj instanceof Protobuf.Service ||\r\n        obj instanceof Protobuf.Type ||\r\n        obj instanceof Protobuf.Enum);\r\n}\r\nfunction isNamespaceBase(obj) {\r\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\r\n}\r\nfunction getAllHandledReflectionObjects(obj, parentName) {\r\n    const objName = joinName(parentName, obj.name);\r\n    if (isHandledReflectionObject(obj)) {\r\n        return [[objName, obj]];\r\n    }\r\n    else {\r\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\r\n            return Object.keys(obj.nested)\r\n                .map(name => {\r\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\r\n            })\r\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\r\n        }\r\n    }\r\n    return [];\r\n}\r\nfunction createDeserializer(cls, options) {\r\n    return function deserialize(argBuf) {\r\n        return cls.toObject(cls.decode(argBuf), options);\r\n    };\r\n}\r\nfunction createSerializer(cls) {\r\n    return function serialize(arg) {\r\n        if (Array.isArray(arg)) {\r\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\r\n        }\r\n        const message = cls.fromObject(arg);\r\n        return cls.encode(message).finish();\r\n    };\r\n}\r\nfunction mapMethodOptions(options) {\r\n    return (options || []).reduce((obj, item) => {\r\n        for (const [key, value] of Object.entries(item)) {\r\n            switch (key) {\r\n                case 'uninterpreted_option':\r\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\r\n                    break;\r\n                default:\r\n                    obj[key] = value;\r\n            }\r\n        }\r\n        return obj;\r\n    }, {\r\n        deprecated: false,\r\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\r\n        uninterpreted_option: [],\r\n    });\r\n}\r\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\r\n    /* This is only ever called after the corresponding root.resolveAll(), so we\r\n     * can assume that the resolved request and response types are non-null */\r\n    const requestType = method.resolvedRequestType;\r\n    const responseType = method.resolvedResponseType;\r\n    return {\r\n        path: '/' + serviceName + '/' + method.name,\r\n        requestStream: !!method.requestStream,\r\n        responseStream: !!method.responseStream,\r\n        requestSerialize: createSerializer(requestType),\r\n        requestDeserialize: createDeserializer(requestType, options),\r\n        responseSerialize: createSerializer(responseType),\r\n        responseDeserialize: createDeserializer(responseType, options),\r\n        // TODO(murgatroid99): Find a better way to handle this\r\n        originalName: camelCase(method.name),\r\n        requestType: createMessageDefinition(requestType, fileDescriptors),\r\n        responseType: createMessageDefinition(responseType, fileDescriptors),\r\n        options: mapMethodOptions(method.parsedOptions),\r\n    };\r\n}\r\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\r\n    const def = {};\r\n    for (const method of service.methodsArray) {\r\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\r\n    }\r\n    return def;\r\n}\r\nfunction createMessageDefinition(message, fileDescriptors) {\r\n    const messageDescriptor = message.toDescriptor('proto3');\r\n    return {\r\n        format: 'Protocol Buffer 3 DescriptorProto',\r\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\r\n        fileDescriptorProtos: fileDescriptors,\r\n    };\r\n}\r\nfunction createEnumDefinition(enumType, fileDescriptors) {\r\n    const enumDescriptor = enumType.toDescriptor('proto3');\r\n    return {\r\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\r\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\r\n        fileDescriptorProtos: fileDescriptors,\r\n    };\r\n}\r\n/**\r\n * function createDefinition(obj: Protobuf.Service, name: string, options:\r\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\r\n * name: string, options: Options): MessageTypeDefinition; function\r\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\r\n * EnumTypeDefinition;\r\n */\r\nfunction createDefinition(obj, name, options, fileDescriptors) {\r\n    if (obj instanceof Protobuf.Service) {\r\n        return createServiceDefinition(obj, name, options, fileDescriptors);\r\n    }\r\n    else if (obj instanceof Protobuf.Type) {\r\n        return createMessageDefinition(obj, fileDescriptors);\r\n    }\r\n    else if (obj instanceof Protobuf.Enum) {\r\n        return createEnumDefinition(obj, fileDescriptors);\r\n    }\r\n    else {\r\n        throw new Error('Type mismatch in reflection object handling');\r\n    }\r\n}\r\nfunction createPackageDefinition(root, options) {\r\n    const def = {};\r\n    root.resolveAll();\r\n    const descriptorList = root.toDescriptor('proto3').file;\r\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\r\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\r\n        def[name] = createDefinition(obj, name, options, bufferList);\r\n    }\r\n    return def;\r\n}\r\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\r\n    options = options || {};\r\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\r\n    root.resolveAll();\r\n    return createPackageDefinition(root, options);\r\n}\r\n/**\r\n * Load a .proto file with the specified options.\r\n * @param filename One or multiple file paths to load. Can be an absolute path\r\n *     or relative to an include path.\r\n * @param options.keepCase Preserve field names. The default is to change them\r\n *     to camel case.\r\n * @param options.longs The type that should be used to represent `long` values.\r\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\r\n *     from a library.\r\n * @param options.enums The type that should be used to represent `enum` values.\r\n *     The only valid option is `String`. Defaults to the numeric value.\r\n * @param options.bytes The type that should be used to represent `bytes`\r\n *     values. Valid options are `Array` and `String`. The default is to use\r\n *     `Buffer`.\r\n * @param options.defaults Set default values on output objects. Defaults to\r\n *     `false`.\r\n * @param options.arrays Set empty arrays for missing array values even if\r\n *     `defaults` is `false`. Defaults to `false`.\r\n * @param options.objects Set empty objects for missing object values even if\r\n *     `defaults` is `false`. Defaults to `false`.\r\n * @param options.oneofs Set virtual oneof properties to the present field's\r\n *     name\r\n * @param options.json Represent Infinity and NaN as strings in float fields,\r\n *     and automatically decode google.protobuf.Any values.\r\n * @param options.includeDirs Paths to search for imported `.proto` files.\r\n */\r\nfunction load(filename, options) {\r\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\r\n        return createPackageDefinition(loadedRoot, options);\r\n    });\r\n}\r\nexports.load = load;\r\nfunction loadSync(filename, options) {\r\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\r\n    return createPackageDefinition(loadedRoot, options);\r\n}\r\nexports.loadSync = loadSync;\r\nfunction fromJSON(json, options) {\r\n    options = options || {};\r\n    const loadedRoot = Protobuf.Root.fromJSON(json);\r\n    loadedRoot.resolveAll();\r\n    return createPackageDefinition(loadedRoot, options);\r\n}\r\nexports.fromJSON = fromJSON;\r\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\r\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\r\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\r\n}\r\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\r\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\r\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\r\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\r\n}\r\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\r\n(0, util_1.addCommonProtos)();\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLFlBQVk7QUFDek0sa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYW5pc2gtYnVkZHkvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz83YzZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gZXhwb3J0cy5mcm9tSlNPTiA9IGV4cG9ydHMubG9hZFN5bmMgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgPSBleHBvcnRzLmlzQW55RXh0ZW5zaW9uID0gZXhwb3J0cy5Mb25nID0gdm9pZCAwO1xyXG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKFwibG9kYXNoLmNhbWVsY2FzZVwiKTtcclxuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcclxuY29uc3QgZGVzY3JpcHRvciA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL2V4dC9kZXNjcmlwdG9yXCIpO1xyXG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XHJcbmV4cG9ydHMuTG9uZyA9IExvbmc7XHJcbmZ1bmN0aW9uIGlzQW55RXh0ZW5zaW9uKG9iaikge1xyXG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcclxufVxyXG5leHBvcnRzLmlzQW55RXh0ZW5zaW9uID0gaXNBbnlFeHRlbnNpb247XHJcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xyXG4oZnVuY3Rpb24gKElkZW1wb3RlbmN5TGV2ZWwpIHtcclxuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJJREVNUE9URU5DWV9VTktOT1dOXCJdID0gXCJJREVNUE9URU5DWV9VTktOT1dOXCI7XHJcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcclxuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJJREVNUE9URU5UXCJdID0gXCJJREVNUE9URU5UXCI7XHJcbn0pKElkZW1wb3RlbmN5TGV2ZWwgPSBleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgfHwgKGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xyXG4gICAgbG9uZ3M6IFN0cmluZyxcclxuICAgIGVudW1zOiBTdHJpbmcsXHJcbiAgICBieXRlczogU3RyaW5nLFxyXG4gICAgZGVmYXVsdHM6IHRydWUsXHJcbiAgICBvbmVvZnM6IHRydWUsXHJcbiAgICBqc29uOiB0cnVlLFxyXG59O1xyXG5mdW5jdGlvbiBqb2luTmFtZShiYXNlTmFtZSwgbmFtZSkge1xyXG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VOYW1lICsgJy4nICsgbmFtZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlIHx8XHJcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxyXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5OYW1lc3BhY2UgfHwgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuUm9vdDtcclxufVxyXG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XHJcbiAgICBjb25zdCBvYmpOYW1lID0gam9pbk5hbWUocGFyZW50TmFtZSwgb2JqLm5hbWUpO1xyXG4gICAgaWYgKGlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqLm5lc3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAobmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IuY29uY2F0KGN1cnJlbnRWYWx1ZSksIFtdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRGVzZXJpYWxpemVyKGNscywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlc2VyaWFsaXplKGFyZ0J1Zikge1xyXG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzZXJpYWxpemUoYXJnKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gY2xzLmZyb21PYmplY3QoYXJnKTtcclxuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gKG9wdGlvbnMgfHwgW10pLnJlZHVjZSgob2JqLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3VuaW50ZXJwcmV0ZWRfb3B0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICBvYmoudW5pbnRlcnByZXRlZF9vcHRpb24ucHVzaChpdGVtLnVuaW50ZXJwcmV0ZWRfb3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSwge1xyXG4gICAgICAgIGRlcHJlY2F0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlkZW1wb3RlbmN5X2xldmVsOiBJZGVtcG90ZW5jeUxldmVsLklERU1QT1RFTkNZX1VOS05PV04sXHJcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcclxuICAgIC8qIFRoaXMgaXMgb25seSBldmVyIGNhbGxlZCBhZnRlciB0aGUgY29ycmVzcG9uZGluZyByb290LnJlc29sdmVBbGwoKSwgc28gd2VcclxuICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgcmVzb2x2ZWQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgdHlwZXMgYXJlIG5vbi1udWxsICovXHJcbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xyXG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxyXG4gICAgICAgIHJlcXVlc3RTdHJlYW06ICEhbWV0aG9kLnJlcXVlc3RTdHJlYW0sXHJcbiAgICAgICAgcmVzcG9uc2VTdHJlYW06ICEhbWV0aG9kLnJlc3BvbnNlU3RyZWFtLFxyXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxyXG4gICAgICAgIHJlcXVlc3REZXNlcmlhbGl6ZTogY3JlYXRlRGVzZXJpYWxpemVyKHJlcXVlc3RUeXBlLCBvcHRpb25zKSxcclxuICAgICAgICByZXNwb25zZVNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihyZXNwb25zZVR5cGUpLFxyXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxyXG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXNcclxuICAgICAgICBvcmlnaW5hbE5hbWU6IGNhbWVsQ2FzZShtZXRob2QubmFtZSksXHJcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogY3JlYXRlTWVzc2FnZURlZmluaXRpb24ocmVzcG9uc2VUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxyXG4gICAgICAgIG9wdGlvbnM6IG1hcE1ldGhvZE9wdGlvbnMobWV0aG9kLnBhcnNlZE9wdGlvbnMpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihzZXJ2aWNlLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcclxuICAgIGNvbnN0IGRlZiA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc2VydmljZS5tZXRob2RzQXJyYXkpIHtcclxuICAgICAgICBkZWZbbWV0aG9kLm5hbWVdID0gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIGZpbGVEZXNjcmlwdG9ycykge1xyXG4gICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSBtZXNzYWdlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXHJcbiAgICAgICAgdHlwZTogbWVzc2FnZURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QobWVzc2FnZURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcclxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFbnVtRGVmaW5pdGlvbihlbnVtVHlwZSwgZmlsZURlc2NyaXB0b3JzKSB7XHJcbiAgICBjb25zdCBlbnVtRGVzY3JpcHRvciA9IGVudW1UeXBlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIEVudW1EZXNjcmlwdG9yUHJvdG8nLFxyXG4gICAgICAgIHR5cGU6IGVudW1EZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KGVudW1EZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXHJcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5TZXJ2aWNlLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6XHJcbiAqIE9wdGlvbnMpOiBTZXJ2aWNlRGVmaW5pdGlvbjsgZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlR5cGUsXHJcbiAqIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6IE1lc3NhZ2VUeXBlRGVmaW5pdGlvbjsgZnVuY3Rpb25cclxuICogY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLkVudW0sIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6XHJcbiAqIEVudW1UeXBlRGVmaW5pdGlvbjtcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTWVzc2FnZURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbnVtRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2ggaW4gcmVmbGVjdGlvbiBvYmplY3QgaGFuZGxpbmcnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBkZWYgPSB7fTtcclxuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xyXG4gICAgY29uc3QgZGVzY3JpcHRvckxpc3QgPSByb290LnRvRGVzY3JpcHRvcigncHJvdG8zJykuZmlsZTtcclxuICAgIGNvbnN0IGJ1ZmZlckxpc3QgPSBkZXNjcmlwdG9yTGlzdC5tYXAodmFsdWUgPT4gQnVmZmVyLmZyb20oZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclByb3RvLmVuY29kZSh2YWx1ZSkuZmluaXNoKCkpKTtcclxuICAgIGZvciAoY29uc3QgW25hbWUsIG9ial0gb2YgZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKHJvb3QsICcnKSkge1xyXG4gICAgICAgIGRlZltuYW1lXSA9IGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBidWZmZXJMaXN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWY7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCByb290ID0gUHJvdG9idWYuUm9vdC5mcm9tRGVzY3JpcHRvcihkZWNvZGVkRGVzY3JpcHRvclNldCk7XHJcbiAgICByb290LnJlc29sdmVBbGwoKTtcclxuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogTG9hZCBhIC5wcm90byBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLlxyXG4gKiBAcGFyYW0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGUgcGF0aHMgdG8gbG9hZC4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGhcclxuICogICAgIG9yIHJlbGF0aXZlIHRvIGFuIGluY2x1ZGUgcGF0aC5cclxuICogQHBhcmFtIG9wdGlvbnMua2VlcENhc2UgUHJlc2VydmUgZmllbGQgbmFtZXMuIFRoZSBkZWZhdWx0IGlzIHRvIGNoYW5nZSB0aGVtXHJcbiAqICAgICB0byBjYW1lbCBjYXNlLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5sb25ncyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgbG9uZ2AgdmFsdWVzLlxyXG4gKiAgICAgVmFsaWQgb3B0aW9ucyBhcmUgYE51bWJlcmAgYW5kIGBTdHJpbmdgLiBEZWZhdWx0cyB0byBhIGBMb25nYCBvYmplY3QgdHlwZVxyXG4gKiAgICAgZnJvbSBhIGxpYnJhcnkuXHJcbiAqIEBwYXJhbSBvcHRpb25zLmVudW1zIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBlbnVtYCB2YWx1ZXMuXHJcbiAqICAgICBUaGUgb25seSB2YWxpZCBvcHRpb24gaXMgYFN0cmluZ2AuIERlZmF1bHRzIHRvIHRoZSBudW1lcmljIHZhbHVlLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5ieXRlcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgYnl0ZXNgXHJcbiAqICAgICB2YWx1ZXMuIFZhbGlkIG9wdGlvbnMgYXJlIGBBcnJheWAgYW5kIGBTdHJpbmdgLiBUaGUgZGVmYXVsdCBpcyB0byB1c2VcclxuICogICAgIGBCdWZmZXJgLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0cyBTZXQgZGVmYXVsdCB2YWx1ZXMgb24gb3V0cHV0IG9iamVjdHMuIERlZmF1bHRzIHRvXHJcbiAqICAgICBgZmFsc2VgLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5hcnJheXMgU2V0IGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyBhcnJheSB2YWx1ZXMgZXZlbiBpZlxyXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5vYmplY3RzIFNldCBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG9iamVjdCB2YWx1ZXMgZXZlbiBpZlxyXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5vbmVvZnMgU2V0IHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyB0byB0aGUgcHJlc2VudCBmaWVsZCdzXHJcbiAqICAgICBuYW1lXHJcbiAqIEBwYXJhbSBvcHRpb25zLmpzb24gUmVwcmVzZW50IEluZmluaXR5IGFuZCBOYU4gYXMgc3RyaW5ncyBpbiBmbG9hdCBmaWVsZHMsXHJcbiAqICAgICBhbmQgYXV0b21hdGljYWxseSBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkFueSB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVEaXJzIFBhdGhzIHRvIHNlYXJjaCBmb3IgaW1wb3J0ZWQgYC5wcm90b2AgZmlsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnMpKGZpbGVuYW1lLCBvcHRpb25zKS50aGVuKGxvYWRlZFJvb3QgPT4ge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XHJcbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBsb2FkZWRSb290ID0gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKShmaWxlbmFtZSwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xyXG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21KU09OKGpzb24pO1xyXG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xyXG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyKGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvclNldCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcjtcclxuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZnJvbU9iamVjdChkZXNjcmlwdG9yU2V0KTtcclxuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcclxufVxyXG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0O1xyXG4oMCwgdXRpbF8xLmFkZENvbW1vblByb3RvcykoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * @license\r\n * Copyright 2018 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\r\nfunction addIncludePathResolver(root, includePaths) {\r\n    const originalResolvePath = root.resolvePath;\r\n    root.resolvePath = (origin, target) => {\r\n        if (path.isAbsolute(target)) {\r\n            return target;\r\n        }\r\n        for (const directory of includePaths) {\r\n            const fullPath = path.join(directory, target);\r\n            try {\r\n                fs.accessSync(fullPath, fs.constants.R_OK);\r\n                return fullPath;\r\n            }\r\n            catch (err) {\r\n                continue;\r\n            }\r\n        }\r\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\r\n        return originalResolvePath(origin, target);\r\n    };\r\n}\r\nasync function loadProtosWithOptions(filename, options) {\r\n    const root = new Protobuf.Root();\r\n    options = options || {};\r\n    if (!!options.includeDirs) {\r\n        if (!Array.isArray(options.includeDirs)) {\r\n            return Promise.reject(new Error('The includeDirs option must be an array'));\r\n        }\r\n        addIncludePathResolver(root, options.includeDirs);\r\n    }\r\n    const loadedRoot = await root.load(filename, options);\r\n    loadedRoot.resolveAll();\r\n    return loadedRoot;\r\n}\r\nexports.loadProtosWithOptions = loadProtosWithOptions;\r\nfunction loadProtosWithOptionsSync(filename, options) {\r\n    const root = new Protobuf.Root();\r\n    options = options || {};\r\n    if (!!options.includeDirs) {\r\n        if (!Array.isArray(options.includeDirs)) {\r\n            throw new Error('The includeDirs option must be an array');\r\n        }\r\n        addIncludePathResolver(root, options.includeDirs);\r\n    }\r\n    const loadedRoot = root.loadSync(filename, options);\r\n    loadedRoot.resolveAll();\r\n    return loadedRoot;\r\n}\r\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\r\n/**\r\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\r\n */\r\nfunction addCommonProtos() {\r\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\r\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\r\n    // Using constant strings for compatibility with tools like Webpack\r\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/api.json\");\r\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\r\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/source_context.json\");\r\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/type.json\");\r\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\r\n}\r\nexports.addCommonProtos = addCommonProtos;\r\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkI7QUFDM0YsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsd0NBQXdDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBcUM7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTRDO0FBQ3JGLG9DQUFvQyxtQkFBTyxDQUFDLDJIQUFnRDtBQUM1RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhbmlzaC1idWRkeS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanM/ZDBmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSB2b2lkIDA7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XHJcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XHJcbiAgICBjb25zdCBvcmlnaW5hbFJlc29sdmVQYXRoID0gcm9vdC5yZXNvbHZlUGF0aDtcclxuICAgIHJvb3QucmVzb2x2ZVBhdGggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcclxuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdWxsUGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGAke3RhcmdldH0gbm90IGZvdW5kIGluIGFueSBvZiB0aGUgaW5jbHVkZSBwYXRocyAke2luY2x1ZGVQYXRoc31gKTtcclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXNvbHZlUGF0aChvcmlnaW4sIHRhcmdldCk7XHJcbiAgICB9O1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9ucyhmaWxlbmFtZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIGluY2x1ZGVEaXJzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IGF3YWl0IHJvb3QubG9hZChmaWxlbmFtZSwgb3B0aW9ucyk7XHJcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcclxuICAgIHJldHVybiBsb2FkZWRSb290O1xyXG59XHJcbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xyXG5mdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IHJvb3QubG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpO1xyXG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XHJcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcclxufVxyXG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jO1xyXG4vKipcclxuICogTG9hZCBHb29nbGUncyB3ZWxsLWtub3duIHByb3RvIGZpbGVzIHRoYXQgYXJlbid0IGV4cG9zZWQgYnkgUHJvdG9idWYuanMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XHJcbiAgICAvLyBQcm90b2J1Zi5qcyBleHBvc2VzOiBhbnksIGR1cmF0aW9uLCBlbXB0eSwgZmllbGRfbWFzaywgc3RydWN0LCB0aW1lc3RhbXAsXHJcbiAgICAvLyBhbmQgd3JhcHBlcnMuIGNvbXBpbGVyL3BsdWdpbiBpcyBleGNsdWRlZCBpbiBQcm90b2J1Zi5qcyBhbmQgaGVyZS5cclxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcclxuICAgIGNvbnN0IGFwaURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9hcGkuanNvbicpO1xyXG4gICAgY29uc3QgZGVzY3JpcHRvckRlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLmpzb24nKTtcclxuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xyXG4gICAgY29uc3QgdHlwZURlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi90eXBlLmpzb24nKTtcclxuICAgIFByb3RvYnVmLmNvbW1vbignYXBpJywgYXBpRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xyXG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcclxuICAgIFByb3RvYnVmLmNvbW1vbignc291cmNlX2NvbnRleHQnLCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xyXG4gICAgUHJvdG9idWYuY29tbW9uKCd0eXBlJywgdHlwZURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcclxufVxyXG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGFkZENvbW1vblByb3RvcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.13.3","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":">=12.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@grpc/proto-loader":"file:../proto-loader","@types/gulp":"^4.0.17","@types/gulp-mocha":"0.0.37","@types/lodash":"^4.14.202","@types/mocha":"^10.0.6","@types/ncp":"^2.0.8","@types/node":">=20.11.20","@types/pify":"^5.0.4","@types/semver":"^7.5.8","@typescript-eslint/eslint-plugin":"^7.1.0","@typescript-eslint/parser":"^7.1.0","@typescript-eslint/typescript-estree":"^7.1.0","clang-format":"^1.8.0","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.21","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.6.0","ts-node":"^10.9.2","typescript":"^5.3.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.13","@js-sdsl/ordered-map":"^4.4.2"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;