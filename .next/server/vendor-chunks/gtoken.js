"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gtoken";
exports.ids = ["vendor-chunks/gtoken"];
exports.modules = {

/***/ "(rsc)/./node_modules/gtoken/build/cjs/src/index.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/gtoken/build/cjs/src/index.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({\r\n  value: true\r\n}));\r\nexports.GoogleToken = void 0;\r\nvar fs = _interopRequireWildcard(__webpack_require__(/*! fs */ \"fs\"));\r\nvar _gaxios = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/cjs/src/index.js\");\r\nvar jws = _interopRequireWildcard(__webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\"));\r\nvar path = _interopRequireWildcard(__webpack_require__(/*! path */ \"path\"));\r\nvar _util = __webpack_require__(/*! util */ \"util\");\r\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\r\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\r\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\r\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\r\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\r\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\r\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\r\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\r\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\r\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\r\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\r\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\r\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\r\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\r\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\r\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\r\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\r\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\r\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\r\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\r\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\r\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\r\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\r\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\r\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\r\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\r\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\r\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; } /**\r\n * Copyright 2018 Google LLC\r\n *\r\n * Distributed under MIT license.\r\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\r\n */\r\nvar readFile = fs.readFile ? (0, _util.promisify)(fs.readFile) : /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\r\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\r\n    while (1) switch (_context.prev = _context.next) {\r\n      case 0:\r\n        throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\r\n      case 1:\r\n      case \"end\":\r\n        return _context.stop();\r\n    }\r\n  }, _callee);\r\n}));\r\nvar GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\r\nvar GOOGLE_REVOKE_TOKEN_URL = 'https://oauth2.googleapis.com/revoke?token=';\r\nvar ErrorWithCode = /*#__PURE__*/function (_Error) {\r\n  function ErrorWithCode(message, code) {\r\n    var _this;\r\n    _classCallCheck(this, ErrorWithCode);\r\n    _this = _callSuper(this, ErrorWithCode, [message]);\r\n    _defineProperty(_this, \"code\", void 0);\r\n    _this.code = code;\r\n    return _this;\r\n  }\r\n  _inherits(ErrorWithCode, _Error);\r\n  return _createClass(ErrorWithCode);\r\n}(/*#__PURE__*/_wrapNativeSuper(Error));\r\nvar _inFlightRequest = /*#__PURE__*/new WeakMap();\r\nvar _GoogleToken_brand = /*#__PURE__*/new WeakSet();\r\nvar GoogleToken = exports.GoogleToken = /*#__PURE__*/function () {\r\n  /**\r\n   * Create a GoogleToken.\r\n   *\r\n   * @param options  Configuration object.\r\n   */\r\n  function GoogleToken(_options) {\r\n    _classCallCheck(this, GoogleToken);\r\n    _classPrivateMethodInitSpec(this, _GoogleToken_brand);\r\n    _defineProperty(this, \"expiresAt\", void 0);\r\n    _defineProperty(this, \"key\", void 0);\r\n    _defineProperty(this, \"keyFile\", void 0);\r\n    _defineProperty(this, \"iss\", void 0);\r\n    _defineProperty(this, \"sub\", void 0);\r\n    _defineProperty(this, \"scope\", void 0);\r\n    _defineProperty(this, \"rawToken\", void 0);\r\n    _defineProperty(this, \"tokenExpires\", void 0);\r\n    _defineProperty(this, \"email\", void 0);\r\n    _defineProperty(this, \"additionalClaims\", void 0);\r\n    _defineProperty(this, \"eagerRefreshThresholdMillis\", void 0);\r\n    _defineProperty(this, \"transporter\", {\r\n      request: function request(opts) {\r\n        return (0, _gaxios.request)(opts);\r\n      }\r\n    });\r\n    _classPrivateFieldInitSpec(this, _inFlightRequest, void 0);\r\n    _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, _options);\r\n  }\r\n\r\n  /**\r\n   * Returns whether the token has expired.\r\n   *\r\n   * @return true if the token has expired, false otherwise.\r\n   */\r\n  return _createClass(GoogleToken, [{\r\n    key: \"accessToken\",\r\n    get: function get() {\r\n      return this.rawToken ? this.rawToken.access_token : undefined;\r\n    }\r\n  }, {\r\n    key: \"idToken\",\r\n    get: function get() {\r\n      return this.rawToken ? this.rawToken.id_token : undefined;\r\n    }\r\n  }, {\r\n    key: \"tokenType\",\r\n    get: function get() {\r\n      return this.rawToken ? this.rawToken.token_type : undefined;\r\n    }\r\n  }, {\r\n    key: \"refreshToken\",\r\n    get: function get() {\r\n      return this.rawToken ? this.rawToken.refresh_token : undefined;\r\n    }\r\n  }, {\r\n    key: \"hasExpired\",\r\n    value: function hasExpired() {\r\n      var now = new Date().getTime();\r\n      if (this.rawToken && this.expiresAt) {\r\n        return now >= this.expiresAt;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns whether the token will expire within eagerRefreshThresholdMillis\r\n     *\r\n     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\r\n     */\r\n  }, {\r\n    key: \"isTokenExpiring\",\r\n    value: function isTokenExpiring() {\r\n      var _this$eagerRefreshThr;\r\n      var now = new Date().getTime();\r\n      var eagerRefreshThresholdMillis = (_this$eagerRefreshThr = this.eagerRefreshThresholdMillis) !== null && _this$eagerRefreshThr !== void 0 ? _this$eagerRefreshThr : 0;\r\n      if (this.rawToken && this.expiresAt) {\r\n        return this.expiresAt <= now + eagerRefreshThresholdMillis;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns a cached token or retrieves a new one from Google.\r\n     *\r\n     * @param callback The callback function.\r\n     */\r\n  }, {\r\n    key: \"getToken\",\r\n    value: function getToken(callback) {\r\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      if (_typeof(callback) === 'object') {\r\n        opts = callback;\r\n        callback = undefined;\r\n      }\r\n      opts = Object.assign({\r\n        forceRefresh: false\r\n      }, opts);\r\n      if (callback) {\r\n        var cb = callback;\r\n        _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts).then(function (t) {\r\n          return cb(null, t);\r\n        }, callback);\r\n        return;\r\n      }\r\n      return _assertClassBrand(_GoogleToken_brand, this, _getTokenAsync).call(this, opts);\r\n    }\r\n\r\n    /**\r\n     * Given a keyFile, extract the key and client email if available\r\n     * @param keyFile Path to a json, pem, or p12 file that contains the key.\r\n     * @returns an object with privateKey and clientEmail properties\r\n     */\r\n  }, {\r\n    key: \"getCredentials\",\r\n    value: (function () {\r\n      var _getCredentials = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(keyFile) {\r\n        var ext, key, body, privateKey, clientEmail, _privateKey;\r\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\r\n          while (1) switch (_context2.prev = _context2.next) {\r\n            case 0:\r\n              ext = path.extname(keyFile);\r\n              _context2.t0 = ext;\r\n              _context2.next = _context2.t0 === '.json' ? 4 : _context2.t0 === '.der' ? 13 : _context2.t0 === '.crt' ? 13 : _context2.t0 === '.pem' ? 13 : _context2.t0 === '.p12' ? 17 : _context2.t0 === '.pfx' ? 17 : 18;\r\n              break;\r\n            case 4:\r\n              _context2.next = 6;\r\n              return readFile(keyFile, 'utf8');\r\n            case 6:\r\n              key = _context2.sent;\r\n              body = JSON.parse(key);\r\n              privateKey = body.private_key;\r\n              clientEmail = body.client_email;\r\n              if (!(!privateKey || !clientEmail)) {\r\n                _context2.next = 12;\r\n                break;\r\n              }\r\n              throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\r\n            case 12:\r\n              return _context2.abrupt(\"return\", {\r\n                privateKey: privateKey,\r\n                clientEmail: clientEmail\r\n              });\r\n            case 13:\r\n              _context2.next = 15;\r\n              return readFile(keyFile, 'utf8');\r\n            case 15:\r\n              _privateKey = _context2.sent;\r\n              return _context2.abrupt(\"return\", {\r\n                privateKey: _privateKey\r\n              });\r\n            case 17:\r\n              throw new ErrorWithCode('*.p12 certificates are not supported after v6.1.2. ' + 'Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.', 'UNKNOWN_CERTIFICATE_TYPE');\r\n            case 18:\r\n              throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' + 'Current supported extensions are *.json, and *.pem.', 'UNKNOWN_CERTIFICATE_TYPE');\r\n            case 19:\r\n            case \"end\":\r\n              return _context2.stop();\r\n          }\r\n        }, _callee2);\r\n      }));\r\n      function getCredentials(_x) {\r\n        return _getCredentials.apply(this, arguments);\r\n      }\r\n      return getCredentials;\r\n    }())\r\n  }, {\r\n    key: \"revokeToken\",\r\n    value: function revokeToken(callback) {\r\n      if (callback) {\r\n        _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this).then(function () {\r\n          return callback();\r\n        }, callback);\r\n        return;\r\n      }\r\n      return _assertClassBrand(_GoogleToken_brand, this, _revokeTokenAsync).call(this);\r\n    }\r\n  }]);\r\n}();\r\nfunction _getTokenAsync(_x2) {\r\n  return _getTokenAsync2.apply(this, arguments);\r\n}\r\nfunction _getTokenAsync2() {\r\n  _getTokenAsync2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(opts) {\r\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\r\n      while (1) switch (_context3.prev = _context3.next) {\r\n        case 0:\r\n          if (!(_classPrivateFieldGet(_inFlightRequest, this) && !opts.forceRefresh)) {\r\n            _context3.next = 2;\r\n            break;\r\n          }\r\n          return _context3.abrupt(\"return\", _classPrivateFieldGet(_inFlightRequest, this));\r\n        case 2:\r\n          _context3.prev = 2;\r\n          _context3.next = 5;\r\n          return _classPrivateFieldSet(_inFlightRequest, this, _assertClassBrand(_GoogleToken_brand, this, _getTokenAsyncInner).call(this, opts));\r\n        case 5:\r\n          return _context3.abrupt(\"return\", _context3.sent);\r\n        case 6:\r\n          _context3.prev = 6;\r\n          _classPrivateFieldSet(_inFlightRequest, this, undefined);\r\n          return _context3.finish(6);\r\n        case 9:\r\n        case \"end\":\r\n          return _context3.stop();\r\n      }\r\n    }, _callee3, this, [[2,, 6, 9]]);\r\n  }));\r\n  return _getTokenAsync2.apply(this, arguments);\r\n}\r\nfunction _getTokenAsyncInner(_x3) {\r\n  return _getTokenAsyncInner2.apply(this, arguments);\r\n}\r\nfunction _getTokenAsyncInner2() {\r\n  _getTokenAsyncInner2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(opts) {\r\n    var creds;\r\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\r\n      while (1) switch (_context4.prev = _context4.next) {\r\n        case 0:\r\n          if (!(this.isTokenExpiring() === false && opts.forceRefresh === false)) {\r\n            _context4.next = 2;\r\n            break;\r\n          }\r\n          return _context4.abrupt(\"return\", Promise.resolve(this.rawToken));\r\n        case 2:\r\n          if (!(!this.key && !this.keyFile)) {\r\n            _context4.next = 4;\r\n            break;\r\n          }\r\n          throw new Error('No key or keyFile set.');\r\n        case 4:\r\n          if (!(!this.key && this.keyFile)) {\r\n            _context4.next = 11;\r\n            break;\r\n          }\r\n          _context4.next = 7;\r\n          return this.getCredentials(this.keyFile);\r\n        case 7:\r\n          creds = _context4.sent;\r\n          this.key = creds.privateKey;\r\n          this.iss = creds.clientEmail || this.iss;\r\n          if (!creds.clientEmail) {\r\n            _assertClassBrand(_GoogleToken_brand, this, _ensureEmail).call(this);\r\n          }\r\n        case 11:\r\n          return _context4.abrupt(\"return\", _assertClassBrand(_GoogleToken_brand, this, _requestToken).call(this));\r\n        case 12:\r\n        case \"end\":\r\n          return _context4.stop();\r\n      }\r\n    }, _callee4, this);\r\n  }));\r\n  return _getTokenAsyncInner2.apply(this, arguments);\r\n}\r\nfunction _ensureEmail() {\r\n  if (!this.iss) {\r\n    throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\r\n  }\r\n}\r\nfunction _revokeTokenAsync() {\r\n  return _revokeTokenAsync2.apply(this, arguments);\r\n}\r\nfunction _revokeTokenAsync2() {\r\n  _revokeTokenAsync2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\r\n    var url;\r\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\r\n      while (1) switch (_context5.prev = _context5.next) {\r\n        case 0:\r\n          if (this.accessToken) {\r\n            _context5.next = 2;\r\n            break;\r\n          }\r\n          throw new Error('No token to revoke.');\r\n        case 2:\r\n          url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\r\n          _context5.next = 5;\r\n          return this.transporter.request({\r\n            url: url,\r\n            retry: true\r\n          });\r\n        case 5:\r\n          _assertClassBrand(_GoogleToken_brand, this, _configure).call(this, {\r\n            email: this.iss,\r\n            sub: this.sub,\r\n            key: this.key,\r\n            keyFile: this.keyFile,\r\n            scope: this.scope,\r\n            additionalClaims: this.additionalClaims\r\n          });\r\n        case 6:\r\n        case \"end\":\r\n          return _context5.stop();\r\n      }\r\n    }, _callee5, this);\r\n  }));\r\n  return _revokeTokenAsync2.apply(this, arguments);\r\n}\r\n/**\r\n * Configure the GoogleToken for re-use.\r\n * @param  {object} options Configuration object.\r\n */\r\nfunction _configure() {\r\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  this.keyFile = options.keyFile;\r\n  this.key = options.key;\r\n  this.rawToken = undefined;\r\n  this.iss = options.email || options.iss;\r\n  this.sub = options.sub;\r\n  this.additionalClaims = options.additionalClaims;\r\n  if (_typeof(options.scope) === 'object') {\r\n    this.scope = options.scope.join(' ');\r\n  } else {\r\n    this.scope = options.scope;\r\n  }\r\n  this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\r\n  if (options.transporter) {\r\n    this.transporter = options.transporter;\r\n  }\r\n}\r\n/**\r\n * Request the token from Google.\r\n */\r\nfunction _requestToken() {\r\n  return _requestToken2.apply(this, arguments);\r\n}\r\nfunction _requestToken2() {\r\n  _requestToken2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\r\n    var iat, additionalClaims, payload, signedJWT, r, _response, _response2, body, desc;\r\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\r\n      while (1) switch (_context6.prev = _context6.next) {\r\n        case 0:\r\n          iat = Math.floor(new Date().getTime() / 1000);\r\n          additionalClaims = this.additionalClaims || {};\r\n          payload = Object.assign({\r\n            iss: this.iss,\r\n            scope: this.scope,\r\n            aud: GOOGLE_TOKEN_URL,\r\n            exp: iat + 3600,\r\n            iat: iat,\r\n            sub: this.sub\r\n          }, additionalClaims);\r\n          signedJWT = jws.sign({\r\n            header: {\r\n              alg: 'RS256'\r\n            },\r\n            payload: payload,\r\n            secret: this.key\r\n          });\r\n          _context6.prev = 4;\r\n          _context6.next = 7;\r\n          return this.transporter.request({\r\n            method: 'POST',\r\n            url: GOOGLE_TOKEN_URL,\r\n            data: new URLSearchParams({\r\n              grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\r\n              assertion: signedJWT\r\n            }),\r\n            responseType: 'json',\r\n            retryConfig: {\r\n              httpMethodsToRetry: ['POST']\r\n            }\r\n          });\r\n        case 7:\r\n          r = _context6.sent;\r\n          this.rawToken = r.data;\r\n          this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;\r\n          return _context6.abrupt(\"return\", this.rawToken);\r\n        case 13:\r\n          _context6.prev = 13;\r\n          _context6.t0 = _context6[\"catch\"](4);\r\n          this.rawToken = undefined;\r\n          this.tokenExpires = undefined;\r\n          body = _context6.t0.response && (_response = _context6.t0.response) !== null && _response !== void 0 && _response.data ? (_response2 = _context6.t0.response) === null || _response2 === void 0 ? void 0 : _response2.data : {};\r\n          if (body.error) {\r\n            desc = body.error_description ? \": \".concat(body.error_description) : '';\r\n            _context6.t0.message = \"\".concat(body.error).concat(desc);\r\n          }\r\n          throw _context6.t0;\r\n        case 20:\r\n        case \"end\":\r\n          return _context6.stop();\r\n      }\r\n    }, _callee6, this, [[4, 13]]);\r\n  }));\r\n  return _requestToken2.apply(this, arguments);\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3Rva2VuL2J1aWxkL2Nqcy9zcmMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixtQkFBbUI7QUFDbkIsaUNBQWlDLG1CQUFPLENBQUMsY0FBSTtBQUM3QyxjQUFjLG1CQUFPLENBQUMsa0VBQVE7QUFDOUIsa0NBQWtDLG1CQUFPLENBQUMsOENBQUs7QUFDL0MsbUNBQW1DLG1CQUFPLENBQUMsa0JBQU07QUFDakQsWUFBWSxtQkFBTyxDQUFDLGtCQUFNO0FBQzFCLHVDQUF1QywrQ0FBK0MsMENBQTBDLDBFQUEwRSxtQkFBbUI7QUFDN04seUNBQXlDLHVDQUF1Qyw2RUFBNkUsZ0JBQWdCLHFDQUFxQyxvQ0FBb0MsVUFBVSxpQkFBaUIsZ0VBQWdFLDBDQUEwQyw4QkFBOEIsMERBQTBELHdFQUF3RTtBQUMzaEIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsNkNBQTZDO0FBQzdDLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDLHVDQUF1QztBQUN2QyxzQ0FBc0Msc0ZBQXNGO0FBQzVILG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsNENBQTRDLHVFQUF1RSxtR0FBbUc7QUFDdE4scUNBQXFDLHlHQUF5RztBQUM5SSwyQkFBMkIscUhBQXFILGdEQUFnRCxlQUFlLDRDQUE0QywyQ0FBMkMsY0FBYztBQUNwVCwrQkFBK0IsdURBQXVELHlEQUF5RCxtREFBbUQsdUdBQXVHLG9CQUFvQiwrQkFBK0IscUJBQXFCLHFCQUFxQixzRUFBc0Usd0RBQXdELGVBQWUsa0VBQWtFLGlDQUFpQztBQUN0bkIsK0JBQStCLGtGQUFrRixnQkFBZ0Isb0JBQW9CLG9DQUFvQztBQUN6TCx1Q0FBdUMsTUFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFuaXNoLWJ1ZGR5Ly4vbm9kZV9tb2R1bGVzL2d0b2tlbi9idWlsZC9janMvc3JjL2luZGV4LmNqcz8zNTk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuR29vZ2xlVG9rZW4gPSB2b2lkIDA7XHJcbnZhciBmcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJmc1wiKSk7XHJcbnZhciBfZ2F4aW9zID0gcmVxdWlyZShcImdheGlvc1wiKTtcclxudmFyIGp3cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJqd3NcIikpO1xyXG52YXIgcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcclxudmFyIF91dGlsID0gcmVxdWlyZShcInV0aWxcIik7XHJcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbltcImRlZmF1bHRcIl0gPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XHJcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cclxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKGUsIGEpIHsgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgYSksIGEuYWRkKGUpOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKGUsIHQsIGEpIHsgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpOyB9XHJcbmZ1bmN0aW9uIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpIHsgaWYgKHQuaGFzKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgdGhlIHNhbWUgcHJpdmF0ZSBlbGVtZW50cyB0d2ljZSBvbiBhbiBvYmplY3RcIik7IH1cclxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHMsIGEsIHIpIHsgcmV0dXJuIHMuc2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjsgfVxyXG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocywgYSkgeyByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpOyB9XHJcbmZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47IHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxyXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxyXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cclxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7IGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuIGU7IH1cclxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiB0LCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxyXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHsgdmFyIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIE1hcCA/IG5ldyBNYXAoKSA6IHZvaWQgMDsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHsgaWYgKG51bGwgPT09IHQgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKHQpKSByZXR1cm4gdDsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyBpZiAodm9pZCAwICE9PSByKSB7IGlmIChyLmhhcyh0KSkgcmV0dXJuIHIuZ2V0KHQpOyByLnNldCh0LCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdCh0LCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gcmV0dXJuIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogITEsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgdCk7IH0sIF93cmFwTmF0aXZlU3VwZXIodCk7IH1cclxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB2YXIgbyA9IFtudWxsXTsgby5wdXNoLmFwcGx5KG8sIGUpOyB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpOyByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwOyB9XHJcbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxyXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbih0KSB7IHRyeSB7IHJldHVybiAtMSAhPT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKTsgfSBjYXRjaCAobikgeyByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0OyB9IH1cclxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0OyB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7IH1cclxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpOyB9LCBfZ2V0UHJvdG90eXBlT2YodCk7IH1cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XHJcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cclxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cclxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBlOyB9OyB2YXIgdCwgZSA9IHt9LCByID0gT2JqZWN0LnByb3RvdHlwZSwgbiA9IHIuaGFzT3duUHJvcGVydHksIG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKHQsIGUsIHIpIHsgdFtlXSA9IHIudmFsdWU7IH0sIGkgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBhID0gaS5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYyA9IGkuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB1ID0gaS50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7IHZhbHVlOiByLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCB0W2VdOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKHQpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKHQsIGUsIHIpIHsgcmV0dXJuIHRbZV0gPSByOyB9OyB9IGZ1bmN0aW9uIHdyYXAodCwgZSwgciwgbikgeyB2YXIgaSA9IGUgJiYgZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBlIDogR2VuZXJhdG9yLCBhID0gT2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksIGMgPSBuZXcgQ29udGV4dChuIHx8IFtdKTsgcmV0dXJuIG8oYSwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QodCwgciwgYykgfSksIGE7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2godCwgZSwgcikgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IHQuY2FsbChlLCByKSB9OyB9IGNhdGNoICh0KSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiB0IH07IH0gfSBlLndyYXAgPSB3cmFwOyB2YXIgaCA9IFwic3VzcGVuZGVkU3RhcnRcIiwgbCA9IFwic3VzcGVuZGVkWWllbGRcIiwgZiA9IFwiZXhlY3V0aW5nXCIsIHMgPSBcImNvbXBsZXRlZFwiLCB5ID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgcCA9IHt9OyBkZWZpbmUocCwgYSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCB2ID0gZCAmJiBkKGQodmFsdWVzKFtdKSkpOyB2ICYmIHYgIT09IHIgJiYgbi5jYWxsKHYsIGEpICYmIChwID0gdik7IHZhciBnID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocCk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyh0KSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IGRlZmluZSh0LCBlLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy5faW52b2tlKGUsIHQpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcih0LCBlKSB7IGZ1bmN0aW9uIGludm9rZShyLCBvLCBpLCBhKSB7IHZhciBjID0gdHJ5Q2F0Y2godFtyXSwgdCwgbyk7IGlmIChcInRocm93XCIgIT09IGMudHlwZSkgeyB2YXIgdSA9IGMuYXJnLCBoID0gdS52YWx1ZTsgcmV0dXJuIGggJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKGgpICYmIG4uY2FsbChoLCBcIl9fYXdhaXRcIikgPyBlLnJlc29sdmUoaC5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh0KSB7IGludm9rZShcIm5leHRcIiwgdCwgaSwgYSk7IH0sIGZ1bmN0aW9uICh0KSB7IGludm9rZShcInRocm93XCIsIHQsIGksIGEpOyB9KSA6IGUucmVzb2x2ZShoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHUudmFsdWUgPSB0LCBpKHUpOyB9LCBmdW5jdGlvbiAodCkgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgdCwgaSwgYSk7IH0pOyB9IGEoYy5hcmcpOyB9IHZhciByOyBvKHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0LCBuKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHsgaW52b2tlKHQsIG4sIGUsIHIpOyB9KTsgfSByZXR1cm4gciA9IHIgPyByLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChlLCByLCBuKSB7IHZhciBvID0gaDsgcmV0dXJuIGZ1bmN0aW9uIChpLCBhKSB7IGlmIChvID09PSBmKSB0aHJvdyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChvID09PSBzKSB7IGlmIChcInRocm93XCIgPT09IGkpIHRocm93IGE7IHJldHVybiB7IHZhbHVlOiB0LCBkb25lOiAhMCB9OyB9IGZvciAobi5tZXRob2QgPSBpLCBuLmFyZyA9IGE7OykgeyB2YXIgYyA9IG4uZGVsZWdhdGU7IGlmIChjKSB7IHZhciB1ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShjLCBuKTsgaWYgKHUpIHsgaWYgKHUgPT09IHkpIGNvbnRpbnVlOyByZXR1cm4gdTsgfSB9IGlmIChcIm5leHRcIiA9PT0gbi5tZXRob2QpIG4uc2VudCA9IG4uX3NlbnQgPSBuLmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IG4ubWV0aG9kKSB7IGlmIChvID09PSBoKSB0aHJvdyBvID0gcywgbi5hcmc7IG4uZGlzcGF0Y2hFeGNlcHRpb24obi5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gbi5tZXRob2QgJiYgbi5hYnJ1cHQoXCJyZXR1cm5cIiwgbi5hcmcpOyBvID0gZjsgdmFyIHAgPSB0cnlDYXRjaChlLCByLCBuKTsgaWYgKFwibm9ybWFsXCIgPT09IHAudHlwZSkgeyBpZiAobyA9IG4uZG9uZSA/IHMgOiBsLCBwLmFyZyA9PT0geSkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiBwLmFyZywgZG9uZTogbi5kb25lIH07IH0gXCJ0aHJvd1wiID09PSBwLnR5cGUgJiYgKG8gPSBzLCBuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBwLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpIHsgdmFyIG4gPSByLm1ldGhvZCwgbyA9IGUuaXRlcmF0b3Jbbl07IGlmIChvID09PSB0KSByZXR1cm4gci5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbiAmJiBlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChyLm1ldGhvZCA9IFwicmV0dXJuXCIsIHIuYXJnID0gdCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShlLCByKSwgXCJ0aHJvd1wiID09PSByLm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbiAmJiAoci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbiArIFwiJyBtZXRob2RcIikpLCB5OyB2YXIgaSA9IHRyeUNhdGNoKG8sIGUuaXRlcmF0b3IsIHIuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gaS50eXBlKSByZXR1cm4gci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gaS5hcmcsIHIuZGVsZWdhdGUgPSBudWxsLCB5OyB2YXIgYSA9IGkuYXJnOyByZXR1cm4gYSA/IGEuZG9uZSA/IChyW2UucmVzdWx0TmFtZV0gPSBhLnZhbHVlLCByLm5leHQgPSBlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IHIubWV0aG9kICYmIChyLm1ldGhvZCA9IFwibmV4dFwiLCByLmFyZyA9IHQpLCByLmRlbGVnYXRlID0gbnVsbCwgeSkgOiBhIDogKHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeSh0KSB7IHZhciBlID0geyB0cnlMb2M6IHRbMF0gfTsgMSBpbiB0ICYmIChlLmNhdGNoTG9jID0gdFsxXSksIDIgaW4gdCAmJiAoZS5maW5hbGx5TG9jID0gdFsyXSwgZS5hZnRlckxvYyA9IHRbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlKTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KHQpIHsgdmFyIGUgPSB0LmNvbXBsZXRpb24gfHwge307IGUudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBlLmFyZywgdC5jb21wbGV0aW9uID0gZTsgfSBmdW5jdGlvbiBDb250ZXh0KHQpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhlKSB7IGlmIChlIHx8IFwiXCIgPT09IGUpIHsgdmFyIHIgPSBlW2FdOyBpZiAocikgcmV0dXJuIHIuY2FsbChlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZS5uZXh0KSByZXR1cm4gZTsgaWYgKCFpc05hTihlLmxlbmd0aCkpIHsgdmFyIG8gPSAtMSwgaSA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK28gPCBlLmxlbmd0aDspIGlmIChuLmNhbGwoZSwgbykpIHJldHVybiBuZXh0LnZhbHVlID0gZVtvXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBpLm5leHQgPSBpOyB9IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihfdHlwZW9mKGUpICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpOyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbyhnLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBvKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhZSAmJiAoZSA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpKTsgfSwgZS5tYXJrID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAodC5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKHQsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZyksIHQ7IH0sIGUuYXdyYXAgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4geyBfX2F3YWl0OiB0IH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGUuYXN5bmMgPSBmdW5jdGlvbiAodCwgciwgbiwgbywgaSkgeyB2b2lkIDAgPT09IGkgJiYgKGkgPSBQcm9taXNlKTsgdmFyIGEgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKHQsIHIsIG4sIG8pLCBpKTsgcmV0dXJuIGUuaXNHZW5lcmF0b3JGdW5jdGlvbihyKSA/IGEgOiBhLm5leHQoKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmRvbmUgPyB0LnZhbHVlIDogYS5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoZyksIGRlZmluZShnLCB1LCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKGcsIGEsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoZywgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZS5rZXlzID0gZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBPYmplY3QodCksIHIgPSBbXTsgZm9yICh2YXIgbiBpbiBlKSByLnB1c2gobik7IHJldHVybiByLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IHIubGVuZ3RoOykgeyB2YXIgdCA9IHIucG9wKCk7IGlmICh0IGluIGUpIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoZSkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB0LCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIWUpIGZvciAodmFyIHIgaW4gdGhpcykgXCJ0XCIgPT09IHIuY2hhckF0KDApICYmIG4uY2FsbCh0aGlzLCByKSAmJiAhaXNOYU4oK3Iuc2xpY2UoMSkpICYmICh0aGlzW3JdID0gdCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgdCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSB0LnR5cGUpIHRocm93IHQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZSkgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBlOyB2YXIgciA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShuLCBvKSB7IHJldHVybiBhLnR5cGUgPSBcInRocm93XCIsIGEuYXJnID0gZSwgci5uZXh0ID0gbiwgbyAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgISFvOyB9IGZvciAodmFyIG8gPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgbyA+PSAwOyAtLW8pIHsgdmFyIGkgPSB0aGlzLnRyeUVudHJpZXNbb10sIGEgPSBpLmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gaS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChpLnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGMgPSBuLmNhbGwoaSwgXCJjYXRjaExvY1wiKSwgdSA9IG4uY2FsbChpLCBcImZpbmFsbHlMb2NcIik7IGlmIChjICYmIHUpIHsgaWYgKHRoaXMucHJldiA8IGkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoaS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoYykgeyBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghdSkgdGhyb3cgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShpLmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0LCBlKSB7IGZvciAodmFyIHIgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHsgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbcl07IGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgbi5jYWxsKG8sIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBvLmZpbmFsbHlMb2MpIHsgdmFyIGkgPSBvOyBicmVhazsgfSB9IGkgJiYgKFwiYnJlYWtcIiA9PT0gdCB8fCBcImNvbnRpbnVlXCIgPT09IHQpICYmIGkudHJ5TG9jIDw9IGUgJiYgZSA8PSBpLmZpbmFsbHlMb2MgJiYgKGkgPSBudWxsKTsgdmFyIGEgPSBpID8gaS5jb21wbGV0aW9uIDoge307IHJldHVybiBhLnR5cGUgPSB0LCBhLmFyZyA9IGUsIGkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gaS5maW5hbGx5TG9jLCB5KSA6IHRoaXMuY29tcGxldGUoYSk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh0LCBlKSB7IGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHQpIHsgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkgeyB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTsgaWYgKHIuZmluYWxseUxvYyA9PT0gdCkgcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLCByLmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShyKSwgeTsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0KSB7IGZvciAodmFyIGUgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpIHsgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07IGlmIChyLnRyeUxvYyA9PT0gdCkgeyB2YXIgbiA9IHIuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gbi50eXBlKSB7IHZhciBvID0gbi5hcmc7IHJlc2V0VHJ5RW50cnkocik7IH0gcmV0dXJuIG87IH0gfSB0aHJvdyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChlLCByLCBuKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGUpLCByZXN1bHROYW1lOiByLCBuZXh0TG9jOiBuIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB0KSwgeTsgfSB9LCBlOyB9XHJcbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChuLCB0LCBlLCByLCBvLCBhLCBjKSB7IHRyeSB7IHZhciBpID0gblthXShjKSwgdSA9IGkudmFsdWU7IH0gY2F0Y2ggKG4pIHsgcmV0dXJuIHZvaWQgZShuKTsgfSBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7IH1cclxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IobikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHRoaXMsIGUgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAociwgbykgeyB2YXIgYSA9IG4uYXBwbHkodCwgZSk7IGZ1bmN0aW9uIF9uZXh0KG4pIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCBuKTsgfSBmdW5jdGlvbiBfdGhyb3cobikgeyBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBuKTsgfSBfbmV4dCh2b2lkIDApOyB9KTsgfTsgfSAvKipcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZS5cclxuICogU2VlIGZpbGUgTElDRU5TRSBmb3IgZGV0YWlsIG9yIGNvcHkgYXQgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuICovXHJcbnZhciByZWFkRmlsZSA9IGZzLnJlYWRGaWxlID8gKDAsIF91dGlsLnByb21pc2lmeSkoZnMucmVhZEZpbGUpIDogLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xyXG4gIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xyXG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCd1c2Uga2V5IHJhdGhlciB0aGFuIGtleUZpbGUuJywgJ01JU1NJTkdfQ1JFREVOVElBTFMnKTtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcclxuICAgIH1cclxuICB9LCBfY2FsbGVlKTtcclxufSkpO1xyXG52YXIgR09PR0xFX1RPS0VOX1VSTCA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbic7XHJcbnZhciBHT09HTEVfUkVWT0tFX1RPS0VOX1VSTCA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS9yZXZva2U/dG9rZW49JztcclxudmFyIEVycm9yV2l0aENvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xyXG4gIGZ1bmN0aW9uIEVycm9yV2l0aENvZGUobWVzc2FnZSwgY29kZSkge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yV2l0aENvZGUpO1xyXG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEVycm9yV2l0aENvZGUsIFttZXNzYWdlXSk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xyXG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG4gIF9pbmhlcml0cyhFcnJvcldpdGhDb2RlLCBfRXJyb3IpO1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXJyb3JXaXRoQ29kZSk7XHJcbn0oLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcclxudmFyIF9pbkZsaWdodFJlcXVlc3QgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcclxudmFyIF9Hb29nbGVUb2tlbl9icmFuZCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xyXG52YXIgR29vZ2xlVG9rZW4gPSBleHBvcnRzLkdvb2dsZVRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBHb29nbGVUb2tlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICBDb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBHb29nbGVUb2tlbihfb3B0aW9ucykge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdvb2dsZVRva2VuKTtcclxuICAgIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyh0aGlzLCBfR29vZ2xlVG9rZW5fYnJhbmQpO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhwaXJlc0F0XCIsIHZvaWQgMCk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlcIiwgdm9pZCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleUZpbGVcIiwgdm9pZCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzc1wiLCB2b2lkIDApO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3ViXCIsIHZvaWQgMCk7XHJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY29wZVwiLCB2b2lkIDApO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmF3VG9rZW5cIiwgdm9pZCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRva2VuRXhwaXJlc1wiLCB2b2lkIDApO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW1haWxcIiwgdm9pZCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxDbGFpbXNcIiwgdm9pZCAwKTtcclxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1wiLCB2b2lkIDApO1xyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0ZXJcIiwge1xyXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gKDAsIF9nYXhpb3MucmVxdWVzdCkob3B0cyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX2luRmxpZ2h0UmVxdWVzdCwgdm9pZCAwKTtcclxuICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2NvbmZpZ3VyZSkuY2FsbCh0aGlzLCBfb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIGhhcyBleHBpcmVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSB0b2tlbiBoYXMgZXhwaXJlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoR29vZ2xlVG9rZW4sIFt7XHJcbiAgICBrZXk6IFwiYWNjZXNzVG9rZW5cIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yYXdUb2tlbiA/IHRoaXMucmF3VG9rZW4uYWNjZXNzX3Rva2VuIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJpZFRva2VuXCIsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLmlkX3Rva2VuIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJ0b2tlblR5cGVcIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yYXdUb2tlbiA/IHRoaXMucmF3VG9rZW4udG9rZW5fdHlwZSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwicmVmcmVzaFRva2VuXCIsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLnJlZnJlc2hfdG9rZW4gOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcImhhc0V4cGlyZWRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNFeHBpcmVkKCkge1xyXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgIGlmICh0aGlzLnJhd1Rva2VuICYmIHRoaXMuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5vdyA+PSB0aGlzLmV4cGlyZXNBdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0b2tlbiB3aWxsIGV4cGlyZSB3aXRoaW4gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSB0b2tlbiB3aWxsIGJlIGV4cGlyZWQgd2l0aGluIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImlzVG9rZW5FeHBpcmluZ1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVG9rZW5FeHBpcmluZygpIHtcclxuICAgICAgdmFyIF90aGlzJGVhZ2VyUmVmcmVzaFRocjtcclxuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICB2YXIgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gKF90aGlzJGVhZ2VyUmVmcmVzaFRociA9IHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSAhPT0gbnVsbCAmJiBfdGhpcyRlYWdlclJlZnJlc2hUaHIgIT09IHZvaWQgMCA/IF90aGlzJGVhZ2VyUmVmcmVzaFRociA6IDA7XHJcbiAgICAgIGlmICh0aGlzLnJhd1Rva2VuICYmIHRoaXMuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwaXJlc0F0IDw9IG5vdyArIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNhY2hlZCB0b2tlbiBvciByZXRyaWV2ZXMgYSBuZXcgb25lIGZyb20gR29vZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZ2V0VG9rZW5cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb2tlbihjYWxsYmFjaykge1xyXG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICAgIGlmIChfdHlwZW9mKGNhbGxiYWNrKSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBvcHRzID0gY2FsbGJhY2s7XHJcbiAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGZvcmNlUmVmcmVzaDogZmFsc2VcclxuICAgICAgfSwgb3B0cyk7XHJcbiAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjYiA9IGNhbGxiYWNrO1xyXG4gICAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2dldFRva2VuQXN5bmMpLmNhbGwodGhpcywgb3B0cykudGhlbihmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHQpO1xyXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2dldFRva2VuQXN5bmMpLmNhbGwodGhpcywgb3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGtleUZpbGUsIGV4dHJhY3QgdGhlIGtleSBhbmQgY2xpZW50IGVtYWlsIGlmIGF2YWlsYWJsZVxyXG4gICAgICogQHBhcmFtIGtleUZpbGUgUGF0aCB0byBhIGpzb24sIHBlbSwgb3IgcDEyIGZpbGUgdGhhdCBjb250YWlucyB0aGUga2V5LlxyXG4gICAgICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggcHJpdmF0ZUtleSBhbmQgY2xpZW50RW1haWwgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImdldENyZWRlbnRpYWxzXCIsXHJcbiAgICB2YWx1ZTogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIF9nZXRDcmVkZW50aWFscyA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihrZXlGaWxlKSB7XHJcbiAgICAgICAgdmFyIGV4dCwga2V5LCBib2R5LCBwcml2YXRlS2V5LCBjbGllbnRFbWFpbCwgX3ByaXZhdGVLZXk7XHJcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcclxuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgIGV4dCA9IHBhdGguZXh0bmFtZShrZXlGaWxlKTtcclxuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBleHQ7XHJcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSBfY29udGV4dDIudDAgPT09ICcuanNvbicgPyA0IDogX2NvbnRleHQyLnQwID09PSAnLmRlcicgPyAxMyA6IF9jb250ZXh0Mi50MCA9PT0gJy5jcnQnID8gMTMgOiBfY29udGV4dDIudDAgPT09ICcucGVtJyA/IDEzIDogX2NvbnRleHQyLnQwID09PSAnLnAxMicgPyAxNyA6IF9jb250ZXh0Mi50MCA9PT0gJy5wZngnID8gMTcgOiAxODtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVhZEZpbGUoa2V5RmlsZSwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgIGtleSA9IF9jb250ZXh0Mi5zZW50O1xyXG4gICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGtleSk7XHJcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGJvZHkucHJpdmF0ZV9rZXk7XHJcbiAgICAgICAgICAgICAgY2xpZW50RW1haWwgPSBib2R5LmNsaWVudF9lbWFpbDtcclxuICAgICAgICAgICAgICBpZiAoISghcHJpdmF0ZUtleSB8fCAhY2xpZW50RW1haWwpKSB7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCdwcml2YXRlX2tleSBhbmQgY2xpZW50X2VtYWlsIGFyZSByZXF1aXJlZC4nLCAnTUlTU0lOR19DUkVERU5USUFMUycpO1xyXG4gICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcclxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgICAgICBjbGllbnRFbWFpbDogY2xpZW50RW1haWxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xyXG4gICAgICAgICAgICAgIHJldHVybiByZWFkRmlsZShrZXlGaWxlLCAndXRmOCcpO1xyXG4gICAgICAgICAgICBjYXNlIDE1OlxyXG4gICAgICAgICAgICAgIF9wcml2YXRlS2V5ID0gX2NvbnRleHQyLnNlbnQ7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogX3ByaXZhdGVLZXlcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSAxNzpcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoQ29kZSgnKi5wMTIgY2VydGlmaWNhdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGFmdGVyIHY2LjEuMi4gJyArICdDb25zaWRlciB1dGlsaXppbmcgKi5qc29uIGZvcm1hdCBvciBjb252ZXJ0aW5nICoucDEyIHRvICoucGVtIHVzaW5nIHRoZSBPcGVuU1NMIENMSS4nLCAnVU5LTk9XTl9DRVJUSUZJQ0FURV9UWVBFJyk7XHJcbiAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aENvZGUoJ1Vua25vd24gY2VydGlmaWNhdGUgdHlwZS4gVHlwZSBpcyBkZXRlcm1pbmVkIGJhc2VkIG9uIGZpbGUgZXh0ZW5zaW9uLiAnICsgJ0N1cnJlbnQgc3VwcG9ydGVkIGV4dGVuc2lvbnMgYXJlICouanNvbiwgYW5kICoucGVtLicsICdVTktOT1dOX0NFUlRJRklDQVRFX1RZUEUnKTtcclxuICAgICAgICAgICAgY2FzZSAxOTpcclxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIF9jYWxsZWUyKTtcclxuICAgICAgfSkpO1xyXG4gICAgICBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhfeCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0Q3JlZGVudGlhbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZ2V0Q3JlZGVudGlhbHM7XHJcbiAgICB9KCkpXHJcbiAgfSwge1xyXG4gICAga2V5OiBcInJldm9rZVRva2VuXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2b2tlVG9rZW4oY2FsbGJhY2spIHtcclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX0dvb2dsZVRva2VuX2JyYW5kLCB0aGlzLCBfcmV2b2tlVG9rZW5Bc3luYykuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX3Jldm9rZVRva2VuQXN5bmMpLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG59KCk7XHJcbmZ1bmN0aW9uIF9nZXRUb2tlbkFzeW5jKF94Mikge1xyXG4gIHJldHVybiBfZ2V0VG9rZW5Bc3luYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5mdW5jdGlvbiBfZ2V0VG9rZW5Bc3luYzIoKSB7XHJcbiAgX2dldFRva2VuQXN5bmMyID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG9wdHMpIHtcclxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XHJcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBpZiAoIShfY2xhc3NQcml2YXRlRmllbGRHZXQoX2luRmxpZ2h0UmVxdWVzdCwgdGhpcykgJiYgIW9wdHMuZm9yY2VSZWZyZXNoKSkge1xyXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9pbkZsaWdodFJlcXVlc3QsIHRoaXMpKTtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI7XHJcbiAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XHJcbiAgICAgICAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KF9pbkZsaWdodFJlcXVlc3QsIHRoaXMsIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2dldFRva2VuQXN5bmNJbm5lcikuY2FsbCh0aGlzLCBvcHRzKSk7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gNjtcclxuICAgICAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfaW5GbGlnaHRSZXF1ZXN0LCB0aGlzLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goNik7XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9LCBfY2FsbGVlMywgdGhpcywgW1syLCwgNiwgOV1dKTtcclxuICB9KSk7XHJcbiAgcmV0dXJuIF9nZXRUb2tlbkFzeW5jMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRUb2tlbkFzeW5jSW5uZXIoX3gzKSB7XHJcbiAgcmV0dXJuIF9nZXRUb2tlbkFzeW5jSW5uZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX2dldFRva2VuQXN5bmNJbm5lcjIoKSB7XHJcbiAgX2dldFRva2VuQXN5bmNJbm5lcjIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQob3B0cykge1xyXG4gICAgdmFyIGNyZWRzO1xyXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcclxuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgIGlmICghKHRoaXMuaXNUb2tlbkV4cGlyaW5nKCkgPT09IGZhbHNlICYmIG9wdHMuZm9yY2VSZWZyZXNoID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UucmVzb2x2ZSh0aGlzLnJhd1Rva2VuKSk7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaWYgKCEoIXRoaXMua2V5ICYmICF0aGlzLmtleUZpbGUpKSB7XHJcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGtleSBvciBrZXlGaWxlIHNldC4nKTtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICBpZiAoISghdGhpcy5rZXkgJiYgdGhpcy5rZXlGaWxlKSkge1xyXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDExO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldENyZWRlbnRpYWxzKHRoaXMua2V5RmlsZSk7XHJcbiAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgY3JlZHMgPSBfY29udGV4dDQuc2VudDtcclxuICAgICAgICAgIHRoaXMua2V5ID0gY3JlZHMucHJpdmF0ZUtleTtcclxuICAgICAgICAgIHRoaXMuaXNzID0gY3JlZHMuY2xpZW50RW1haWwgfHwgdGhpcy5pc3M7XHJcbiAgICAgICAgICBpZiAoIWNyZWRzLmNsaWVudEVtYWlsKSB7XHJcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2Vuc3VyZUVtYWlsKS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfYXNzZXJ0Q2xhc3NCcmFuZChfR29vZ2xlVG9rZW5fYnJhbmQsIHRoaXMsIF9yZXF1ZXN0VG9rZW4pLmNhbGwodGhpcykpO1xyXG4gICAgICAgIGNhc2UgMTI6XHJcbiAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcclxuICB9KSk7XHJcbiAgcmV0dXJuIF9nZXRUb2tlbkFzeW5jSW5uZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX2Vuc3VyZUVtYWlsKCkge1xyXG4gIGlmICghdGhpcy5pc3MpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCdlbWFpbCBpcyByZXF1aXJlZC4nLCAnTUlTU0lOR19DUkVERU5USUFMUycpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfcmV2b2tlVG9rZW5Bc3luYygpIHtcclxuICByZXR1cm4gX3Jldm9rZVRva2VuQXN5bmMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX3Jldm9rZVRva2VuQXN5bmMyKCkge1xyXG4gIF9yZXZva2VUb2tlbkFzeW5jMiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcclxuICAgIHZhciB1cmw7XHJcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xyXG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdG9rZW4gdG8gcmV2b2tlLicpO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHVybCA9IEdPT0dMRV9SRVZPS0VfVE9LRU5fVVJMICsgdGhpcy5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgcmV0cnk6IHRydWVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9Hb29nbGVUb2tlbl9icmFuZCwgdGhpcywgX2NvbmZpZ3VyZSkuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmlzcyxcclxuICAgICAgICAgICAgc3ViOiB0aGlzLnN1YixcclxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcclxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxyXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZSxcclxuICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcclxuICB9KSk7XHJcbiAgcmV0dXJuIF9yZXZva2VUb2tlbkFzeW5jMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBDb25maWd1cmUgdGhlIEdvb2dsZVRva2VuIGZvciByZS11c2UuXHJcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIF9jb25maWd1cmUoKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gIHRoaXMua2V5RmlsZSA9IG9wdGlvbnMua2V5RmlsZTtcclxuICB0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xyXG4gIHRoaXMucmF3VG9rZW4gPSB1bmRlZmluZWQ7XHJcbiAgdGhpcy5pc3MgPSBvcHRpb25zLmVtYWlsIHx8IG9wdGlvbnMuaXNzO1xyXG4gIHRoaXMuc3ViID0gb3B0aW9ucy5zdWI7XHJcbiAgdGhpcy5hZGRpdGlvbmFsQ2xhaW1zID0gb3B0aW9ucy5hZGRpdGlvbmFsQ2xhaW1zO1xyXG4gIGlmIChfdHlwZW9mKG9wdGlvbnMuc2NvcGUpID09PSAnb2JqZWN0Jykge1xyXG4gICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGUuam9pbignICcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZTtcclxuICB9XHJcbiAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBvcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcclxuICBpZiAob3B0aW9ucy50cmFuc3BvcnRlcikge1xyXG4gICAgdGhpcy50cmFuc3BvcnRlciA9IG9wdGlvbnMudHJhbnNwb3J0ZXI7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXF1ZXN0IHRoZSB0b2tlbiBmcm9tIEdvb2dsZS5cclxuICovXHJcbmZ1bmN0aW9uIF9yZXF1ZXN0VG9rZW4oKSB7XHJcbiAgcmV0dXJuIF9yZXF1ZXN0VG9rZW4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gX3JlcXVlc3RUb2tlbjIoKSB7XHJcbiAgX3JlcXVlc3RUb2tlbjIgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoKSB7XHJcbiAgICB2YXIgaWF0LCBhZGRpdGlvbmFsQ2xhaW1zLCBwYXlsb2FkLCBzaWduZWRKV1QsIHIsIF9yZXNwb25zZSwgX3Jlc3BvbnNlMiwgYm9keSwgZGVzYztcclxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XHJcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBpYXQgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zID0gdGhpcy5hZGRpdGlvbmFsQ2xhaW1zIHx8IHt9O1xyXG4gICAgICAgICAgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgICBpc3M6IHRoaXMuaXNzLFxyXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZSxcclxuICAgICAgICAgICAgYXVkOiBHT09HTEVfVE9LRU5fVVJMLFxyXG4gICAgICAgICAgICBleHA6IGlhdCArIDM2MDAsXHJcbiAgICAgICAgICAgIGlhdDogaWF0LFxyXG4gICAgICAgICAgICBzdWI6IHRoaXMuc3ViXHJcbiAgICAgICAgICB9LCBhZGRpdGlvbmFsQ2xhaW1zKTtcclxuICAgICAgICAgIHNpZ25lZEpXVCA9IGp3cy5zaWduKHtcclxuICAgICAgICAgICAgaGVhZGVyOiB7XHJcbiAgICAgICAgICAgICAgYWxnOiAnUlMyNTYnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIHNlY3JldDogdGhpcy5rZXlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSA0O1xyXG4gICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA3O1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICB1cmw6IEdPT0dMRV9UT0tFTl9VUkwsXHJcbiAgICAgICAgICAgIGRhdGE6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICAgICAgICAgIGdyYW50X3R5cGU6ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpqd3QtYmVhcmVyJyxcclxuICAgICAgICAgICAgICBhc3NlcnRpb246IHNpZ25lZEpXVFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgIHJldHJ5Q29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgaHR0cE1ldGhvZHNUb1JldHJ5OiBbJ1BPU1QnXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICByID0gX2NvbnRleHQ2LnNlbnQ7XHJcbiAgICAgICAgICB0aGlzLnJhd1Rva2VuID0gci5kYXRhO1xyXG4gICAgICAgICAgdGhpcy5leHBpcmVzQXQgPSByLmRhdGEuZXhwaXJlc19pbiA9PT0gbnVsbCB8fCByLmRhdGEuZXhwaXJlc19pbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGlhdCArIHIuZGF0YS5leHBpcmVzX2luKSAqIDEwMDA7XHJcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJhd1Rva2VuKTtcclxuICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxMztcclxuICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDQpO1xyXG4gICAgICAgICAgdGhpcy5yYXdUb2tlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIHRoaXMudG9rZW5FeHBpcmVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgYm9keSA9IF9jb250ZXh0Ni50MC5yZXNwb25zZSAmJiAoX3Jlc3BvbnNlID0gX2NvbnRleHQ2LnQwLnJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfcmVzcG9uc2UgIT09IHZvaWQgMCAmJiBfcmVzcG9uc2UuZGF0YSA/IChfcmVzcG9uc2UyID0gX2NvbnRleHQ2LnQwLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfcmVzcG9uc2UyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzcG9uc2UyLmRhdGEgOiB7fTtcclxuICAgICAgICAgIGlmIChib2R5LmVycm9yKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSBib2R5LmVycm9yX2Rlc2NyaXB0aW9uID8gXCI6IFwiLmNvbmNhdChib2R5LmVycm9yX2Rlc2NyaXB0aW9uKSA6ICcnO1xyXG4gICAgICAgICAgICBfY29udGV4dDYudDAubWVzc2FnZSA9IFwiXCIuY29uY2F0KGJvZHkuZXJyb3IpLmNvbmNhdChkZXNjKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IF9jb250ZXh0Ni50MDtcclxuICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9LCBfY2FsbGVlNiwgdGhpcywgW1s0LCAxM11dKTtcclxuICB9KSk7XHJcbiAgcmV0dXJuIF9yZXF1ZXN0VG9rZW4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gtoken/build/cjs/src/index.cjs\n");

/***/ })

};
;